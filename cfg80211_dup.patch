--- a/net/wireless/core.c	2015-06-23 11:07:42.882851337 +0200
+++ b/net/wireless/core.c	2015-06-23 14:54:17.301857456 +0200
@@ -221,11 +221,11 @@ void cfg80211_stop_p2p_device(struct cfg
 	if (rdev->scan_req && rdev->scan_req->wdev == wdev) {
 		if (WARN_ON(!rdev->scan_req->notified))
 			rdev->scan_req->aborted = true;
-		___cfg80211_scan_done(rdev, false);
+		___cfg80211_scan_done_dup(rdev, false);
 	}
 }
 
-void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy)
+void cfg80211_shutdown_all_interfaces_dup(struct wiphy *wiphy)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 	struct wireless_dev *wdev;
@@ -247,7 +247,7 @@ void cfg80211_shutdown_all_interfaces(st
 		}
 	}
 }
-EXPORT_SYMBOL_GPL(cfg80211_shutdown_all_interfaces);
+EXPORT_SYMBOL_GPL(cfg80211_shutdown_all_interfaces_dup);
 
 static int cfg80211_rfkill_set_block(void *data, bool blocked)
 {
@@ -257,7 +257,7 @@ static int cfg80211_rfkill_set_block(voi
 		return 0;
 
 	rtnl_lock();
-	cfg80211_shutdown_all_interfaces(&rdev->wiphy);
+	cfg80211_shutdown_all_interfaces_dup(&rdev->wiphy);
 	rtnl_unlock();
 
 	return 0;
@@ -324,7 +324,7 @@ static void cfg80211_destroy_iface_wk(st
 
 /* exported functions */
 
-struct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,
+struct wiphy *wiphy_new_nm_dup(const struct cfg80211_ops *ops, int sizeof_priv,
 			   const char *requested_name)
 {
 	static atomic_t wiphy_counter = ATOMIC_INIT(0);
@@ -393,8 +393,8 @@ use_default_name:
 	spin_lock_init(&rdev->beacon_registrations_lock);
 	spin_lock_init(&rdev->bss_lock);
 	INIT_LIST_HEAD(&rdev->bss_list);
-	INIT_WORK(&rdev->scan_done_wk, __cfg80211_scan_done);
-	INIT_WORK(&rdev->sched_scan_results_wk, __cfg80211_sched_scan_results);
+	INIT_WORK(&rdev->scan_done_wk, __cfg80211_scan_done_dup);
+	INIT_WORK(&rdev->sched_scan_results_wk, __cfg80211_sched_scan_results_dup);
 	INIT_DELAYED_WORK(&rdev->dfs_update_channels_wk,
 			  cfg80211_dfs_channels_update_work);
 #ifdef CONFIG_CFG80211_WEXT
@@ -446,7 +446,7 @@ use_default_name:
 
 	return &rdev->wiphy;
 }
-EXPORT_SYMBOL(wiphy_new_nm);
+EXPORT_SYMBOL(wiphy_new_nm_dup);
 
 static int wiphy_verify_combinations(struct wiphy *wiphy)
 {
@@ -523,7 +523,7 @@ static int wiphy_verify_combinations(str
 	return 0;
 }
 
-int wiphy_register(struct wiphy *wiphy)
+int wiphy_register_dup(struct wiphy *wiphy)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 	int res;
@@ -632,7 +632,7 @@ int wiphy_register(struct wiphy *wiphy)
 
 		/*
 		 * Since we use a u32 for rate bitmaps in
-		 * ieee80211_get_response_rate, we cannot
+		 * ieee80211_get_response_rate_dup, we cannot
 		 * have more than 32 legacy rates.
 		 */
 		if (WARN_ON(sband->n_bitrates > 32))
@@ -709,15 +709,15 @@ int wiphy_register(struct wiphy *wiphy)
 	if (res) {
 		rfkill_destroy(rdev->rfkill);
 		rdev->rfkill = NULL;
-		wiphy_unregister(&rdev->wiphy);
+		wiphy_unregister_dup(&rdev->wiphy);
 		return res;
 	}
 
 	return 0;
 }
-EXPORT_SYMBOL(wiphy_register);
+EXPORT_SYMBOL(wiphy_register_dup);
 
-void wiphy_rfkill_start_polling(struct wiphy *wiphy)
+void wiphy_rfkill_start_polling_dup(struct wiphy *wiphy)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
@@ -726,17 +726,17 @@ void wiphy_rfkill_start_polling(struct w
 	rdev->rfkill_ops.poll = cfg80211_rfkill_poll;
 	rfkill_resume_polling(rdev->rfkill);
 }
-EXPORT_SYMBOL(wiphy_rfkill_start_polling);
+EXPORT_SYMBOL(wiphy_rfkill_start_polling_dup);
 
-void wiphy_rfkill_stop_polling(struct wiphy *wiphy)
+void wiphy_rfkill_stop_polling_dup(struct wiphy *wiphy)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
 	rfkill_pause_polling(rdev->rfkill);
 }
-EXPORT_SYMBOL(wiphy_rfkill_stop_polling);
+EXPORT_SYMBOL(wiphy_rfkill_stop_polling_dup);
 
-void wiphy_unregister(struct wiphy *wiphy)
+void wiphy_unregister_dup(struct wiphy *wiphy)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
@@ -788,7 +788,7 @@ void wiphy_unregister(struct wiphy *wiph
 	cfg80211_rdev_free_wowlan(rdev);
 	cfg80211_rdev_free_coalesce(rdev);
 }
-EXPORT_SYMBOL(wiphy_unregister);
+EXPORT_SYMBOL(wiphy_unregister_dup);
 
 void cfg80211_dev_free(struct cfg80211_registered_device *rdev)
 {
@@ -800,26 +800,26 @@ void cfg80211_dev_free(struct cfg80211_r
 		kfree(reg);
 	}
 	list_for_each_entry_safe(scan, tmp, &rdev->bss_list, list)
-		cfg80211_put_bss(&rdev->wiphy, &scan->pub);
+		cfg80211_put_bss_dup(&rdev->wiphy, &scan->pub);
 	kfree(rdev);
 }
 
-void wiphy_free(struct wiphy *wiphy)
+void wiphy_free_dup(struct wiphy *wiphy)
 {
 	put_device(&wiphy->dev);
 }
-EXPORT_SYMBOL(wiphy_free);
+EXPORT_SYMBOL(wiphy_free_dup);
 
-void wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked)
+void wiphy_rfkill_set_hw_state_dup(struct wiphy *wiphy, bool blocked)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
 	if (rfkill_set_hw_state(rdev->rfkill, blocked))
 		schedule_work(&rdev->rfkill_sync);
 }
-EXPORT_SYMBOL(wiphy_rfkill_set_hw_state);
+EXPORT_SYMBOL(wiphy_rfkill_set_hw_state_dup);
 
-void cfg80211_unregister_wdev(struct wireless_dev *wdev)
+void cfg80211_unregister_wdev_dup(struct wireless_dev *wdev)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
 
@@ -840,7 +840,7 @@ void cfg80211_unregister_wdev(struct wir
 		break;
 	}
 }
-EXPORT_SYMBOL(cfg80211_unregister_wdev);
+EXPORT_SYMBOL(cfg80211_unregister_wdev_dup);
 
 static struct device_type wiphy_type = {
 	.name	= "wlan",
@@ -917,14 +917,14 @@ void cfg80211_leave(struct cfg80211_regi
 	wdev_unlock(wdev);
 }
 
-void cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,
+void cfg80211_stop_iface_dup(struct wiphy *wiphy, struct wireless_dev *wdev,
 			 gfp_t gfp)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 	struct cfg80211_event *ev;
 	unsigned long flags;
 
-	trace_cfg80211_stop_iface(wiphy, wdev);
+	trace_cfg80211_stop_iface_dup(wiphy, wdev);
 
 	ev = kzalloc(sizeof(*ev), gfp);
 	if (!ev)
@@ -937,7 +937,7 @@ void cfg80211_stop_iface(struct wiphy *w
 	spin_unlock_irqrestore(&wdev->event_lock, flags);
 	queue_work(cfg80211_wq, &rdev->event_work);
 }
-EXPORT_SYMBOL(cfg80211_stop_iface);
+EXPORT_SYMBOL(cfg80211_stop_iface_dup);
 
 static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
 					 unsigned long state, void *ptr)
@@ -1010,7 +1010,7 @@ static int cfg80211_netdev_notifier_call
 		if (rdev->scan_req && rdev->scan_req->wdev == wdev) {
 			if (WARN_ON(!rdev->scan_req->notified))
 				rdev->scan_req->aborted = true;
-			___cfg80211_scan_done(rdev, false);
+			___cfg80211_scan_done_dup(rdev, false);
 		}
 
 		if (WARN_ON(rdev->sched_scan_req &&
@@ -1102,7 +1102,7 @@ static int cfg80211_netdev_notifier_call
 
 		if (WARN_ON(wdev->current_bss)) {
 			cfg80211_unhold_bss(wdev->current_bss);
-			cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
+			cfg80211_put_bss_dup(wdev->wiphy, &wdev->current_bss->pub);
 			wdev->current_bss = NULL;
 		}
 		break;
@@ -1159,7 +1159,7 @@ static int __init cfg80211_init(void)
 	if (err)
 		goto out_fail_nl80211;
 
-	ieee80211_debugfs_dir = debugfs_create_dir("ieee80211", NULL);
+	ieee80211_debugfs_dir = debugfs_create_dir("ieee80211_dup", NULL);
 
 	err = regulatory_init();
 	if (err)
--- a/net/wireless/sysfs.c	2015-06-26 10:50:15.000000000 +0200
+++ b/net/wireless/sysfs.c	2015-06-24 12:59:23.000000000 +0200
@@ -145,7 +145,7 @@ static const void *wiphy_namespace(struc
 #endif
 
 struct class ieee80211_class = {
-	.name = "ieee80211",
+	.name = "ieee80211_dup",
 	.owner = THIS_MODULE,
 	.dev_release = wiphy_dev_release,
 	.dev_attrs = ieee80211_dev_attrs,
--- a/net/wireless/core.h	2015-06-23 11:07:42.882851337 +0200
+++ b/net/wireless/core.h	2015-06-23 14:54:17.347857663 +0200
@@ -268,7 +268,7 @@ int __cfg80211_leave_ibss(struct cfg8021
 			  struct net_device *dev, bool nowext);
 int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, bool nowext);
-void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+void __cfg80211_ibss_joined_dup(struct net_device *dev, const u8 *bssid,
 			    struct ieee80211_channel *channel);
 int cfg80211_ibss_wext_join(struct cfg80211_registered_device *rdev,
 			    struct wireless_dev *wdev);
@@ -356,17 +356,17 @@ int cfg80211_connect(struct cfg80211_reg
 		     struct cfg80211_connect_params *connect,
 		     struct cfg80211_cached_keys *connkeys,
 		     const u8 *prev_bssid);
-void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
+void __cfg80211_connect_result_dup(struct net_device *dev, const u8 *bssid,
 			       const u8 *req_ie, size_t req_ie_len,
 			       const u8 *resp_ie, size_t resp_ie_len,
 			       u16 status, bool wextev,
 			       struct cfg80211_bss *bss);
-void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
+void __cfg80211_disconnected_dup(struct net_device *dev, const u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap);
 int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			struct net_device *dev, u16 reason,
 			bool wextev);
-void __cfg80211_roamed(struct wireless_dev *wdev,
+void __cfg80211_roamed_dup(struct wireless_dev *wdev,
 		       struct cfg80211_bss *bss,
 		       const u8 *req_ie, size_t req_ie_len,
 		       const u8 *resp_ie, size_t resp_ie_len);
@@ -388,10 +388,10 @@ bool cfg80211_supported_cipher_suite(str
 int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,
 				   struct key_params *params, int key_idx,
 				   bool pairwise, const u8 *mac_addr);
-void __cfg80211_scan_done(struct work_struct *wk);
-void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
+void __cfg80211_scan_done_dup(struct work_struct *wk);
+void ___cfg80211_scan_done_dup(struct cfg80211_registered_device *rdev,
 			   bool send_message);
-void __cfg80211_sched_scan_results(struct work_struct *wk);
+void __cfg80211_sched_scan_results_dup(struct work_struct *wk);
 int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
 			       bool driver_initiated);
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev);
--- a/net/wireless/genetlink-compat.c	2015-06-23 11:07:42.882851337 +0200
+++ b/net/wireless/genetlink-compat.c	2015-06-23 14:54:17.408857937 +0200
@@ -68,7 +68,7 @@ found:
 	return err;
 }
 
-int compat_genl_register_family(struct genl_family *family)
+int compat_genl_register_family_dup(struct genl_family *family)
 {
 	int i, ret;
 
@@ -108,16 +108,16 @@ int compat_genl_register_family(struct g
 	return ret;
 
 error_ops:
-	compat_genl_unregister_family(family);
+	compat_genl_unregister_family_dup(family);
 	return ret;
 }
-EXPORT_SYMBOL(compat_genl_register_family);
+EXPORT_SYMBOL(compat_genl_register_family_dup);
 
-int compat_genl_unregister_family(struct genl_family *family)
+int compat_genl_unregister_family_dup(struct genl_family *family)
 {
 	int err;
 	err = genl_unregister_family(&family->family);
 	list_del(&family->list);
 	return err;
 }
-EXPORT_SYMBOL(compat_genl_unregister_family);
+EXPORT_SYMBOL(compat_genl_unregister_family_dup);
--- a/net/wireless/genetlink-compat.h	2015-06-23 11:07:42.883851349 +0200
+++ b/net/wireless/genetlink-compat.h	2015-06-23 14:54:17.453858139 +0200
@@ -53,7 +53,7 @@ struct compat_genl_family {
 };
 #define genl_family compat_genl_family
 
-extern int compat_genl_register_family(struct genl_family *family);
+extern int compat_genl_register_family_dup(struct genl_family *family);
 
 static inline int
 _genl_register_family_with_ops_grps(struct genl_family *family,
@@ -66,7 +66,7 @@ _genl_register_family_with_ops_grps(stru
 	family->n_ops = n_ops;
 	family->mcgrps = mcgrps;
 	family->n_mcgrps = n_mcgrps;
-	return compat_genl_register_family(family);
+	return compat_genl_register_family_dup(family);
 }
 
 #define genl_register_family_with_ops_groups(family, ops, grps)	\
@@ -74,7 +74,7 @@ _genl_register_family_with_ops_grps(stru
 					    (ops), ARRAY_SIZE(ops),	\
 					    (grps), ARRAY_SIZE(grps))
 
-#define genl_unregister_family compat_genl_unregister_family
+#define genl_unregister_family compat_genl_unregister_family_dup
 
 int genl_unregister_family(struct genl_family *family);
 
--- a/net/wireless/chan.c	2015-06-23 11:07:42.882851337 +0200
+++ b/net/wireless/chan.c	2015-06-23 14:54:17.504858369 +0200
@@ -12,7 +12,7 @@
 #include "core.h"
 #include "rdev-ops.h"
 
-void cfg80211_chandef_create(struct cfg80211_chan_def *chandef,
+void cfg80211_chandef_create_dup(struct cfg80211_chan_def *chandef,
 			     struct ieee80211_channel *chan,
 			     enum nl80211_channel_type chan_type)
 {
@@ -43,9 +43,9 @@ void cfg80211_chandef_create(struct cfg8
 		WARN_ON(1);
 	}
 }
-EXPORT_SYMBOL(cfg80211_chandef_create);
+EXPORT_SYMBOL(cfg80211_chandef_create_dup);
 
-bool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef)
+bool cfg80211_chandef_valid_dup(const struct cfg80211_chan_def *chandef)
 {
 	u32 control_freq;
 
@@ -112,7 +112,7 @@ bool cfg80211_chandef_valid(const struct
 
 	return true;
 }
-EXPORT_SYMBOL(cfg80211_chandef_valid);
+EXPORT_SYMBOL(cfg80211_chandef_valid_dup);
 
 static void chandef_primary_freqs(const struct cfg80211_chan_def *c,
 				  u32 *pri40, u32 *pri80)
@@ -183,7 +183,7 @@ static int cfg80211_chandef_get_width(co
 }
 
 const struct cfg80211_chan_def *
-cfg80211_chandef_compatible(const struct cfg80211_chan_def *c1,
+cfg80211_chandef_compatible_dup(const struct cfg80211_chan_def *c1,
 			    const struct cfg80211_chan_def *c2)
 {
 	u32 c1_pri40, c1_pri80, c2_pri40, c2_pri80;
@@ -235,7 +235,7 @@ cfg80211_chandef_compatible(const struct
 		return c1;
 	return c2;
 }
-EXPORT_SYMBOL(cfg80211_chandef_compatible);
+EXPORT_SYMBOL(cfg80211_chandef_compatible_dup);
 
 static void cfg80211_set_chans_dfs_state(struct wiphy *wiphy, u32 center_freq,
 					 u32 bandwidth,
@@ -262,7 +262,7 @@ void cfg80211_set_dfs_state(struct wiphy
 {
 	int width;
 
-	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+	if (WARN_ON(!cfg80211_chandef_valid_dup(chandef)))
 		return;
 
 	width = cfg80211_chandef_get_width(chandef);
@@ -326,14 +326,14 @@ static int cfg80211_get_chans_dfs_requir
 }
 
 
-int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
+int cfg80211_chandef_dfs_required_dup(struct wiphy *wiphy,
 				  const struct cfg80211_chan_def *chandef,
 				  enum nl80211_iftype iftype)
 {
 	int width;
 	int ret;
 
-	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+	if (WARN_ON(!cfg80211_chandef_valid_dup(chandef)))
 		return -EINVAL;
 
 	switch (iftype) {
@@ -380,7 +380,7 @@ int cfg80211_chandef_dfs_required(struct
 
 	return 0;
 }
-EXPORT_SYMBOL(cfg80211_chandef_dfs_required);
+EXPORT_SYMBOL(cfg80211_chandef_dfs_required_dup);
 
 static int cfg80211_get_chans_dfs_usable(struct wiphy *wiphy,
 					 u32 center_freq,
@@ -425,7 +425,7 @@ bool cfg80211_chandef_dfs_usable(struct
 	int width;
 	int r1, r2 = 0;
 
-	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+	if (WARN_ON(!cfg80211_chandef_valid_dup(chandef)))
 		return false;
 
 	width = cfg80211_chandef_get_width(chandef);
@@ -493,7 +493,7 @@ static bool cfg80211_chandef_dfs_availab
 	int width;
 	int r;
 
-	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+	if (WARN_ON(!cfg80211_chandef_valid_dup(chandef)))
 		return false;
 
 	width = cfg80211_chandef_get_width(chandef);
@@ -557,7 +557,7 @@ cfg80211_chandef_dfs_cac_time(struct wip
 	int width;
 	unsigned int t1 = 0, t2 = 0;
 
-	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+	if (WARN_ON(!cfg80211_chandef_valid_dup(chandef)))
 		return 0;
 
 	width = cfg80211_chandef_get_width(chandef);
@@ -597,7 +597,7 @@ static bool cfg80211_secondary_chans_ok(
 	return true;
 }
 
-bool cfg80211_chandef_usable(struct wiphy *wiphy,
+bool cfg80211_chandef_usable_dup(struct wiphy *wiphy,
 			     const struct cfg80211_chan_def *chandef,
 			     u32 prohibited_flags)
 {
@@ -605,7 +605,7 @@ bool cfg80211_chandef_usable(struct wiph
 	struct ieee80211_sta_vht_cap *vht_cap;
 	u32 width, control_freq, cap;
 
-	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+	if (WARN_ON(!cfg80211_chandef_valid_dup(chandef)))
 		return false;
 
 	ht_cap = &wiphy->bands[chandef->chan->band]->ht_cap;
@@ -695,7 +695,7 @@ bool cfg80211_chandef_usable(struct wiph
 	return cfg80211_secondary_chans_ok(wiphy, chandef->center_freq2,
 					   width, prohibited_flags);
 }
-EXPORT_SYMBOL(cfg80211_chandef_usable);
+EXPORT_SYMBOL(cfg80211_chandef_usable_dup);
 
 /*
  * For GO only, check if the channel can be used under permissive conditions
@@ -780,7 +780,7 @@ static bool cfg80211_go_permissive_chan(
 	return false;
 }
 
-bool cfg80211_reg_can_beacon(struct wiphy *wiphy,
+bool cfg80211_reg_can_beacon_dup(struct wiphy *wiphy,
 			     struct cfg80211_chan_def *chandef,
 			     enum nl80211_iftype iftype)
 {
@@ -789,7 +789,7 @@ bool cfg80211_reg_can_beacon(struct wiph
 	u32 prohibited_flags = IEEE80211_CHAN_DISABLED |
 			       IEEE80211_CHAN_RADAR;
 
-	trace_cfg80211_reg_can_beacon(wiphy, chandef, iftype);
+	trace_cfg80211_reg_can_beacon_dup(wiphy, chandef, iftype);
 
 	/*
 	 * Under certain conditions suggested by the some regulatory bodies
@@ -801,18 +801,18 @@ bool cfg80211_reg_can_beacon(struct wiph
 	    !cfg80211_go_permissive_chan(rdev, chandef->chan))
 		prohibited_flags |= IEEE80211_CHAN_NO_IR;
 
-	if (cfg80211_chandef_dfs_required(wiphy, chandef, iftype) > 0 &&
+	if (cfg80211_chandef_dfs_required_dup(wiphy, chandef, iftype) > 0 &&
 	    cfg80211_chandef_dfs_available(wiphy, chandef)) {
 		/* We can skip IEEE80211_CHAN_NO_IR if chandef dfs available */
 		prohibited_flags = IEEE80211_CHAN_DISABLED;
 	}
 
-	res = cfg80211_chandef_usable(wiphy, chandef, prohibited_flags);
+	res = cfg80211_chandef_usable_dup(wiphy, chandef, prohibited_flags);
 
 	trace_cfg80211_return_bool(res);
 	return res;
 }
-EXPORT_SYMBOL(cfg80211_reg_can_beacon);
+EXPORT_SYMBOL(cfg80211_reg_can_beacon_dup);
 
 int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
 				 struct cfg80211_chan_def *chandef)
@@ -875,7 +875,7 @@ cfg80211_get_chan_state(struct wireless_
 			*chan = wdev->chandef.chan;
 			*chanmode = CHAN_MODE_SHARED;
 
-			ret = cfg80211_chandef_dfs_required(wdev->wiphy,
+			ret = cfg80211_chandef_dfs_required_dup(wdev->wiphy,
 							    &wdev->chandef,
 							    wdev->iftype);
 			WARN_ON(ret < 0);
@@ -888,7 +888,7 @@ cfg80211_get_chan_state(struct wireless_
 			*chan = wdev->chandef.chan;
 			*chanmode = CHAN_MODE_SHARED;
 
-			ret = cfg80211_chandef_dfs_required(wdev->wiphy,
+			ret = cfg80211_chandef_dfs_required_dup(wdev->wiphy,
 							    &wdev->chandef,
 							    wdev->iftype);
 			WARN_ON(ret < 0);
--- a/net/wireless/ibss.c	2015-06-23 11:07:42.883851349 +0200
+++ b/net/wireless/ibss.c	2015-06-23 14:54:17.555858598 +0200
@@ -14,7 +14,7 @@
 #include "rdev-ops.h"
 
 
-void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+void __cfg80211_ibss_joined_dup(struct net_device *dev, const u8 *bssid,
 			    struct ieee80211_channel *channel)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -29,7 +29,7 @@ void __cfg80211_ibss_joined(struct net_d
 	if (!wdev->ssid_len)
 		return;
 
-	bss = cfg80211_get_bss(wdev->wiphy, channel, bssid, NULL, 0,
+	bss = cfg80211_get_bss_dup(wdev->wiphy, channel, bssid, NULL, 0,
 			       WLAN_CAPABILITY_IBSS, WLAN_CAPABILITY_IBSS);
 
 	if (WARN_ON(!bss))
@@ -37,7 +37,7 @@ void __cfg80211_ibss_joined(struct net_d
 
 	if (wdev->current_bss) {
 		cfg80211_unhold_bss(wdev->current_bss);
-		cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
+		cfg80211_put_bss_dup(wdev->wiphy, &wdev->current_bss->pub);
 	}
 
 	cfg80211_hold_bss(bss_from_pub(bss));
@@ -50,11 +50,11 @@ void __cfg80211_ibss_joined(struct net_d
 #ifdef CONFIG_CFG80211_WEXT
 	memset(&wrqu, 0, sizeof(wrqu));
 	memcpy(wrqu.ap_addr.sa_data, bssid, ETH_ALEN);
-	wireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);
+	wireless_send_event_dup(dev, SIOCGIWAP, &wrqu, NULL);
 #endif
 }
 
-void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+void cfg80211_ibss_joined_dup(struct net_device *dev, const u8 *bssid,
 			  struct ieee80211_channel *channel, gfp_t gfp)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -62,7 +62,7 @@ void cfg80211_ibss_joined(struct net_dev
 	struct cfg80211_event *ev;
 	unsigned long flags;
 
-	trace_cfg80211_ibss_joined(dev, bssid, channel);
+	trace_cfg80211_ibss_joined_dup(dev, bssid, channel);
 
 	if (WARN_ON(!channel))
 		return;
@@ -80,7 +80,7 @@ void cfg80211_ibss_joined(struct net_dev
 	spin_unlock_irqrestore(&wdev->event_lock, flags);
 	queue_work(cfg80211_wq, &rdev->event_work);
 }
-EXPORT_SYMBOL(cfg80211_ibss_joined);
+EXPORT_SYMBOL(cfg80211_ibss_joined_dup);
 
 static int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
 				struct net_device *dev,
@@ -176,7 +176,7 @@ static void __cfg80211_clear_ibss(struct
 
 	if (wdev->current_bss) {
 		cfg80211_unhold_bss(wdev->current_bss);
-		cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
+		cfg80211_put_bss_dup(wdev->wiphy, &wdev->current_bss->pub);
 	}
 
 	wdev->current_bss = NULL;
@@ -273,7 +273,7 @@ int cfg80211_ibss_wext_join(struct cfg80
 		if (!new_chan)
 			return -EINVAL;
 
-		cfg80211_chandef_create(&wdev->wext.ibss.chandef, new_chan,
+		cfg80211_chandef_create_dup(&wdev->wext.ibss.chandef, new_chan,
 					NL80211_CHAN_NO_HT);
 	}
 
@@ -348,7 +348,7 @@ int cfg80211_ibss_wext_siwfreq(struct ne
 		return err;
 
 	if (chan) {
-		cfg80211_chandef_create(&wdev->wext.ibss.chandef, chan,
+		cfg80211_chandef_create_dup(&wdev->wext.ibss.chandef, chan,
 					NL80211_CHAN_NO_HT);
 		wdev->wext.ibss.channel_fixed = true;
 	} else {
--- a/net/wireless/lib80211.c	2015-06-23 11:07:42.883851349 +0200
+++ b/net/wireless/lib80211.c	2015-06-23 14:54:17.606858827 +0200
@@ -25,7 +25,7 @@
 
 #include <net/lib80211.h>
 
-#define DRV_NAME        "lib80211"
+#define DRV_NAME        "lib80211_dup"
 
 #define DRV_DESCRIPTION	"common routines for IEEE802.11 drivers"

@@ -46,7 +46,7 @@ static void lib80211_crypt_deinit_entrie
 static void lib80211_crypt_quiescing(struct lib80211_crypt_info *info);
 static void lib80211_crypt_deinit_handler(unsigned long data);
 
-int lib80211_crypt_info_init(struct lib80211_crypt_info *info, char *name,
+int lib80211_crypt_info_init_dup(struct lib80211_crypt_info *info, char *name,
 				spinlock_t *lock)
 {
 	memset(info, 0, sizeof(*info));
@@ -60,9 +60,9 @@ int lib80211_crypt_info_init(struct lib8
 
 	return 0;
 }
-EXPORT_SYMBOL(lib80211_crypt_info_init);
+EXPORT_SYMBOL(lib80211_crypt_info_init_dup);
 
-void lib80211_crypt_info_free(struct lib80211_crypt_info *info)
+void lib80211_crypt_info_free_dup(struct lib80211_crypt_info *info)
 {
 	int i;
 
@@ -82,7 +82,7 @@ void lib80211_crypt_info_free(struct lib
                 }
         }
 }
-EXPORT_SYMBOL(lib80211_crypt_info_free);
+EXPORT_SYMBOL(lib80211_crypt_info_free_dup);
 
 static void lib80211_crypt_deinit_entries(struct lib80211_crypt_info *info,
 					  int force)
@@ -133,7 +133,7 @@ static void lib80211_crypt_deinit_handle
 	spin_unlock_irqrestore(info->lock, flags);
 }
 
-void lib80211_crypt_delayed_deinit(struct lib80211_crypt_info *info,
+void lib80211_crypt_delayed_deinit_dup(struct lib80211_crypt_info *info,
 				    struct lib80211_crypt_data **crypt)
 {
 	struct lib80211_crypt_data *tmp;
@@ -159,9 +159,9 @@ void lib80211_crypt_delayed_deinit(struc
 	}
 	spin_unlock_irqrestore(info->lock, flags);
 }
-EXPORT_SYMBOL(lib80211_crypt_delayed_deinit);
+EXPORT_SYMBOL(lib80211_crypt_delayed_deinit_dup);
 
-int lib80211_register_crypto_ops(struct lib80211_crypto_ops *ops)
+int lib80211_register_crypto_ops_dup(struct lib80211_crypto_ops *ops)
 {
 	unsigned long flags;
 	struct lib80211_crypto_alg *alg;
@@ -181,9 +181,9 @@ int lib80211_register_crypto_ops(struct
 
 	return 0;
 }
-EXPORT_SYMBOL(lib80211_register_crypto_ops);
+EXPORT_SYMBOL(lib80211_register_crypto_ops_dup);
 
-int lib80211_unregister_crypto_ops(struct lib80211_crypto_ops *ops)
+int lib80211_unregister_crypto_ops_dup(struct lib80211_crypto_ops *ops)
 {
 	struct lib80211_crypto_alg *alg;
 	unsigned long flags;
@@ -204,9 +204,9 @@ int lib80211_unregister_crypto_ops(struc
 	kfree(alg);
 	return 0;
 }
-EXPORT_SYMBOL(lib80211_unregister_crypto_ops);
+EXPORT_SYMBOL(lib80211_unregister_crypto_ops_dup);
 
-struct lib80211_crypto_ops *lib80211_get_crypto_ops(const char *name)
+struct lib80211_crypto_ops *lib80211_get_crypto_ops_dup(const char *name)
 {
 	struct lib80211_crypto_alg *alg;
 	unsigned long flags;
@@ -223,7 +223,7 @@ struct lib80211_crypto_ops *lib80211_get
 	spin_unlock_irqrestore(&lib80211_crypto_lock, flags);
 	return alg->ops;
 }
-EXPORT_SYMBOL(lib80211_get_crypto_ops);
+EXPORT_SYMBOL(lib80211_get_crypto_ops_dup);
 
 static void *lib80211_crypt_null_init(int keyidx)
 {
@@ -244,12 +244,12 @@ static struct lib80211_crypto_ops lib802
 static int __init lib80211_init(void)
 {
 	pr_info(DRV_DESCRIPTION "\n");
-	return lib80211_register_crypto_ops(&lib80211_crypt_null);
+	return lib80211_register_crypto_ops_dup(&lib80211_crypt_null);
 }
 
 static void __exit lib80211_exit(void)
 {
-	lib80211_unregister_crypto_ops(&lib80211_crypt_null);
+	lib80211_unregister_crypto_ops_dup(&lib80211_crypt_null);
 	BUG_ON(!list_empty(&lib80211_crypto_algs));
 }
 
--- a/net/wireless/lib80211_crypt_ccmp.c	2015-06-23 11:07:42.883851349 +0200
+++ b/net/wireless/lib80211_crypt_ccmp.c	2015-06-23 14:54:17.656859051 +0200
@@ -467,12 +467,12 @@ static struct lib80211_crypto_ops lib802
 
 static int __init lib80211_crypto_ccmp_init(void)
 {
-	return lib80211_register_crypto_ops(&lib80211_crypt_ccmp);
+	return lib80211_register_crypto_ops_dup(&lib80211_crypt_ccmp);
 }
 
 static void __exit lib80211_crypto_ccmp_exit(void)
 {
-	lib80211_unregister_crypto_ops(&lib80211_crypt_ccmp);
+	lib80211_unregister_crypto_ops_dup(&lib80211_crypt_ccmp);
 }
 
 module_init(lib80211_crypto_ccmp_init);
--- a/net/wireless/lib80211_crypt_tkip.c	2015-06-23 11:07:42.883851349 +0200
+++ b/net/wireless/lib80211_crypt_tkip.c	2015-06-23 14:54:17.718859330 +0200
@@ -602,7 +602,7 @@ static void lib80211_michael_mic_failure
 	memcpy(ev.src_addr.sa_data, hdr->addr2, ETH_ALEN);
 	memset(&wrqu, 0, sizeof(wrqu));
 	wrqu.data.length = sizeof(ev);
-	wireless_send_event(dev, IWEVMICHAELMICFAILURE, &wrqu, (char *)&ev);
+	wireless_send_event_dup(dev, IWEVMICHAELMICFAILURE, &wrqu, (char *)&ev);
 }
 
 static int lib80211_michael_mic_verify(struct sk_buff *skb, int keyidx,
@@ -750,12 +750,12 @@ static struct lib80211_crypto_ops lib802
 
 static int __init lib80211_crypto_tkip_init(void)
 {
-	return lib80211_register_crypto_ops(&lib80211_crypt_tkip);
+	return lib80211_register_crypto_ops_dup(&lib80211_crypt_tkip);
 }
 
 static void __exit lib80211_crypto_tkip_exit(void)
 {
-	lib80211_unregister_crypto_ops(&lib80211_crypt_tkip);
+	lib80211_unregister_crypto_ops_dup(&lib80211_crypt_tkip);
 }
 
 module_init(lib80211_crypto_tkip_init);
--- a/net/wireless/lib80211_crypt_wep.c	2015-06-23 11:07:42.883851349 +0200
+++ b/net/wireless/lib80211_crypt_wep.c	2015-06-23 14:54:17.774859582 +0200
@@ -277,12 +277,12 @@ static struct lib80211_crypto_ops lib802
 
 static int __init lib80211_crypto_wep_init(void)
 {
-	return lib80211_register_crypto_ops(&lib80211_crypt_wep);
+	return lib80211_register_crypto_ops_dup(&lib80211_crypt_wep);
 }
 
 static void __exit lib80211_crypto_wep_exit(void)
 {
-	lib80211_unregister_crypto_ops(&lib80211_crypt_wep);
+	lib80211_unregister_crypto_ops_dup(&lib80211_crypt_wep);
 }
 
 module_init(lib80211_crypto_wep_init);
--- a/net/wireless/mesh.c	2015-06-23 11:07:42.883851349 +0200
+++ b/net/wireless/mesh.c	2015-06-23 14:54:17.824859806 +0200
@@ -170,11 +170,11 @@ int __cfg80211_join_mesh(struct cfg80211
 		struct ieee80211_supported_band *sband =
 				rdev->wiphy.bands[setup->chandef.chan->band];
 		scan_width = cfg80211_chandef_to_scan_width(&setup->chandef);
-		setup->basic_rates = ieee80211_mandatory_rates(sband,
+		setup->basic_rates = ieee80211_mandatory_rates_dup(sband,
 							       scan_width);
 	}
 
-	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef,
+	if (!cfg80211_reg_can_beacon_dup(&rdev->wiphy, &setup->chandef,
 				     NL80211_IFTYPE_MESH_POINT))
 		return -EINVAL;
 
--- a/net/wireless/mlme.c	2015-06-23 11:07:42.883851349 +0200
+++ b/net/wireless/mlme.c	2015-06-23 14:54:17.872860022 +0200
@@ -18,7 +18,7 @@
 #include "rdev-ops.h"
 
 
-void cfg80211_rx_assoc_resp(struct net_device *dev, struct cfg80211_bss *bss,
+void cfg80211_rx_assoc_resp_dup(struct net_device *dev, struct cfg80211_bss *bss,
 			    const u8 *buf, size_t len, int uapsd_queues)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -39,17 +39,17 @@ void cfg80211_rx_assoc_resp(struct net_d
 	 */
 	if (cfg80211_sme_rx_assoc_resp(wdev, status_code)) {
 		cfg80211_unhold_bss(bss_from_pub(bss));
-		cfg80211_put_bss(wiphy, bss);
+		cfg80211_put_bss_dup(wiphy, bss);
 		return;
 	}
 
 	nl80211_send_rx_assoc(rdev, dev, buf, len, GFP_KERNEL, uapsd_queues);
 	/* update current_bss etc., consumes the bss reference */
-	__cfg80211_connect_result(dev, mgmt->bssid, NULL, 0, ie, len - ieoffs,
+	__cfg80211_connect_result_dup(dev, mgmt->bssid, NULL, 0, ie, len - ieoffs,
 				  status_code,
 				  status_code == WLAN_STATUS_SUCCESS, bss);
 }
-EXPORT_SYMBOL(cfg80211_rx_assoc_resp);
+EXPORT_SYMBOL(cfg80211_rx_assoc_resp_dup);
 
 static void cfg80211_process_auth(struct wireless_dev *wdev,
 				  const u8 *buf, size_t len)
@@ -75,7 +75,7 @@ static void cfg80211_process_deauth(stru
 	    !ether_addr_equal(wdev->current_bss->pub.bssid, bssid))
 		return;
 
-	__cfg80211_disconnected(wdev->netdev, NULL, 0, reason_code, from_ap);
+	__cfg80211_disconnected_dup(wdev->netdev, NULL, 0, reason_code, from_ap);
 	cfg80211_sme_deauth(wdev);
 }
 
@@ -94,18 +94,18 @@ static void cfg80211_process_disassoc(st
 		    !ether_addr_equal(wdev->current_bss->pub.bssid, bssid)))
 		return;
 
-	__cfg80211_disconnected(wdev->netdev, NULL, 0, reason_code, from_ap);
+	__cfg80211_disconnected_dup(wdev->netdev, NULL, 0, reason_code, from_ap);
 	cfg80211_sme_disassoc(wdev);
 }
 
-void cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len)
+void cfg80211_rx_mlme_mgmt_dup(struct net_device *dev, const u8 *buf, size_t len)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct ieee80211_mgmt *mgmt = (void *)buf;
 
 	ASSERT_WDEV_LOCK(wdev);
 
-	trace_cfg80211_rx_mlme_mgmt(dev, buf, len);
+	trace_cfg80211_rx_mlme_mgmt_dup(dev, buf, len);
 
 	if (WARN_ON(len < 2))
 		return;
@@ -117,9 +117,9 @@ void cfg80211_rx_mlme_mgmt(struct net_de
 	else if (ieee80211_is_disassoc(mgmt->frame_control))
 		cfg80211_process_disassoc(wdev, buf, len);
 }
-EXPORT_SYMBOL(cfg80211_rx_mlme_mgmt);
+EXPORT_SYMBOL(cfg80211_rx_mlme_mgmt_dup);
 
-void cfg80211_auth_timeout(struct net_device *dev, const u8 *addr)
+void cfg80211_auth_timeout_dup(struct net_device *dev, const u8 *addr)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct wiphy *wiphy = wdev->wiphy;
@@ -130,9 +130,9 @@ void cfg80211_auth_timeout(struct net_de
 	nl80211_send_auth_timeout(rdev, dev, addr, GFP_KERNEL);
 	cfg80211_sme_auth_timeout(wdev);
 }
-EXPORT_SYMBOL(cfg80211_auth_timeout);
+EXPORT_SYMBOL(cfg80211_auth_timeout_dup);
 
-void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss)
+void cfg80211_assoc_timeout_dup(struct net_device *dev, struct cfg80211_bss *bss)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct wiphy *wiphy = wdev->wiphy;
@@ -144,18 +144,18 @@ void cfg80211_assoc_timeout(struct net_d
 	cfg80211_sme_assoc_timeout(wdev);
 
 	cfg80211_unhold_bss(bss_from_pub(bss));
-	cfg80211_put_bss(wiphy, bss);
+	cfg80211_put_bss_dup(wiphy, bss);
 }
-EXPORT_SYMBOL(cfg80211_assoc_timeout);
+EXPORT_SYMBOL(cfg80211_assoc_timeout_dup);
 
-void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len)
+void cfg80211_tx_mlme_mgmt_dup(struct net_device *dev, const u8 *buf, size_t len)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct ieee80211_mgmt *mgmt = (void *)buf;
 
 	ASSERT_WDEV_LOCK(wdev);
 
-	trace_cfg80211_tx_mlme_mgmt(dev, buf, len);
+	trace_cfg80211_tx_mlme_mgmt_dup(dev, buf, len);
 
 	if (WARN_ON(len < 2))
 		return;
@@ -165,9 +165,9 @@ void cfg80211_tx_mlme_mgmt(struct net_de
 	else
 		cfg80211_process_disassoc(wdev, buf, len);
 }
-EXPORT_SYMBOL(cfg80211_tx_mlme_mgmt);
+EXPORT_SYMBOL(cfg80211_tx_mlme_mgmt_dup);
 
-void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
+void cfg80211_michael_mic_failure_dup(struct net_device *dev, const u8 *addr,
 				  enum nl80211_key_type key_type, int key_id,
 				  const u8 *tsc, gfp_t gfp)
 {
@@ -184,15 +184,15 @@ void cfg80211_michael_mic_failure(struct
 			addr);
 		memset(&wrqu, 0, sizeof(wrqu));
 		wrqu.data.length = strlen(buf);
-		wireless_send_event(dev, IWEVCUSTOM, &wrqu, buf);
+		wireless_send_event_dup(dev, IWEVCUSTOM, &wrqu, buf);
 		kfree(buf);
 	}
 #endif
 
-	trace_cfg80211_michael_mic_failure(dev, addr, key_type, key_id, tsc);
+	trace_cfg80211_michael_mic_failure_dup(dev, addr, key_type, key_id, tsc);
 	nl80211_michael_mic_failure(rdev, dev, addr, key_type, key_id, tsc, gfp);
 }
-EXPORT_SYMBOL(cfg80211_michael_mic_failure);
+EXPORT_SYMBOL(cfg80211_michael_mic_failure_dup);
 
 /* some MLME handling for userspace SME */
 int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
@@ -228,14 +228,14 @@ int cfg80211_mlme_auth(struct cfg80211_r
 	    ether_addr_equal(bssid, wdev->current_bss->pub.bssid))
 		return -EALREADY;
 
-	req.bss = cfg80211_get_bss(&rdev->wiphy, chan, bssid, ssid, ssid_len,
+	req.bss = cfg80211_get_bss_dup(&rdev->wiphy, chan, bssid, ssid, ssid_len,
 				   WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
 	if (!req.bss)
 		return -ENOENT;
 
 	err = rdev_auth(rdev, dev, &req);
 
-	cfg80211_put_bss(&rdev->wiphy, req.bss);
+	cfg80211_put_bss_dup(&rdev->wiphy, req.bss);
 	return err;
 }
 
@@ -295,7 +295,7 @@ int cfg80211_mlme_assoc(struct cfg80211_
 	cfg80211_oper_and_vht_capa(&req->vht_capa_mask,
 				   rdev->wiphy.vht_capa_mod_mask);
 
-	req->bss = cfg80211_get_bss(&rdev->wiphy, chan, bssid, ssid, ssid_len,
+	req->bss = cfg80211_get_bss_dup(&rdev->wiphy, chan, bssid, ssid, ssid_len,
 				    WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
 	if (!req->bss)
 		return -ENOENT;
@@ -304,7 +304,7 @@ int cfg80211_mlme_assoc(struct cfg80211_
 	if (!err)
 		cfg80211_hold_bss(bss_from_pub(req->bss));
 	else
-		cfg80211_put_bss(&rdev->wiphy, req->bss);
+		cfg80211_put_bss_dup(&rdev->wiphy, req->bss);
 
 	return err;
 }
@@ -604,7 +604,7 @@ int cfg80211_mlme_mgmt_tx(struct cfg8021
 	return rdev_mgmt_tx(rdev, wdev, params, cookie);
 }
 
-bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_mbm,
+bool cfg80211_rx_mgmt_dup(struct wireless_dev *wdev, int freq, int sig_mbm,
 		      const u8 *buf, size_t len, u32 flags)
 {
 	struct wiphy *wiphy = wdev->wiphy;
@@ -620,7 +620,7 @@ bool cfg80211_rx_mgmt(struct wireless_de
 		cpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE);
 	u16 stype;
 
-	trace_cfg80211_rx_mgmt(wdev, freq, sig_mbm);
+	trace_cfg80211_rx_mgmt_dup(wdev, freq, sig_mbm);
 	stype = (le16_to_cpu(mgmt->frame_control) & IEEE80211_FCTL_STYPE) >> 4;
 
 	if (!(stypes->rx & BIT(stype))) {
@@ -628,8 +628,8 @@ bool cfg80211_rx_mgmt(struct wireless_de
 		return false;
 	}
 
-	data = buf + ieee80211_hdrlen(mgmt->frame_control);
-	data_len = len - ieee80211_hdrlen(mgmt->frame_control);
+	data = buf + ieee80211_hdrlen_dup(mgmt->frame_control);
+	data_len = len - ieee80211_hdrlen_dup(mgmt->frame_control);
 
 	spin_lock_bh(&wdev->mgmt_registrations_lock);
 
@@ -660,7 +660,7 @@ bool cfg80211_rx_mgmt(struct wireless_de
 	trace_cfg80211_return_bool(result);
 	return result;
 }
-EXPORT_SYMBOL(cfg80211_rx_mgmt);
+EXPORT_SYMBOL(cfg80211_rx_mgmt_dup);
 
 void cfg80211_dfs_channels_update_work(struct work_struct *work)
 {
@@ -698,7 +698,7 @@ void cfg80211_dfs_channels_update_work(s
 				c->dfs_state = NL80211_DFS_USABLE;
 				c->dfs_state_entered = jiffies;
 
-				cfg80211_chandef_create(&chandef, c,
+				cfg80211_chandef_create_dup(&chandef, c,
 							NL80211_CHAN_NO_HT);
 
 				nl80211_radar_notify(rdev, &chandef,
@@ -723,14 +723,14 @@ void cfg80211_dfs_channels_update_work(s
 }
 
 
-void cfg80211_radar_event(struct wiphy *wiphy,
+void cfg80211_radar_event_dup(struct wiphy *wiphy,
 			  struct cfg80211_chan_def *chandef,
 			  gfp_t gfp)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 	unsigned long timeout;
 
-	trace_cfg80211_radar_event(wiphy, chandef);
+	trace_cfg80211_radar_event_dup(wiphy, chandef);
 
 	/* only set the chandef supplied channel to unavailable, in
 	 * case the radar is detected on only one of multiple channels
@@ -744,9 +744,9 @@ void cfg80211_radar_event(struct wiphy *
 
 	nl80211_radar_notify(rdev, chandef, NL80211_RADAR_DETECTED, NULL, gfp);
 }
-EXPORT_SYMBOL(cfg80211_radar_event);
+EXPORT_SYMBOL(cfg80211_radar_event_dup);
 
-void cfg80211_cac_event(struct net_device *netdev,
+void cfg80211_cac_event_dup(struct net_device *netdev,
 			const struct cfg80211_chan_def *chandef,
 			enum nl80211_radar_event event, gfp_t gfp)
 {
@@ -755,7 +755,7 @@ void cfg80211_cac_event(struct net_devic
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 	unsigned long timeout;
 
-	trace_cfg80211_cac_event(netdev, event);
+	trace_cfg80211_cac_event_dup(netdev, event);
 
 	if (WARN_ON(!wdev->cac_started))
 		return;
@@ -780,4 +780,4 @@ void cfg80211_cac_event(struct net_devic
 
 	nl80211_radar_notify(rdev, chandef, event, netdev, gfp);
 }
-EXPORT_SYMBOL(cfg80211_cac_event);
+EXPORT_SYMBOL(cfg80211_cac_event_dup);
--- a/net/wireless/nl80211.c	2015-06-23 11:07:42.885851372 +0200
+++ b/net/wireless/nl80211.c	2015-06-23 14:54:17.920860237 +0200
@@ -1931,7 +1931,7 @@ static int nl80211_parse_chandef(struct
 		case NL80211_CHAN_HT20:
 		case NL80211_CHAN_HT40PLUS:
 		case NL80211_CHAN_HT40MINUS:
-			cfg80211_chandef_create(chandef, chandef->chan,
+			cfg80211_chandef_create_dup(chandef, chandef->chan,
 						chantype);
 			break;
 		default:
@@ -1950,10 +1950,10 @@ static int nl80211_parse_chandef(struct
 					info->attrs[NL80211_ATTR_CENTER_FREQ2]);
 	}
 
-	if (!cfg80211_chandef_valid(chandef))
+	if (!cfg80211_chandef_valid_dup(chandef))
 		return -EINVAL;
 
-	if (!cfg80211_chandef_usable(&rdev->wiphy, chandef,
+	if (!cfg80211_chandef_usable_dup(&rdev->wiphy, chandef,
 				     IEEE80211_CHAN_DISABLED))
 		return -EINVAL;
 
@@ -1988,7 +1988,7 @@ static int __nl80211_set_channel(struct
 	switch (iftype) {
 	case NL80211_IFTYPE_AP:
 	case NL80211_IFTYPE_P2P_GO:
-		if (!cfg80211_reg_can_beacon(&rdev->wiphy, &chandef, iftype)) {
+		if (!cfg80211_reg_can_beacon_dup(&rdev->wiphy, &chandef, iftype)) {
 			result = -EINVAL;
 			break;
 		}
@@ -2319,7 +2319,7 @@ static inline u64 wdev_id(struct wireles
 static int nl80211_send_chandef(struct sk_buff *msg,
 				const struct cfg80211_chan_def *chandef)
 {
-	if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+	if (WARN_ON(!cfg80211_chandef_valid_dup(chandef)))
 		return -EINVAL;
 
 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,
@@ -3386,7 +3386,7 @@ static int nl80211_start_ap(struct sk_bu
 	} else if (!nl80211_get_ap_channel(rdev, &params))
 		return -EINVAL;
 
-	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &params.chandef,
+	if (!cfg80211_reg_can_beacon_dup(&rdev->wiphy, &params.chandef,
 				     wdev->iftype))
 		return -EINVAL;
 
@@ -3569,8 +3569,8 @@ static bool nl80211_put_sta_rate(struct
 	if (!rate)
 		return false;
 
-	/* cfg80211_calculate_bitrate will return 0 for mcs >= 32 */
-	bitrate = cfg80211_calculate_bitrate(info);
+	/* cfg80211_calculate_bitrate_dup will return 0 for mcs >= 32 */
+	bitrate = cfg80211_calculate_bitrate_dup(info);
 	/* report 16-bit bitrate only if we can */
 	bitrate_compat = bitrate < (1UL << 16) ? bitrate : 0;
 	if (bitrate > 0 &&
@@ -3909,7 +3909,7 @@ static int nl80211_get_station(struct sk
 	return genlmsg_reply(msg, info);
 }
 
-int cfg80211_check_station_change(struct wiphy *wiphy,
+int cfg80211_check_station_change_dup(struct wiphy *wiphy,
 				  struct station_parameters *params,
 				  enum cfg80211_station_type statype)
 {
@@ -4038,7 +4038,7 @@ int cfg80211_check_station_change(struct
 
 	return 0;
 }
-EXPORT_SYMBOL(cfg80211_check_station_change);
+EXPORT_SYMBOL(cfg80211_check_station_change_dup);
 
 /*
  * Get vlan interface making sure it is running and on the right wiphy.
@@ -4274,7 +4274,7 @@ static int nl80211_set_station(struct sk
 		goto out_put_vlan;
 	}
 
-	/* driver will call cfg80211_check_station_change() */
+	/* driver will call cfg80211_check_station_change_dup() */
 	err = rdev_change_station(rdev, dev, mac_addr, &params);
 
  out_put_vlan:
@@ -5607,7 +5607,7 @@ static int nl80211_trigger_scan(struct s
 			goto unlock;
 		}
 	} else {
-		n_channels = ieee80211_get_num_supported_channels(wiphy);
+		n_channels = ieee80211_get_num_supported_channels_dup(wiphy);
 	}
 
 	if (info->attrs[NL80211_ATTR_SCAN_SSIDS])
@@ -5827,7 +5827,7 @@ nl80211_parse_sched_scan(struct wiphy *w
 		if (!n_channels)
 			return ERR_PTR(-EINVAL);
 	} else {
-		n_channels = ieee80211_get_num_supported_channels(wiphy);
+		n_channels = ieee80211_get_num_supported_channels_dup(wiphy);
 	}
 
 	if (attrs[NL80211_ATTR_SCAN_SSIDS])
@@ -6158,7 +6158,7 @@ static int nl80211_start_radar_detection
 	if (wdev->cac_started)
 		return -EBUSY;
 
-	err = cfg80211_chandef_dfs_required(wdev->wiphy, &chandef,
+	err = cfg80211_chandef_dfs_required_dup(wdev->wiphy, &chandef,
 					    wdev->iftype);
 	if (err < 0)
 		return err;
@@ -6322,11 +6322,11 @@ skip_beacons:
 	if (err)
 		return err;
 
-	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &params.chandef,
+	if (!cfg80211_reg_can_beacon_dup(&rdev->wiphy, &params.chandef,
 				     wdev->iftype))
 		return -EINVAL;
 
-	err = cfg80211_chandef_dfs_required(wdev->wiphy,
+	err = cfg80211_chandef_dfs_required_dup(wdev->wiphy,
 					    &params.chandef,
 					    wdev->iftype);
 	if (err < 0)
@@ -7099,7 +7099,7 @@ static int nl80211_join_ibss(struct sk_b
 	if (err)
 		return err;
 
-	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &ibss.chandef,
+	if (!cfg80211_reg_can_beacon_dup(&rdev->wiphy, &ibss.chandef,
 				     NL80211_IFTYPE_ADHOC))
 		return -EINVAL;
 
@@ -7269,7 +7269,7 @@ __cfg80211_alloc_vendor_skb(struct cfg80
 	return NULL;
 }
 
-struct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,
+struct sk_buff *__cfg80211_alloc_event_skb_dup(struct wiphy *wiphy,
 					   enum nl80211_commands cmd,
 					   enum nl80211_attrs attr,
 					   int vendor_event_idx,
@@ -7298,9 +7298,9 @@ struct sk_buff *__cfg80211_alloc_event_s
 	return __cfg80211_alloc_vendor_skb(rdev, approxlen, 0, 0,
 					   cmd, attr, info, gfp);
 }
-EXPORT_SYMBOL(__cfg80211_alloc_event_skb);
+EXPORT_SYMBOL(__cfg80211_alloc_event_skb_dup);
 
-void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp)
+void __cfg80211_send_event_skb_dup(struct sk_buff *skb, gfp_t gfp)
 {
 	struct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];
 	void *hdr = ((void **)skb->cb)[1];
@@ -7319,7 +7319,7 @@ void __cfg80211_send_event_skb(struct sk
 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), skb, 0,
 				mcgrp, gfp);
 }
-EXPORT_SYMBOL(__cfg80211_send_event_skb);
+EXPORT_SYMBOL(__cfg80211_send_event_skb_dup);
 
 #ifdef CONFIG_NL80211_TESTMODE
 static int nl80211_testmode_do(struct sk_buff *skb, struct genl_info *info)
@@ -9679,7 +9679,7 @@ static int nl80211_vendor_cmd(struct sk_
 	return -EOPNOTSUPP;
 }
 
-struct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,
+struct sk_buff *__cfg80211_alloc_reply_skb_dup(struct wiphy *wiphy,
 					   enum nl80211_commands cmd,
 					   enum nl80211_attrs attr,
 					   int approxlen)
@@ -9694,9 +9694,9 @@ struct sk_buff *__cfg80211_alloc_reply_s
 					   rdev->cur_cmd_info->snd_seq,
 					   cmd, attr, NULL, GFP_KERNEL);
 }
-EXPORT_SYMBOL(__cfg80211_alloc_reply_skb);
+EXPORT_SYMBOL(__cfg80211_alloc_reply_skb_dup);
 
-int cfg80211_vendor_cmd_reply(struct sk_buff *skb)
+int cfg80211_vendor_cmd_reply_dup(struct sk_buff *skb)
 {
 	struct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];
 	void *hdr = ((void **)skb->cb)[1];
@@ -9714,7 +9714,7 @@ int cfg80211_vendor_cmd_reply(struct sk_
 	genlmsg_end(skb, hdr);
 	return genlmsg_reply(skb, rdev->cur_cmd_info);
 }
-EXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_reply);
+EXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_reply_dup);
 
 
 static int nl80211_set_qos_map(struct sk_buff *skb,
@@ -9895,11 +9895,11 @@ static int nl80211_tdls_channel_switch(s
 		return -EINVAL;
 
 	/* we will be active on the TDLS link */
-	if (!cfg80211_reg_can_beacon(&rdev->wiphy, &chandef, wdev->iftype))
+	if (!cfg80211_reg_can_beacon_dup(&rdev->wiphy, &chandef, wdev->iftype))
 		return -EINVAL;
 
 	/* don't allow switching to DFS channels */
-	if (cfg80211_chandef_dfs_required(wdev->wiphy, &chandef, wdev->iftype))
+	if (cfg80211_chandef_dfs_required_dup(wdev->wiphy, &chandef, wdev->iftype))
 		return -EINVAL;
 
 	addr = nla_data(info->attrs[NL80211_ATTR_MAC]);
@@ -11104,7 +11104,7 @@ void nl80211_send_disassoc(struct cfg802
 				NL80211_CMD_DISASSOCIATE, gfp, -1);
 }
 
-void cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev, const u8 *buf,
+void cfg80211_rx_unprot_mlme_mgmt_dup(struct net_device *dev, const u8 *buf,
 				  size_t len)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -11121,10 +11121,10 @@ void cfg80211_rx_unprot_mlme_mgmt(struct
 	else
 		cmd = NL80211_CMD_UNPROT_DISASSOCIATE;
 
-	trace_cfg80211_rx_unprot_mlme_mgmt(dev, buf, len);
+	trace_cfg80211_rx_unprot_mlme_mgmt_dup(dev, buf, len);
 	nl80211_send_mlme_event(rdev, dev, buf, len, cmd, GFP_ATOMIC, -1);
 }
-EXPORT_SYMBOL(cfg80211_rx_unprot_mlme_mgmt);
+EXPORT_SYMBOL(cfg80211_rx_unprot_mlme_mgmt_dup);
 
 static void nl80211_send_mlme_timeout(struct cfg80211_registered_device *rdev,
 				      struct net_device *netdev, int cmd,
@@ -11327,7 +11327,7 @@ void nl80211_send_ibss_bssid(struct cfg8
 	nlmsg_free(msg);
 }
 
-void cfg80211_notify_new_peer_candidate(struct net_device *dev, const u8 *addr,
+void cfg80211_notify_new_peer_candidate_dup(struct net_device *dev, const u8 *addr,
 					const u8* ie, u8 ie_len, gfp_t gfp)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -11338,7 +11338,7 @@ void cfg80211_notify_new_peer_candidate(
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_MESH_POINT))
 		return;
 
-	trace_cfg80211_notify_new_peer_candidate(dev, addr);
+	trace_cfg80211_notify_new_peer_candidate_dup(dev, addr);
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
 	if (!msg)
@@ -11367,7 +11367,7 @@ void cfg80211_notify_new_peer_candidate(
 	genlmsg_cancel(msg, hdr);
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_notify_new_peer_candidate);
+EXPORT_SYMBOL(cfg80211_notify_new_peer_candidate_dup);
 
 void nl80211_michael_mic_failure(struct cfg80211_registered_device *rdev,
 				 struct net_device *netdev, const u8 *addr,
@@ -11506,21 +11506,21 @@ static void nl80211_send_remain_on_chan_
 	nlmsg_free(msg);
 }
 
-void cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_ready_on_channel_dup(struct wireless_dev *wdev, u64 cookie,
 			       struct ieee80211_channel *chan,
 			       unsigned int duration, gfp_t gfp)
 {
 	struct wiphy *wiphy = wdev->wiphy;
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
-	trace_cfg80211_ready_on_channel(wdev, cookie, chan, duration);
+	trace_cfg80211_ready_on_channel_dup(wdev, cookie, chan, duration);
 	nl80211_send_remain_on_chan_event(NL80211_CMD_REMAIN_ON_CHANNEL,
 					  rdev, wdev, cookie, chan,
 					  duration, gfp);
 }
-EXPORT_SYMBOL(cfg80211_ready_on_channel);
+EXPORT_SYMBOL(cfg80211_ready_on_channel_dup);
 
-void cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_remain_on_channel_expired_dup(struct wireless_dev *wdev, u64 cookie,
 					struct ieee80211_channel *chan,
 					gfp_t gfp)
 {
@@ -11531,16 +11531,16 @@ void cfg80211_remain_on_channel_expired(
 	nl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,
 					  rdev, wdev, cookie, chan, 0, gfp);
 }
-EXPORT_SYMBOL(cfg80211_remain_on_channel_expired);
+EXPORT_SYMBOL(cfg80211_remain_on_channel_expired_dup);
 
-void cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,
+void cfg80211_new_sta_dup(struct net_device *dev, const u8 *mac_addr,
 		      struct station_info *sinfo, gfp_t gfp)
 {
 	struct wiphy *wiphy = dev->ieee80211_ptr->wiphy;
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 	struct sk_buff *msg;
 
-	trace_cfg80211_new_sta(dev, mac_addr, sinfo);
+	trace_cfg80211_new_sta_dup(dev, mac_addr, sinfo);
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
 	if (!msg)
@@ -11555,16 +11555,16 @@ void cfg80211_new_sta(struct net_device
 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
 				NL80211_MCGRP_MLME, gfp);
 }
-EXPORT_SYMBOL(cfg80211_new_sta);
+EXPORT_SYMBOL(cfg80211_new_sta_dup);
 
-void cfg80211_del_sta(struct net_device *dev, const u8 *mac_addr, gfp_t gfp)
+void cfg80211_del_sta_dup(struct net_device *dev, const u8 *mac_addr, gfp_t gfp)
 {
 	struct wiphy *wiphy = dev->ieee80211_ptr->wiphy;
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 	struct sk_buff *msg;
 	void *hdr;
 
-	trace_cfg80211_del_sta(dev, mac_addr);
+	trace_cfg80211_del_sta_dup(dev, mac_addr);
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
 	if (!msg)
@@ -11590,9 +11590,9 @@ void cfg80211_del_sta(struct net_device
 	genlmsg_cancel(msg, hdr);
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_del_sta);
+EXPORT_SYMBOL(cfg80211_del_sta_dup);
 
-void cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,
+void cfg80211_conn_failed_dup(struct net_device *dev, const u8 *mac_addr,
 			  enum nl80211_connect_failed_reason reason,
 			  gfp_t gfp)
 {
@@ -11626,7 +11626,7 @@ void cfg80211_conn_failed(struct net_dev
 	genlmsg_cancel(msg, hdr);
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_conn_failed);
+EXPORT_SYMBOL(cfg80211_conn_failed_dup);
 
 static bool __nl80211_unexpected_frame(struct net_device *dev, u8 cmd,
 				       const u8 *addr, gfp_t gfp)
@@ -11665,13 +11665,13 @@ static bool __nl80211_unexpected_frame(s
 	return true;
 }
 
-bool cfg80211_rx_spurious_frame(struct net_device *dev,
+bool cfg80211_rx_spurious_frame_dup(struct net_device *dev,
 				const u8 *addr, gfp_t gfp)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	bool ret;
 
-	trace_cfg80211_rx_spurious_frame(dev, addr);
+	trace_cfg80211_rx_spurious_frame_dup(dev, addr);
 
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&
 		    wdev->iftype != NL80211_IFTYPE_P2P_GO)) {
@@ -11683,15 +11683,15 @@ bool cfg80211_rx_spurious_frame(struct n
 	trace_cfg80211_return_bool(ret);
 	return ret;
 }
-EXPORT_SYMBOL(cfg80211_rx_spurious_frame);
+EXPORT_SYMBOL(cfg80211_rx_spurious_frame_dup);
 
-bool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,
+bool cfg80211_rx_unexpected_4addr_frame_dup(struct net_device *dev,
 					const u8 *addr, gfp_t gfp)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	bool ret;
 
-	trace_cfg80211_rx_unexpected_4addr_frame(dev, addr);
+	trace_cfg80211_rx_unexpected_4addr_frame_dup(dev, addr);
 
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&
 		    wdev->iftype != NL80211_IFTYPE_P2P_GO &&
@@ -11705,7 +11705,7 @@ bool cfg80211_rx_unexpected_4addr_frame(
 	trace_cfg80211_return_bool(ret);
 	return ret;
 }
-EXPORT_SYMBOL(cfg80211_rx_unexpected_4addr_frame);
+EXPORT_SYMBOL(cfg80211_rx_unexpected_4addr_frame_dup);
 
 int nl80211_send_mgmt(struct cfg80211_registered_device *rdev,
 		      struct wireless_dev *wdev, u32 nlportid,
@@ -11748,7 +11748,7 @@ int nl80211_send_mgmt(struct cfg80211_re
 	return -ENOBUFS;
 }
 
-void cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_mgmt_tx_status_dup(struct wireless_dev *wdev, u64 cookie,
 			     const u8 *buf, size_t len, bool ack, gfp_t gfp)
 {
 	struct wiphy *wiphy = wdev->wiphy;
@@ -11757,7 +11757,7 @@ void cfg80211_mgmt_tx_status(struct wire
 	struct sk_buff *msg;
 	void *hdr;
 
-	trace_cfg80211_mgmt_tx_status(wdev, cookie, ack);
+	trace_cfg80211_mgmt_tx_status_dup(wdev, cookie, ack);
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
 	if (!msg)
@@ -11788,7 +11788,7 @@ void cfg80211_mgmt_tx_status(struct wire
 	genlmsg_cancel(msg, hdr);
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_mgmt_tx_status);
+EXPORT_SYMBOL(cfg80211_mgmt_tx_status_dup);
 
 static struct sk_buff *cfg80211_prepare_cqm(struct net_device *dev,
 					    const char *mac, gfp_t gfp)
@@ -11842,13 +11842,13 @@ static void cfg80211_send_cqm(struct sk_
 				NL80211_MCGRP_MLME, gfp);
 }
 
-void cfg80211_cqm_rssi_notify(struct net_device *dev,
+void cfg80211_cqm_rssi_notify_dup(struct net_device *dev,
 			      enum nl80211_cqm_rssi_threshold_event rssi_event,
 			      gfp_t gfp)
 {
 	struct sk_buff *msg;
 
-	trace_cfg80211_cqm_rssi_notify(dev, rssi_event);
+	trace_cfg80211_cqm_rssi_notify_dup(dev, rssi_event);
 
 	if (WARN_ON(rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW &&
 		    rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH))
@@ -11869,9 +11869,9 @@ void cfg80211_cqm_rssi_notify(struct net
  nla_put_failure:
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_cqm_rssi_notify);
+EXPORT_SYMBOL(cfg80211_cqm_rssi_notify_dup);
 
-void cfg80211_cqm_txe_notify(struct net_device *dev,
+void cfg80211_cqm_txe_notify_dup(struct net_device *dev,
 			     const u8 *peer, u32 num_packets,
 			     u32 rate, u32 intvl, gfp_t gfp)
 {
@@ -11896,14 +11896,14 @@ void cfg80211_cqm_txe_notify(struct net_
  nla_put_failure:
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_cqm_txe_notify);
+EXPORT_SYMBOL(cfg80211_cqm_txe_notify_dup);
 
-void cfg80211_cqm_pktloss_notify(struct net_device *dev,
+void cfg80211_cqm_pktloss_notify_dup(struct net_device *dev,
 				 const u8 *peer, u32 num_packets, gfp_t gfp)
 {
 	struct sk_buff *msg;
 
-	trace_cfg80211_cqm_pktloss_notify(dev, peer, num_packets);
+	trace_cfg80211_cqm_pktloss_notify_dup(dev, peer, num_packets);
 
 	msg = cfg80211_prepare_cqm(dev, peer, gfp);
 	if (!msg)
@@ -11918,9 +11918,9 @@ void cfg80211_cqm_pktloss_notify(struct
  nla_put_failure:
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_cqm_pktloss_notify);
+EXPORT_SYMBOL(cfg80211_cqm_pktloss_notify_dup);
 
-void cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp)
+void cfg80211_cqm_beacon_loss_notify_dup(struct net_device *dev, gfp_t gfp)
 {
 	struct sk_buff *msg;
 
@@ -11937,7 +11937,7 @@ void cfg80211_cqm_beacon_loss_notify(str
  nla_put_failure:
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_cqm_beacon_loss_notify);
+EXPORT_SYMBOL(cfg80211_cqm_beacon_loss_notify_dup);
 
 static void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,
 				     struct net_device *netdev, const u8 *bssid,
@@ -11983,17 +11983,17 @@ static void nl80211_gtk_rekey_notify(str
 	nlmsg_free(msg);
 }
 
-void cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,
+void cfg80211_gtk_rekey_notify_dup(struct net_device *dev, const u8 *bssid,
 			       const u8 *replay_ctr, gfp_t gfp)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct wiphy *wiphy = wdev->wiphy;
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
-	trace_cfg80211_gtk_rekey_notify(dev, bssid);
+	trace_cfg80211_gtk_rekey_notify_dup(dev, bssid);
 	nl80211_gtk_rekey_notify(rdev, dev, bssid, replay_ctr, gfp);
 }
-EXPORT_SYMBOL(cfg80211_gtk_rekey_notify);
+EXPORT_SYMBOL(cfg80211_gtk_rekey_notify_dup);
 
 static void
 nl80211_pmksa_candidate_notify(struct cfg80211_registered_device *rdev,
@@ -12041,17 +12041,17 @@ nl80211_pmksa_candidate_notify(struct cf
 	nlmsg_free(msg);
 }
 
-void cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,
+void cfg80211_pmksa_candidate_notify_dup(struct net_device *dev, int index,
 				     const u8 *bssid, bool preauth, gfp_t gfp)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct wiphy *wiphy = wdev->wiphy;
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
-	trace_cfg80211_pmksa_candidate_notify(dev, index, bssid, preauth);
+	trace_cfg80211_pmksa_candidate_notify_dup(dev, index, bssid, preauth);
 	nl80211_pmksa_candidate_notify(rdev, dev, index, bssid, preauth, gfp);
 }
-EXPORT_SYMBOL(cfg80211_pmksa_candidate_notify);
+EXPORT_SYMBOL(cfg80211_pmksa_candidate_notify_dup);
 
 static void nl80211_ch_switch_notify(struct cfg80211_registered_device *rdev,
 				     struct net_device *netdev,
@@ -12094,7 +12094,7 @@ static void nl80211_ch_switch_notify(str
 	nlmsg_free(msg);
 }
 
-void cfg80211_ch_switch_notify(struct net_device *dev,
+void cfg80211_ch_switch_notify_dup(struct net_device *dev,
 			       struct cfg80211_chan_def *chandef)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -12103,16 +12103,16 @@ void cfg80211_ch_switch_notify(struct ne
 
 	ASSERT_WDEV_LOCK(wdev);
 
-	trace_cfg80211_ch_switch_notify(dev, chandef);
+	trace_cfg80211_ch_switch_notify_dup(dev, chandef);
 
 	wdev->chandef = *chandef;
 	wdev->preset_chandef = *chandef;
 	nl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL,
 				 NL80211_CMD_CH_SWITCH_NOTIFY, 0);
 }
-EXPORT_SYMBOL(cfg80211_ch_switch_notify);
+EXPORT_SYMBOL(cfg80211_ch_switch_notify_dup);
 
-void cfg80211_ch_switch_started_notify(struct net_device *dev,
+void cfg80211_ch_switch_started_notify_dup(struct net_device *dev,
 				       struct cfg80211_chan_def *chandef,
 				       u8 count)
 {
@@ -12120,12 +12120,12 @@ void cfg80211_ch_switch_started_notify(s
 	struct wiphy *wiphy = wdev->wiphy;
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
-	trace_cfg80211_ch_switch_started_notify(dev, chandef);
+	trace_cfg80211_ch_switch_started_notify_dup(dev, chandef);
 
 	nl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL,
 				 NL80211_CMD_CH_SWITCH_STARTED_NOTIFY, count);
 }
-EXPORT_SYMBOL(cfg80211_ch_switch_started_notify);
+EXPORT_SYMBOL(cfg80211_ch_switch_started_notify_dup);
 
 void
 nl80211_radar_notify(struct cfg80211_registered_device *rdev,
@@ -12175,7 +12175,7 @@ nl80211_radar_notify(struct cfg80211_reg
 	nlmsg_free(msg);
 }
 
-void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
+void cfg80211_probe_status_dup(struct net_device *dev, const u8 *addr,
 			   u64 cookie, bool acked, gfp_t gfp)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -12183,7 +12183,7 @@ void cfg80211_probe_status(struct net_de
 	struct sk_buff *msg;
 	void *hdr;
 
-	trace_cfg80211_probe_status(dev, addr, cookie, acked);
+	trace_cfg80211_probe_status_dup(dev, addr, cookie, acked);
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
 
@@ -12213,9 +12213,9 @@ void cfg80211_probe_status(struct net_de
 	genlmsg_cancel(msg, hdr);
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_probe_status);
+EXPORT_SYMBOL(cfg80211_probe_status_dup);
 
-void cfg80211_report_obss_beacon(struct wiphy *wiphy,
+void cfg80211_report_obss_beacon_dup(struct wiphy *wiphy,
 				 const u8 *frame, size_t len,
 				 int freq, int sig_dbm)
 {
@@ -12224,7 +12224,7 @@ void cfg80211_report_obss_beacon(struct
 	void *hdr;
 	struct cfg80211_beacon_registration *reg;
 
-	trace_cfg80211_report_obss_beacon(wiphy, frame, len, freq, sig_dbm);
+	trace_cfg80211_report_obss_beacon_dup(wiphy, frame, len, freq, sig_dbm);
 
 	spin_lock_bh(&rdev->beacon_registrations_lock);
 	list_for_each_entry(reg, &rdev->beacon_registrations, list) {
@@ -12259,7 +12259,7 @@ void cfg80211_report_obss_beacon(struct
 		genlmsg_cancel(msg, hdr);
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_report_obss_beacon);
+EXPORT_SYMBOL(cfg80211_report_obss_beacon_dup);
 
 #ifdef CONFIG_PM
 static int cfg80211_net_detect_results(struct sk_buff *msg,
@@ -12323,7 +12323,7 @@ out:
 	return 0;
 }
 
-void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
+void cfg80211_report_wowlan_wakeup_dup(struct wireless_dev *wdev,
 				   struct cfg80211_wowlan_wakeup *wakeup,
 				   gfp_t gfp)
 {
@@ -12332,7 +12332,7 @@ void cfg80211_report_wowlan_wakeup(struc
 	void *hdr;
 	int size = 200;
 
-	trace_cfg80211_report_wowlan_wakeup(wdev->wiphy, wdev, wakeup);
+	trace_cfg80211_report_wowlan_wakeup_dup(wdev->wiphy, wdev, wakeup);
 
 	if (wakeup)
 		size += wakeup->packet_present_len;
@@ -12433,10 +12433,10 @@ void cfg80211_report_wowlan_wakeup(struc
  free_msg:
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_report_wowlan_wakeup);
+EXPORT_SYMBOL(cfg80211_report_wowlan_wakeup_dup);
 #endif
 
-void cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,
+void cfg80211_tdls_oper_request_dup(struct net_device *dev, const u8 *peer,
 				enum nl80211_tdls_operation oper,
 				u16 reason_code, gfp_t gfp)
 {
@@ -12445,7 +12445,7 @@ void cfg80211_tdls_oper_request(struct n
 	struct sk_buff *msg;
 	void *hdr;
 
-	trace_cfg80211_tdls_oper_request(wdev->wiphy, dev, peer, oper,
+	trace_cfg80211_tdls_oper_request_dup(wdev->wiphy, dev, peer, oper,
 					 reason_code);
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
@@ -12476,7 +12476,7 @@ void cfg80211_tdls_oper_request(struct n
 	genlmsg_cancel(msg, hdr);
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_tdls_oper_request);
+EXPORT_SYMBOL(cfg80211_tdls_oper_request_dup);
 
 static int nl80211_netlink_notify(struct notifier_block * nb,
 				  unsigned long state,
@@ -12536,7 +12536,7 @@ static struct notifier_block nl80211_net
 	.notifier_call = nl80211_netlink_notify,
 };
 
-void cfg80211_ft_event(struct net_device *netdev,
+void cfg80211_ft_event_dup(struct net_device *netdev,
 		       struct cfg80211_ft_event_params *ft_event)
 {
 	struct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;
@@ -12544,7 +12544,7 @@ void cfg80211_ft_event(struct net_device
 	struct sk_buff *msg;
 	void *hdr;
 
-	trace_cfg80211_ft_event(wiphy, netdev, ft_event);
+	trace_cfg80211_ft_event_dup(wiphy, netdev, ft_event);
 
 	if (!ft_event->target_ap)
 		return;
@@ -12578,9 +12578,9 @@ void cfg80211_ft_event(struct net_device
  out:
 	nlmsg_free(msg);
 }
-EXPORT_SYMBOL(cfg80211_ft_event);
+EXPORT_SYMBOL(cfg80211_ft_event_dup);
 
-void cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp)
+void cfg80211_crit_proto_stopped_dup(struct wireless_dev *wdev, gfp_t gfp)
 {
 	struct cfg80211_registered_device *rdev;
 	struct sk_buff *msg;
@@ -12617,7 +12617,7 @@ void cfg80211_crit_proto_stopped(struct
 	nlmsg_free(msg);
 
 }
-EXPORT_SYMBOL(cfg80211_crit_proto_stopped);
+EXPORT_SYMBOL(cfg80211_crit_proto_stopped_dup);
 
 void nl80211_send_ap_stopped(struct wireless_dev *wdev)
 {
--- a/net/wireless/radiotap.c	2015-06-23 11:07:42.885851372 +0200
+++ b/net/wireless/radiotap.c	2015-06-23 14:54:17.991860557 +0200
@@ -54,7 +54,7 @@ static const struct ieee80211_radiotap_n
 };
 
 /**
- * ieee80211_radiotap_iterator_init - radiotap parser iterator initialization
+ * ieee80211_radiotap_iterator_init_dup - radiotap parser iterator initialization
  * @iterator: radiotap_iterator to initialize
  * @radiotap_header: radiotap header to parse
  * @max_length: total length we can parse into (eg, whole packet length)
@@ -62,15 +62,15 @@ static const struct ieee80211_radiotap_n
  * Returns: 0 or a negative error code if there is a problem.
  *
  * This function initializes an opaque iterator struct which can then
- * be passed to ieee80211_radiotap_iterator_next() to visit every radiotap
+ * be passed to ieee80211_radiotap_iterator_next_dup() to visit every radiotap
  * argument which is present in the header.  It knows about extended
  * present headers and handles them.
  *
  * How to use:
- * call __ieee80211_radiotap_iterator_init() to init a semi-opaque iterator
+ * call __ieee80211_radiotap_iterator_init_dup() to init a semi-opaque iterator
  * struct ieee80211_radiotap_iterator (no need to init the struct beforehand)
  * checking for a good 0 return code.  Then loop calling
- * __ieee80211_radiotap_iterator_next()... it returns either 0,
+ * __ieee80211_radiotap_iterator_next_dup()... it returns either 0,
  * -ENOENT if there are no more args to parse, or -EINVAL if there is a problem.
  * The iterator's @this_arg member points to the start of the argument
  * associated with the current argument index that is present, which can be
@@ -79,7 +79,7 @@ static const struct ieee80211_radiotap_n
  *
  * Radiotap header length:
  * You can find the CPU-endian total radiotap header length in
- * iterator->max_length after executing ieee80211_radiotap_iterator_init()
+ * iterator->max_length after executing ieee80211_radiotap_iterator_init_dup()
  * successfully.
  *
  * Alignment Gotcha:
@@ -92,7 +92,7 @@ static const struct ieee80211_radiotap_n
  * See Documentation/networking/radiotap-headers.txt
  */
 
-int ieee80211_radiotap_iterator_init(
+int ieee80211_radiotap_iterator_init_dup(
 	struct ieee80211_radiotap_iterator *iterator,
 	struct ieee80211_radiotap_header *radiotap_header,
 	int max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)
@@ -149,7 +149,7 @@ int ieee80211_radiotap_iterator_init(
 
 		/*
 		 * no need to check again for blowing past stated radiotap
-		 * header length, because ieee80211_radiotap_iterator_next
+		 * header length, because ieee80211_radiotap_iterator_next_dup
 		 * checks it before it is dereferenced
 		 */
 	}
@@ -160,7 +160,7 @@ int ieee80211_radiotap_iterator_init(
 
 	return 0;
 }
-EXPORT_SYMBOL(ieee80211_radiotap_iterator_init);
+EXPORT_SYMBOL(ieee80211_radiotap_iterator_init_dup);
 
 static void find_ns(struct ieee80211_radiotap_iterator *iterator,
 		    uint32_t oui, uint8_t subns)
@@ -186,7 +186,7 @@ static void find_ns(struct ieee80211_rad
 
 
 /**
- * ieee80211_radiotap_iterator_next - return next radiotap parser iterator arg
+ * ieee80211_radiotap_iterator_next_dup - return next radiotap parser iterator arg
  * @iterator: radiotap_iterator to move to next arg (if any)
  *
  * Returns: 0 if there is an argument to handle,
@@ -208,7 +208,7 @@ static void find_ns(struct ieee80211_rad
  * iterator.this_arg for type "type" safely on all arches.
  */
 
-int ieee80211_radiotap_iterator_next(
+int ieee80211_radiotap_iterator_next_dup(
 	struct ieee80211_radiotap_iterator *iterator)
 {
 	while (1) {
@@ -366,4 +366,4 @@ int ieee80211_radiotap_iterator_next(
 			return 0;
 	}
 }
-EXPORT_SYMBOL(ieee80211_radiotap_iterator_next);
+EXPORT_SYMBOL(ieee80211_radiotap_iterator_next_dup);
--- a/net/wireless/reg.c	2015-06-23 11:07:42.885851372 +0200
+++ b/net/wireless/reg.c	2015-06-23 14:54:18.041860781 +0200
@@ -1029,7 +1029,7 @@ freq_reg_info_regd(struct wiphy *wiphy,
 	return ERR_PTR(-EINVAL);
 }
 
-const struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,
+const struct ieee80211_reg_rule *freq_reg_info_dup(struct wiphy *wiphy,
 					       u32 center_freq)
 {
 	const struct ieee80211_regdomain *regd;
@@ -1038,9 +1038,9 @@ const struct ieee80211_reg_rule *freq_re
 
 	return freq_reg_info_regd(wiphy, center_freq, regd);
 }
-EXPORT_SYMBOL(freq_reg_info);
+EXPORT_SYMBOL(freq_reg_info_dup);
 
-const char *reg_initiator_name(enum nl80211_reg_initiator initiator)
+const char *reg_initiator_name_dup(enum nl80211_reg_initiator initiator)
 {
 	switch (initiator) {
 	case NL80211_REGDOM_SET_BY_CORE:
@@ -1056,7 +1056,7 @@ const char *reg_initiator_name(enum nl80
 		return "bug";
 	}
 }
-EXPORT_SYMBOL(reg_initiator_name);
+EXPORT_SYMBOL(reg_initiator_name_dup);
 
 #ifdef CONFIG_CFG80211_REG_DEBUG
 static void chan_reg_rule_print_dbg(const struct ieee80211_regdomain *regd,
@@ -1123,7 +1123,7 @@ static void handle_channel(struct wiphy
 
 	flags = chan->orig_flags;
 
-	reg_rule = freq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));
+	reg_rule = freq_reg_info_dup(wiphy, MHZ_TO_KHZ(chan->center_freq));
 	if (IS_ERR(reg_rule)) {
 		/*
 		 * We will disable all channels that do not match our
@@ -1310,7 +1310,7 @@ static bool ignore_reg_update(struct wip
 	if (!lr) {
 		REG_DBG_PRINT("Ignoring regulatory request set by %s "
 			      "since last_request is not set\n",
-			      reg_initiator_name(initiator));
+			      reg_initiator_name_dup(initiator));
 		return true;
 	}
 
@@ -1319,7 +1319,7 @@ static bool ignore_reg_update(struct wip
 		REG_DBG_PRINT("Ignoring regulatory request set by %s "
 			      "since the driver uses its own custom "
 			      "regulatory domain\n",
-			      reg_initiator_name(initiator));
+			      reg_initiator_name_dup(initiator));
 		return true;
 	}
 
@@ -1333,7 +1333,7 @@ static bool ignore_reg_update(struct wip
 		REG_DBG_PRINT("Ignoring regulatory request set by %s "
 			      "since the driver requires its own regulatory "
 			      "domain to be set first\n",
-			      reg_initiator_name(initiator));
+			      reg_initiator_name_dup(initiator));
 		return true;
 	}
 
@@ -1561,7 +1561,7 @@ static bool reg_wdev_chan_valid(struct w
 
 		if (!rdev->ops->get_channel ||
 		    rdev_get_channel(rdev, wdev, &chandef))
-			cfg80211_chandef_create(&chandef,
+			cfg80211_chandef_create_dup(&chandef,
 						wdev->current_bss->pub.channel,
 						NL80211_CHAN_NO_HT);
 		break;
@@ -1582,10 +1582,10 @@ static bool reg_wdev_chan_valid(struct w
 	case NL80211_IFTYPE_AP:
 	case NL80211_IFTYPE_P2P_GO:
 	case NL80211_IFTYPE_ADHOC:
-		return cfg80211_reg_can_beacon(wiphy, &chandef, iftype);
+		return cfg80211_reg_can_beacon_dup(wiphy, &chandef, iftype);
 	case NL80211_IFTYPE_STATION:
 	case NL80211_IFTYPE_P2P_CLIENT:
-		return cfg80211_chandef_usable(wiphy, &chandef,
+		return cfg80211_chandef_usable_dup(wiphy, &chandef,
 					       IEEE80211_CHAN_DISABLED);
 	default:
 		break;
@@ -1631,8 +1631,7 @@ static void reg_check_channels(void)
 	 * Give usermode a chance to do something nicer (move to another
 	 * channel, orderly disconnection), before forcing a disconnection.
 	 */
-	mod_delayed_work(system_wq,
-			 &reg_check_chans,
+	schedule_delayed_work(&reg_check_chans,
 			 msecs_to_jiffies(REG_ENFORCE_GRACE_MS));
 }
 
@@ -1750,7 +1749,7 @@ static void handle_band_custom(struct wi
 }
 
 /* Used by drivers prior to wiphy registration */
-void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
+void wiphy_apply_custom_regulatory_dup(struct wiphy *wiphy,
 				   const struct ieee80211_regdomain *regd)
 {
 	enum ieee80211_band band;
@@ -1773,7 +1772,7 @@ void wiphy_apply_custom_regulatory(struc
 	 */
 	WARN_ON(!bands_set);
 }
-EXPORT_SYMBOL(wiphy_apply_custom_regulatory);
+EXPORT_SYMBOL(wiphy_apply_custom_regulatory_dup);
 
 static void reg_set_request_processed(void)
 {
@@ -2076,8 +2075,7 @@ static void reg_process_hint(struct regu
 		    treatment == REG_REQ_ALREADY_SET ||
 		    treatment == REG_REQ_USER_HINT_HANDLED)
 			return;
-		queue_delayed_work(system_wq,
-				   &reg_timeout, msecs_to_jiffies(3142));
+		schedule_delayed_work(&reg_timeout, msecs_to_jiffies(3142));
 		return;
 	case NL80211_REGDOM_SET_BY_DRIVER:
 		if (!wiphy)
@@ -2247,7 +2245,7 @@ int regulatory_hint_indoor_user(void)
 }
 
 /* Driver hints */
-int regulatory_hint(struct wiphy *wiphy, const char *alpha2)
+int regulatory_hint_dup(struct wiphy *wiphy, const char *alpha2)
 {
 	struct regulatory_request *request;
 
@@ -2270,7 +2268,7 @@ int regulatory_hint(struct wiphy *wiphy,
 
 	return 0;
 }
-EXPORT_SYMBOL(regulatory_hint);
+EXPORT_SYMBOL(regulatory_hint_dup);
 
 void regulatory_hint_country_ie(struct wiphy *wiphy, enum ieee80211_band band,
 				const u8 *country_ie, u8 country_ie_len)
@@ -2481,9 +2479,9 @@ void regulatory_hint_disconnect(void)
 
 static bool freq_is_chan_12_13_14(u16 freq)
 {
-	if (freq == ieee80211_channel_to_frequency(12, IEEE80211_BAND_2GHZ) ||
-	    freq == ieee80211_channel_to_frequency(13, IEEE80211_BAND_2GHZ) ||
-	    freq == ieee80211_channel_to_frequency(14, IEEE80211_BAND_2GHZ))
+	if (freq == ieee80211_channel_to_frequency_dup(12, IEEE80211_BAND_2GHZ) ||
+	    freq == ieee80211_channel_to_frequency_dup(13, IEEE80211_BAND_2GHZ) ||
+	    freq == ieee80211_channel_to_frequency_dup(14, IEEE80211_BAND_2GHZ))
 		return true;
 	return false;
 }
@@ -2525,7 +2523,7 @@ int regulatory_hint_found_beacon(struct
 
 	REG_DBG_PRINT("Found new beacon on frequency: %d MHz (Ch %d) on %s\n",
 		      beacon_chan->center_freq,
-		      ieee80211_frequency_to_channel(beacon_chan->center_freq),
+		      ieee80211_frequency_to_channel_dup(beacon_chan->center_freq),
 		      wiphy_name(wiphy));
 
 	memcpy(&reg_beacon->chan, beacon_chan,
@@ -2712,8 +2710,7 @@ static int reg_set_rd_driver(const struc
 
 	request_wiphy = wiphy_idx_to_wiphy(driver_request->wiphy_idx);
 	if (!request_wiphy) {
-		queue_delayed_work(system_wq,
-				   &reg_timeout, 0);
+		schedule_delayed_work(&reg_timeout, 0);
 		return -ENODEV;
 	}
 
@@ -2773,8 +2770,7 @@ static int reg_set_rd_country_ie(const s
 
 	request_wiphy = wiphy_idx_to_wiphy(country_ie_request->wiphy_idx);
 	if (!request_wiphy) {
-		queue_delayed_work(system_wq,
-				   &reg_timeout, 0);
+		schedule_delayed_work(&reg_timeout, 0);
 		return -ENODEV;
 	}
 
--- a/net/wireless/scan.c	2015-06-23 11:07:42.886851383 +0200
+++ b/net/wireless/scan.c	2015-06-23 14:54:18.149861266 +0200
@@ -115,7 +115,7 @@ static inline void bss_ref_put(struct cf
 		bss_free(bss);
 }
 
-static bool __cfg80211_unlink_bss(struct cfg80211_registered_device *rdev,
+static bool __cfg80211_unlink_bss_dup(struct cfg80211_registered_device *rdev,
 				  struct cfg80211_internal_bss *bss)
 {
 	lockdep_assert_held(&rdev->bss_lock);
@@ -154,7 +154,7 @@ static void __cfg80211_bss_expire(struct
 		if (!time_after(expire_time, bss->ts))
 			continue;
 
-		if (__cfg80211_unlink_bss(rdev, bss))
+		if (__cfg80211_unlink_bss_dup(rdev, bss))
 			expired = true;
 	}
 
@@ -162,7 +162,7 @@ static void __cfg80211_bss_expire(struct
 		rdev->bss_generation++;
 }
 
-void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
+void ___cfg80211_scan_done_dup(struct cfg80211_registered_device *rdev,
 			   bool send_message)
 {
 	struct cfg80211_scan_request *request;
@@ -208,7 +208,7 @@ void ___cfg80211_scan_done(struct cfg802
 	if (wdev->netdev && !request->aborted) {
 		memset(&wrqu, 0, sizeof(wrqu));
 
-		wireless_send_event(wdev->netdev, SIOCGIWSCAN, &wrqu, NULL);
+		wireless_send_event_dup(wdev->netdev, SIOCGIWSCAN, &wrqu, NULL);
 	}
 #endif
 
@@ -224,7 +224,7 @@ void ___cfg80211_scan_done(struct cfg802
 		nl80211_send_scan_result(rdev, msg);
 }
 
-void __cfg80211_scan_done(struct work_struct *wk)
+void __cfg80211_scan_done_dup(struct work_struct *wk)
 {
 	struct cfg80211_registered_device *rdev;
 
@@ -232,22 +232,22 @@ void __cfg80211_scan_done(struct work_st
 			    scan_done_wk);
 
 	rtnl_lock();
-	___cfg80211_scan_done(rdev, true);
+	___cfg80211_scan_done_dup(rdev, true);
 	rtnl_unlock();
 }
 
-void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted)
+void cfg80211_scan_done_dup(struct cfg80211_scan_request *request, bool aborted)
 {
-	trace_cfg80211_scan_done(request, aborted);
+	trace_cfg80211_scan_done_dup(request, aborted);
 	WARN_ON(request != wiphy_to_rdev(request->wiphy)->scan_req);
 
 	request->aborted = aborted;
 	request->notified = true;
 	queue_work(cfg80211_wq, &wiphy_to_rdev(request->wiphy)->scan_done_wk);
 }
-EXPORT_SYMBOL(cfg80211_scan_done);
+EXPORT_SYMBOL(cfg80211_scan_done_dup);
 
-void __cfg80211_sched_scan_results(struct work_struct *wk)
+void __cfg80211_sched_scan_results_dup(struct work_struct *wk)
 {
 	struct cfg80211_registered_device *rdev;
 	struct cfg80211_sched_scan_request *request;
@@ -275,35 +275,35 @@ void __cfg80211_sched_scan_results(struc
 	rtnl_unlock();
 }
 
-void cfg80211_sched_scan_results(struct wiphy *wiphy)
+void cfg80211_sched_scan_results_dup(struct wiphy *wiphy)
 {
-	trace_cfg80211_sched_scan_results(wiphy);
+	trace_cfg80211_sched_scan_results_dup(wiphy);
 	/* ignore if we're not scanning */
 	if (wiphy_to_rdev(wiphy)->sched_scan_req)
 		queue_work(cfg80211_wq,
 			   &wiphy_to_rdev(wiphy)->sched_scan_results_wk);
 }
-EXPORT_SYMBOL(cfg80211_sched_scan_results);
+EXPORT_SYMBOL(cfg80211_sched_scan_results_dup);
 
-void cfg80211_sched_scan_stopped_rtnl(struct wiphy *wiphy)
+void cfg80211_sched_scan_stopped_rtnl_dup(struct wiphy *wiphy)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
 	ASSERT_RTNL();
 
-	trace_cfg80211_sched_scan_stopped(wiphy);
+	trace_cfg80211_sched_scan_stopped_dup(wiphy);
 
 	__cfg80211_stop_sched_scan(rdev, true);
 }
-EXPORT_SYMBOL(cfg80211_sched_scan_stopped_rtnl);
+EXPORT_SYMBOL(cfg80211_sched_scan_stopped_rtnl_dup);
 
-void cfg80211_sched_scan_stopped(struct wiphy *wiphy)
+void cfg80211_sched_scan_stopped_dup(struct wiphy *wiphy)
 {
 	rtnl_lock();
-	cfg80211_sched_scan_stopped_rtnl(wiphy);
+	cfg80211_sched_scan_stopped_rtnl_dup(wiphy);
 	rtnl_unlock();
 }
-EXPORT_SYMBOL(cfg80211_sched_scan_stopped);
+EXPORT_SYMBOL(cfg80211_sched_scan_stopped_dup);
 
 int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
 			       bool driver_initiated)
@@ -348,7 +348,7 @@ void cfg80211_bss_expire(struct cfg80211
 	__cfg80211_bss_expire(rdev, jiffies - IEEE80211_SCAN_RESULT_EXPIRE);
 }
 
-const u8 *cfg80211_find_ie(u8 eid, const u8 *ies, int len)
+const u8 *cfg80211_find_ie_dup(u8 eid, const u8 *ies, int len)
 {
 	while (len > 2 && ies[0] != eid) {
 		len -= ies[1] + 2;
@@ -360,9 +360,9 @@ const u8 *cfg80211_find_ie(u8 eid, const
 		return NULL;
 	return ies;
 }
-EXPORT_SYMBOL(cfg80211_find_ie);
+EXPORT_SYMBOL(cfg80211_find_ie_dup);
 
-const u8 *cfg80211_find_vendor_ie(unsigned int oui, u8 oui_type,
+const u8 *cfg80211_find_vendor_ie_dup(unsigned int oui, u8 oui_type,
 				  const u8 *ies, int len)
 {
 	struct ieee80211_vendor_ie *ie;
@@ -370,7 +370,7 @@ const u8 *cfg80211_find_vendor_ie(unsign
 	int ie_oui;
 
 	while (pos < end) {
-		pos = cfg80211_find_ie(WLAN_EID_VENDOR_SPECIFIC, pos,
+		pos = cfg80211_find_ie_dup(WLAN_EID_VENDOR_SPECIFIC, pos,
 				       end - pos);
 		if (!pos)
 			return NULL;
@@ -391,7 +391,7 @@ cont:
 	}
 	return NULL;
 }
-EXPORT_SYMBOL(cfg80211_find_vendor_ie);
+EXPORT_SYMBOL(cfg80211_find_vendor_ie_dup);
 
 static bool is_bss(struct cfg80211_bss *a, const u8 *bssid,
 		   const u8 *ssid, size_t ssid_len)
@@ -408,7 +408,7 @@ static bool is_bss(struct cfg80211_bss *
 	ies = rcu_access_pointer(a->ies);
 	if (!ies)
 		return false;
-	ssidie = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);
+	ssidie = cfg80211_find_ie_dup(WLAN_EID_SSID, ies->data, ies->len);
 	if (!ssidie)
 		return false;
 	if (ssidie[1] != ssid_len)
@@ -448,10 +448,10 @@ static int cmp_bss(struct cfg80211_bss *
 		return 1;
 
 	if (WLAN_CAPABILITY_IS_STA_BSS(a->capability))
-		ie1 = cfg80211_find_ie(WLAN_EID_MESH_ID,
+		ie1 = cfg80211_find_ie_dup(WLAN_EID_MESH_ID,
 				       a_ies->data, a_ies->len);
 	if (WLAN_CAPABILITY_IS_STA_BSS(b->capability))
-		ie2 = cfg80211_find_ie(WLAN_EID_MESH_ID,
+		ie2 = cfg80211_find_ie_dup(WLAN_EID_MESH_ID,
 				       b_ies->data, b_ies->len);
 	if (ie1 && ie2) {
 		int mesh_id_cmp;
@@ -461,9 +461,9 @@ static int cmp_bss(struct cfg80211_bss *
 		else
 			mesh_id_cmp = ie2[1] - ie1[1];
 
-		ie1 = cfg80211_find_ie(WLAN_EID_MESH_CONFIG,
+		ie1 = cfg80211_find_ie_dup(WLAN_EID_MESH_CONFIG,
 				       a_ies->data, a_ies->len);
-		ie2 = cfg80211_find_ie(WLAN_EID_MESH_CONFIG,
+		ie2 = cfg80211_find_ie_dup(WLAN_EID_MESH_CONFIG,
 				       b_ies->data, b_ies->len);
 		if (ie1 && ie2) {
 			if (mesh_id_cmp)
@@ -478,8 +478,8 @@ static int cmp_bss(struct cfg80211_bss *
 	if (r)
 		return r;
 
-	ie1 = cfg80211_find_ie(WLAN_EID_SSID, a_ies->data, a_ies->len);
-	ie2 = cfg80211_find_ie(WLAN_EID_SSID, b_ies->data, b_ies->len);
+	ie1 = cfg80211_find_ie_dup(WLAN_EID_SSID, a_ies->data, a_ies->len);
+	ie2 = cfg80211_find_ie_dup(WLAN_EID_SSID, b_ies->data, b_ies->len);
 
 	if (!ie1 && !ie2)
 		return 0;
@@ -529,7 +529,7 @@ static int cmp_bss(struct cfg80211_bss *
 }
 
 /* Returned bss is reference counted and must be cleaned up appropriately. */
-struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
+struct cfg80211_bss *cfg80211_get_bss_dup(struct wiphy *wiphy,
 				      struct ieee80211_channel *channel,
 				      const u8 *bssid,
 				      const u8 *ssid, size_t ssid_len,
@@ -539,7 +539,7 @@ struct cfg80211_bss *cfg80211_get_bss(st
 	struct cfg80211_internal_bss *bss, *res = NULL;
 	unsigned long now = jiffies;
 
-	trace_cfg80211_get_bss(wiphy, channel, bssid, ssid, ssid_len, capa_mask,
+	trace_cfg80211_get_bss_dup(wiphy, channel, bssid, ssid, ssid_len, capa_mask,
 			       capa_val);
 
 	spin_lock_bh(&rdev->bss_lock);
@@ -568,7 +568,7 @@ struct cfg80211_bss *cfg80211_get_bss(st
 	trace_cfg80211_return_bss(&res->pub);
 	return &res->pub;
 }
-EXPORT_SYMBOL(cfg80211_get_bss);
+EXPORT_SYMBOL(cfg80211_get_bss_dup);
 
 static void rb_insert_bss(struct cfg80211_registered_device *rdev,
 			  struct cfg80211_internal_bss *bss)
@@ -636,7 +636,7 @@ static bool cfg80211_combine_bsses(struc
 	if (WARN_ON(!ies))
 		return false;
 
-	ie = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);
+	ie = cfg80211_find_ie_dup(WLAN_EID_SSID, ies->data, ies->len);
 	if (!ie) {
 		/* nothing to do */
 		return true;
@@ -665,7 +665,7 @@ static bool cfg80211_combine_bsses(struc
 		ies = rcu_access_pointer(bss->pub.ies);
 		if (!ies)
 			continue;
-		ie = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);
+		ie = cfg80211_find_ie_dup(WLAN_EID_SSID, ies->data, ies->len);
 		if (!ie)
 			continue;
 		if (ssidlen && ie[1] != ssidlen)
@@ -856,11 +856,11 @@ cfg80211_get_bss_channel(struct wiphy *w
 	u32 freq;
 	int channel_number = -1;
 
-	tmp = cfg80211_find_ie(WLAN_EID_DS_PARAMS, ie, ielen);
+	tmp = cfg80211_find_ie_dup(WLAN_EID_DS_PARAMS, ie, ielen);
 	if (tmp && tmp[1] == 1) {
 		channel_number = tmp[2];
 	} else {
-		tmp = cfg80211_find_ie(WLAN_EID_HT_OPERATION, ie, ielen);
+		tmp = cfg80211_find_ie_dup(WLAN_EID_HT_OPERATION, ie, ielen);
 		if (tmp && tmp[1] >= sizeof(struct ieee80211_ht_operation)) {
 			struct ieee80211_ht_operation *htop = (void *)(tmp + 2);
 
@@ -871,7 +871,7 @@ cfg80211_get_bss_channel(struct wiphy *w
 	if (channel_number < 0)
 		return channel;
 
-	freq = ieee80211_channel_to_frequency(channel_number, channel->band);
+	freq = ieee80211_channel_to_frequency_dup(channel_number, channel->band);
 	channel = ieee80211_get_channel(wiphy, freq);
 	if (!channel)
 		return NULL;
@@ -882,7 +882,7 @@ cfg80211_get_bss_channel(struct wiphy *w
 
 /* Returned bss is reference counted and must be cleaned up appropriately. */
 struct cfg80211_bss*
-cfg80211_inform_bss_width(struct wiphy *wiphy,
+cfg80211_inform_bss_width_dup(struct wiphy *wiphy,
 			  struct ieee80211_channel *rx_channel,
 			  enum nl80211_bss_scan_width scan_width,
 			  enum cfg80211_bss_frame_type ftype,
@@ -954,11 +954,11 @@ cfg80211_inform_bss_width(struct wiphy *
 	/* cfg80211_bss_update gives us a referenced result */
 	return &res->pub;
 }
-EXPORT_SYMBOL(cfg80211_inform_bss_width);
+EXPORT_SYMBOL(cfg80211_inform_bss_width_dup);
 
 /* Returned bss is reference counted and must be cleaned up appropriately. */
 struct cfg80211_bss *
-cfg80211_inform_bss_width_frame(struct wiphy *wiphy,
+cfg80211_inform_bss_width_frame_dup(struct wiphy *wiphy,
 				struct ieee80211_channel *rx_channel,
 				enum nl80211_bss_scan_width scan_width,
 				struct ieee80211_mgmt *mgmt, size_t len,
@@ -974,7 +974,7 @@ cfg80211_inform_bss_width_frame(struct w
 	BUILD_BUG_ON(offsetof(struct ieee80211_mgmt, u.probe_resp.variable) !=
 			offsetof(struct ieee80211_mgmt, u.beacon.variable));
 
-	trace_cfg80211_inform_bss_width_frame(wiphy, rx_channel, scan_width, mgmt,
+	trace_cfg80211_inform_bss_width_frame_dup(wiphy, rx_channel, scan_width, mgmt,
 					      len, signal);
 
 	if (WARN_ON(!mgmt))
@@ -1029,9 +1029,9 @@ cfg80211_inform_bss_width_frame(struct w
 	/* cfg80211_bss_update gives us a referenced result */
 	return &res->pub;
 }
-EXPORT_SYMBOL(cfg80211_inform_bss_width_frame);
+EXPORT_SYMBOL(cfg80211_inform_bss_width_frame_dup);
 
-void cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)
+void cfg80211_ref_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *pub)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 	struct cfg80211_internal_bss *bss;
@@ -1045,9 +1045,9 @@ void cfg80211_ref_bss(struct wiphy *wiph
 	bss_ref_get(rdev, bss);
 	spin_unlock_bh(&rdev->bss_lock);
 }
-EXPORT_SYMBOL(cfg80211_ref_bss);
+EXPORT_SYMBOL(cfg80211_ref_bss_dup);
 
-void cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)
+void cfg80211_put_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *pub)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 	struct cfg80211_internal_bss *bss;
@@ -1061,9 +1061,9 @@ void cfg80211_put_bss(struct wiphy *wiph
 	bss_ref_put(rdev, bss);
 	spin_unlock_bh(&rdev->bss_lock);
 }
-EXPORT_SYMBOL(cfg80211_put_bss);
+EXPORT_SYMBOL(cfg80211_put_bss_dup);
 
-void cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)
+void cfg80211_unlink_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *pub)
 {
 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 	struct cfg80211_internal_bss *bss;
@@ -1075,12 +1075,12 @@ void cfg80211_unlink_bss(struct wiphy *w
 
 	spin_lock_bh(&rdev->bss_lock);
 	if (!list_empty(&bss->list)) {
-		if (__cfg80211_unlink_bss(rdev, bss))
+		if (__cfg80211_unlink_bss_dup(rdev, bss))
 			rdev->bss_generation++;
 	}
 	spin_unlock_bh(&rdev->bss_lock);
 }
-EXPORT_SYMBOL(cfg80211_unlink_bss);
+EXPORT_SYMBOL(cfg80211_unlink_bss_dup);
 
 #ifdef CONFIG_CFG80211_WEXT
 static struct cfg80211_registered_device *
@@ -1102,7 +1102,7 @@ cfg80211_get_dev_from_ifindex(struct net
 	return rdev;
 }
 
-int cfg80211_wext_siwscan(struct net_device *dev,
+int cfg80211_wext_siwscan_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  union iwreq_data *wrqu, char *extra)
 {
@@ -1135,7 +1135,7 @@ int cfg80211_wext_siwscan(struct net_dev
 	if (wreq && wreq->num_channels)
 		n_channels = wreq->num_channels;
 	else
-		n_channels = ieee80211_get_num_supported_channels(wiphy);
+		n_channels = ieee80211_get_num_supported_channels_dup(wiphy);
 
 	creq = kzalloc(sizeof(*creq) + sizeof(struct cfg80211_ssid) +
 		       n_channels * sizeof(void *),
@@ -1234,7 +1234,7 @@ int cfg80211_wext_siwscan(struct net_dev
 	kfree(creq);
 	return err;
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_siwscan);
+EXPORT_SYMBOL_GPL(cfg80211_wext_siwscan_dup);
 
 static void ieee80211_scan_add_ies(struct iw_request_info *info,
 				   const struct cfg80211_bss_ies *ies,
@@ -1299,7 +1299,7 @@ ieee80211_bss(struct wiphy *wiphy, struc
 
 	memset(&iwe, 0, sizeof(iwe));
 	iwe.cmd = SIOCGIWFREQ;
-	iwe.u.freq.m = ieee80211_frequency_to_channel(bss->pub.channel->center_freq);
+	iwe.u.freq.m = ieee80211_frequency_to_channel_dup(bss->pub.channel->center_freq);
 	iwe.u.freq.e = 0;
 	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe,
 					  IW_EV_FREQ_LEN);
@@ -1515,7 +1515,7 @@ static int ieee80211_scan_results(struct
 }
 
 
-int cfg80211_wext_giwscan(struct net_device *dev,
+int cfg80211_wext_giwscan_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_point *data, char *extra)
 {
@@ -1542,5 +1542,5 @@ int cfg80211_wext_giwscan(struct net_dev
 
 	return res;
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_giwscan);
+EXPORT_SYMBOL_GPL(cfg80211_wext_giwscan_dup);
 #endif
--- a/net/wireless/sme.c	2015-06-23 11:07:42.886851383 +0200
+++ b/net/wireless/sme.c	2015-06-24 09:24:38.357203734 +0200
@@ -72,7 +72,7 @@ static int cfg80211_conn_scan(struct wir
 	if (wdev->conn->params.channel)
 		n_channels = 1;
 	else
-		n_channels = ieee80211_get_num_supported_channels(wdev->wiphy);
+		n_channels = ieee80211_get_num_supported_channels_dup(wdev->wiphy);
 
 	request = kzalloc(sizeof(*request) + sizeof(request->ssids[0]) +
 			  sizeof(request->channels[0]) * n_channels,
@@ -240,7 +240,7 @@ void cfg80211_conn_work(struct work_stru
 			bssid = bssid_buf;
 		}
 		if (cfg80211_conn_do_work(wdev)) {
-			__cfg80211_connect_result(
+			__cfg80211_connect_result_dup(
 					wdev->netdev, bssid,
 					NULL, 0, NULL, 0,
 					WLAN_STATUS_UNSPECIFIED_FAILURE,
@@ -264,7 +264,7 @@ static struct cfg80211_bss *cfg80211_get
 	if (wdev->conn->params.privacy)
 		capa |= WLAN_CAPABILITY_PRIVACY;
 
-	bss = cfg80211_get_bss(wdev->wiphy, wdev->conn->params.channel,
+	bss = cfg80211_get_bss_dup(wdev->wiphy, wdev->conn->params.channel,
 			       wdev->conn->params.bssid,
 			       wdev->conn->params.ssid,
 			       wdev->conn->params.ssid_len,
@@ -299,7 +299,7 @@ static void __cfg80211_sme_scan_done(str
 
 	bss = cfg80211_get_conn_bss(wdev);
 	if (bss)
-		cfg80211_put_bss(&rdev->wiphy, bss);
+		cfg80211_put_bss_dup(&rdev->wiphy, bss);
 	else
 		schedule_work(&rdev->conn_work);
 }
@@ -351,7 +351,7 @@ void cfg80211_sme_rx_auth(struct wireles
 		wdev->conn->state = CFG80211_CONN_AUTHENTICATE_NEXT;
 		schedule_work(&rdev->conn_work);
 	} else if (status_code != WLAN_STATUS_SUCCESS) {
-		__cfg80211_connect_result(wdev->netdev, mgmt->bssid,
+		__cfg80211_connect_result_dup(wdev->netdev, mgmt->bssid,
 					  NULL, 0, NULL, 0,
 					  status_code, false, NULL);
 	} else if (wdev->conn->state == CFG80211_CONN_AUTHENTICATING) {
@@ -491,7 +491,7 @@ static int cfg80211_sme_connect(struct w
 	/* we're good if we have a matching bss struct */
 	if (bss) {
 		err = cfg80211_conn_do_work(wdev);
-		cfg80211_put_bss(wdev->wiphy, bss);
+		cfg80211_put_bss_dup(wdev->wiphy, bss);
 	} else {
 		/* otherwise we'll need to scan for the AP first */
 		err = cfg80211_conn_scan(wdev);
@@ -583,7 +583,7 @@ static DECLARE_WORK(cfg80211_disconnect_
  */
 
 /* This method must consume bss one way or another */
-void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
+void __cfg80211_connect_result_dup(struct net_device *dev, const u8 *bssid,
 			       const u8 *req_ie, size_t req_ie_len,
 			       const u8 *resp_ie, size_t resp_ie_len,
 			       u16 status, bool wextev,
@@ -599,7 +599,7 @@ void __cfg80211_connect_result(struct ne
 
 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&
 		    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)) {
-		cfg80211_put_bss(wdev->wiphy, bss);
+		cfg80211_put_bss_dup(wdev->wiphy, bss);
 		return;
 	}
 
@@ -613,13 +613,13 @@ void __cfg80211_connect_result(struct ne
 		if (req_ie && status == WLAN_STATUS_SUCCESS) {
 			memset(&wrqu, 0, sizeof(wrqu));
 			wrqu.data.length = req_ie_len;
-			wireless_send_event(dev, IWEVASSOCREQIE, &wrqu, req_ie);
+			wireless_send_event_dup(dev, IWEVASSOCREQIE, &wrqu, req_ie);
 		}
 
 		if (resp_ie && status == WLAN_STATUS_SUCCESS) {
 			memset(&wrqu, 0, sizeof(wrqu));
 			wrqu.data.length = resp_ie_len;
-			wireless_send_event(dev, IWEVASSOCRESPIE, &wrqu, resp_ie);
+			wireless_send_event_dup(dev, IWEVASSOCRESPIE, &wrqu, resp_ie);
 		}
 
 		memset(&wrqu, 0, sizeof(wrqu));
@@ -629,13 +629,13 @@ void __cfg80211_connect_result(struct ne
 			memcpy(wdev->wext.prev_bssid, bssid, ETH_ALEN);
 			wdev->wext.prev_bssid_valid = true;
 		}
-		wireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);
+		wireless_send_event_dup(dev, SIOCGIWAP, &wrqu, NULL);
 	}
 #endif
 
 	if (!bss && (status == WLAN_STATUS_SUCCESS)) {
 		WARN_ON_ONCE(!wiphy_to_rdev(wdev->wiphy)->ops->connect);
-		bss = cfg80211_get_bss(wdev->wiphy, NULL, bssid,
+		bss = cfg80211_get_bss_dup(wdev->wiphy, NULL, bssid,
 				       wdev->ssid, wdev->ssid_len,
 				       WLAN_CAPABILITY_ESS,
 				       WLAN_CAPABILITY_ESS);
@@ -645,7 +645,7 @@ void __cfg80211_connect_result(struct ne
 
 	if (wdev->current_bss) {
 		cfg80211_unhold_bss(wdev->current_bss);
-		cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
+		cfg80211_put_bss_dup(wdev->wiphy, &wdev->current_bss->pub);
 		wdev->current_bss = NULL;
 	}
 
@@ -655,7 +655,7 @@ void __cfg80211_connect_result(struct ne
 		wdev->ssid_len = 0;
 		if (bss) {
 			cfg80211_unhold_bss(bss_from_pub(bss));
-			cfg80211_put_bss(wdev->wiphy, bss);
+			cfg80211_put_bss_dup(wdev->wiphy, bss);
 		}
 		cfg80211_sme_free(wdev);
 		return;
@@ -669,7 +669,7 @@ void __cfg80211_connect_result(struct ne
 	cfg80211_upload_connect_keys(wdev);
 
 	rcu_read_lock();
-	country_ie = ieee80211_bss_get_ie(bss, WLAN_EID_COUNTRY);
+	country_ie = ieee80211_bss_get_ie_dup(bss, WLAN_EID_COUNTRY);
 	if (!country_ie) {
 		rcu_read_unlock();
 		return;
@@ -682,7 +682,7 @@ void __cfg80211_connect_result(struct ne
 		return;
 
 	/*
-	 * ieee80211_bss_get_ie() ensures we can access:
+	 * ieee80211_bss_get_ie_dup() ensures we can access:
 	 * - country_ie + 2, the start of the country ie data, and
 	 * - and country_ie[1] which is the IE length
 	 */
@@ -691,7 +691,7 @@ void __cfg80211_connect_result(struct ne
 	kfree(country_ie);
 }
 
-void cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
+void cfg80211_connect_result_dup(struct net_device *dev, const u8 *bssid,
 			     const u8 *req_ie, size_t req_ie_len,
 			     const u8 *resp_ie, size_t resp_ie_len,
 			     u16 status, gfp_t gfp)
@@ -725,10 +725,10 @@ void cfg80211_connect_result(struct net_
 	spin_unlock_irqrestore(&wdev->event_lock, flags);
 	queue_work(cfg80211_wq, &rdev->event_work);
 }
-EXPORT_SYMBOL(cfg80211_connect_result);
+EXPORT_SYMBOL(cfg80211_connect_result_dup);
 
 /* Consumes bss object one way or another */
-void __cfg80211_roamed(struct wireless_dev *wdev,
+void __cfg80211_roamed_dup(struct wireless_dev *wdev,
 		       struct cfg80211_bss *bss,
 		       const u8 *req_ie, size_t req_ie_len,
 		       const u8 *resp_ie, size_t resp_ie_len)
@@ -746,7 +746,7 @@ void __cfg80211_roamed(struct wireless_d
 		goto out;
 
 	cfg80211_unhold_bss(wdev->current_bss);
-	cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
+	cfg80211_put_bss_dup(wdev->wiphy, &wdev->current_bss->pub);
 	wdev->current_bss = NULL;
 
 	cfg80211_hold_bss(bss_from_pub(bss));
@@ -761,14 +761,14 @@ void __cfg80211_roamed(struct wireless_d
 	if (req_ie) {
 		memset(&wrqu, 0, sizeof(wrqu));
 		wrqu.data.length = req_ie_len;
-		wireless_send_event(wdev->netdev, IWEVASSOCREQIE,
+		wireless_send_event_dup(wdev->netdev, IWEVASSOCREQIE,
 				    &wrqu, req_ie);
 	}
 
 	if (resp_ie) {
 		memset(&wrqu, 0, sizeof(wrqu));
 		wrqu.data.length = resp_ie_len;
-		wireless_send_event(wdev->netdev, IWEVASSOCRESPIE,
+		wireless_send_event_dup(wdev->netdev, IWEVASSOCRESPIE,
 				    &wrqu, resp_ie);
 	}
 
@@ -777,15 +777,15 @@ void __cfg80211_roamed(struct wireless_d
 	memcpy(wrqu.ap_addr.sa_data, bss->bssid, ETH_ALEN);
 	memcpy(wdev->wext.prev_bssid, bss->bssid, ETH_ALEN);
 	wdev->wext.prev_bssid_valid = true;
-	wireless_send_event(wdev->netdev, SIOCGIWAP, &wrqu, NULL);
+	wireless_send_event_dup(wdev->netdev, SIOCGIWAP, &wrqu, NULL);
 #endif
 
 	return;
 out:
-	cfg80211_put_bss(wdev->wiphy, bss);
+	cfg80211_put_bss_dup(wdev->wiphy, bss);
 }
 
-void cfg80211_roamed(struct net_device *dev,
+void cfg80211_roamed_dup(struct net_device *dev,
 		     struct ieee80211_channel *channel,
 		     const u8 *bssid,
 		     const u8 *req_ie, size_t req_ie_len,
@@ -794,19 +794,19 @@ void cfg80211_roamed(struct net_device *
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 	struct cfg80211_bss *bss;
 
-	bss = cfg80211_get_bss(wdev->wiphy, channel, bssid, wdev->ssid,
+	bss = cfg80211_get_bss_dup(wdev->wiphy, channel, bssid, wdev->ssid,
 			       wdev->ssid_len, WLAN_CAPABILITY_ESS,
 			       WLAN_CAPABILITY_ESS);
 	if (WARN_ON(!bss))
 		return;
 
-	cfg80211_roamed_bss(dev, bss, req_ie, req_ie_len, resp_ie,
+	cfg80211_roamed_bss_dup(dev, bss, req_ie, req_ie_len, resp_ie,
 			    resp_ie_len, gfp);
 }
-EXPORT_SYMBOL(cfg80211_roamed);
+EXPORT_SYMBOL(cfg80211_roamed_dup);
 
 /* Consumes bss object one way or another */
-void cfg80211_roamed_bss(struct net_device *dev,
+void cfg80211_roamed_bss_dup(struct net_device *dev,
 			 struct cfg80211_bss *bss, const u8 *req_ie,
 			 size_t req_ie_len, const u8 *resp_ie,
 			 size_t resp_ie_len, gfp_t gfp)
@@ -821,7 +821,7 @@ void cfg80211_roamed_bss(struct net_devi
 
 	ev = kzalloc(sizeof(*ev) + req_ie_len + resp_ie_len, gfp);
 	if (!ev) {
-		cfg80211_put_bss(wdev->wiphy, bss);
+		cfg80211_put_bss_dup(wdev->wiphy, bss);
 		return;
 	}
 
@@ -839,9 +839,9 @@ void cfg80211_roamed_bss(struct net_devi
 	spin_unlock_irqrestore(&wdev->event_lock, flags);
 	queue_work(cfg80211_wq, &rdev->event_work);
 }
-EXPORT_SYMBOL(cfg80211_roamed_bss);
+EXPORT_SYMBOL(cfg80211_roamed_bss_dup);
 
-void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
+void __cfg80211_disconnected_dup(struct net_device *dev, const u8 *ie,
 			     size_t ie_len, u16 reason, bool from_ap)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -859,7 +859,7 @@ void __cfg80211_disconnected(struct net_
 
 	if (wdev->current_bss) {
 		cfg80211_unhold_bss(wdev->current_bss);
-		cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
+		cfg80211_put_bss_dup(wdev->wiphy, &wdev->current_bss->pub);
 	}
 
 	wdev->current_bss = NULL;
@@ -880,14 +880,14 @@ void __cfg80211_disconnected(struct net_
 #ifdef CONFIG_CFG80211_WEXT
 	memset(&wrqu, 0, sizeof(wrqu));
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	wireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);
+	wireless_send_event_dup(dev, SIOCGIWAP, &wrqu, NULL);
 	wdev->wext.connect.ssid_len = 0;
 #endif
 
 	schedule_work(&cfg80211_disconnect_work);
 }
 
-void cfg80211_disconnected(struct net_device *dev, u16 reason,
+void cfg80211_disconnected_dup(struct net_device *dev, u16 reason,
 			   const u8 *ie, size_t ie_len, gfp_t gfp)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -910,7 +910,7 @@ void cfg80211_disconnected(struct net_de
 	spin_unlock_irqrestore(&wdev->event_lock, flags);
 	queue_work(cfg80211_wq, &rdev->event_work);
 }
-EXPORT_SYMBOL(cfg80211_disconnected);
+EXPORT_SYMBOL(cfg80211_disconnected_dup);
 
 /*
  * API calls for nl80211/wext compatibility code
--- a/net/wireless/trace.h	2015-06-23 11:07:42.886851383 +0200
+++ b/net/wireless/trace.h	2015-06-23 14:54:18.242861684 +0200
@@ -2108,7 +2108,7 @@ DECLARE_EVENT_CLASS(cfg80211_netdev_mac_
 		  NETDEV_PR_ARG, MAC_PR_ARG(macaddr))
 );
 
-DEFINE_EVENT(cfg80211_netdev_mac_evt, cfg80211_notify_new_peer_candidate,
+DEFINE_EVENT(cfg80211_netdev_mac_evt, cfg80211_notify_new_peer_candidate_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *macaddr),
 	TP_ARGS(netdev, macaddr)
 );
@@ -2163,17 +2163,17 @@ DECLARE_EVENT_CLASS(netdev_frame_event,
 		  le16_to_cpup((__le16 *)__get_dynamic_array(frame)))
 );
 
-DEFINE_EVENT(netdev_frame_event, cfg80211_rx_unprot_mlme_mgmt,
+DEFINE_EVENT(netdev_frame_event, cfg80211_rx_unprot_mlme_mgmt_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *buf, int len),
 	TP_ARGS(netdev, buf, len)
 );
 
-DEFINE_EVENT(netdev_frame_event, cfg80211_rx_mlme_mgmt,
+DEFINE_EVENT(netdev_frame_event, cfg80211_rx_mlme_mgmt_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *buf, int len),
 	TP_ARGS(netdev, buf, len)
 );
 
-TRACE_EVENT(cfg80211_tx_mlme_mgmt,
+TRACE_EVENT(cfg80211_tx_mlme_mgmt_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *buf, int len),
 	TP_ARGS(netdev, buf, len),
 	TP_STRUCT__entry(
@@ -2214,7 +2214,7 @@ DEFINE_EVENT(netdev_mac_evt, cfg80211_se
 	TP_ARGS(netdev, mac)
 );
 
-TRACE_EVENT(cfg80211_michael_mic_failure,
+TRACE_EVENT(cfg80211_michael_mic_failure_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *addr,
 		 enum nl80211_key_type key_type, int key_id, const u8 *tsc),
 	TP_ARGS(netdev, addr, key_type, key_id, tsc),
@@ -2238,7 +2238,7 @@ TRACE_EVENT(cfg80211_michael_mic_failure
 		  __entry->key_id, __entry->tsc)
 );
 
-TRACE_EVENT(cfg80211_ready_on_channel,
+TRACE_EVENT(cfg80211_ready_on_channel_dup,
 	TP_PROTO(struct wireless_dev *wdev, u64 cookie,
 		 struct ieee80211_channel *chan,
 		 unsigned int duration),
@@ -2278,7 +2278,7 @@ TRACE_EVENT(cfg80211_ready_on_channel_ex
 		  WDEV_PR_ARG, __entry->cookie, CHAN_PR_ARG)
 );
 
-TRACE_EVENT(cfg80211_new_sta,
+TRACE_EVENT(cfg80211_new_sta_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *mac_addr,
 		 struct station_info *sinfo),
 	TP_ARGS(netdev, mac_addr, sinfo),
@@ -2296,12 +2296,12 @@ TRACE_EVENT(cfg80211_new_sta,
 		  NETDEV_PR_ARG, MAC_PR_ARG(mac_addr))
 );
 
-DEFINE_EVENT(cfg80211_netdev_mac_evt, cfg80211_del_sta,
+DEFINE_EVENT(cfg80211_netdev_mac_evt, cfg80211_del_sta_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *macaddr),
 	TP_ARGS(netdev, macaddr)
 );
 
-TRACE_EVENT(cfg80211_rx_mgmt,
+TRACE_EVENT(cfg80211_rx_mgmt_dup,
 	TP_PROTO(struct wireless_dev *wdev, int freq, int sig_mbm),
 	TP_ARGS(wdev, freq, sig_mbm),
 	TP_STRUCT__entry(
@@ -2318,7 +2318,7 @@ TRACE_EVENT(cfg80211_rx_mgmt,
 		  WDEV_PR_ARG, __entry->freq, __entry->sig_mbm)
 );
 
-TRACE_EVENT(cfg80211_mgmt_tx_status,
+TRACE_EVENT(cfg80211_mgmt_tx_status_dup,
 	TP_PROTO(struct wireless_dev *wdev, u64 cookie, bool ack),
 	TP_ARGS(wdev, cookie, ack),
 	TP_STRUCT__entry(
@@ -2335,7 +2335,7 @@ TRACE_EVENT(cfg80211_mgmt_tx_status,
 		  WDEV_PR_ARG, __entry->cookie, BOOL_TO_STR(__entry->ack))
 );
 
-TRACE_EVENT(cfg80211_cqm_rssi_notify,
+TRACE_EVENT(cfg80211_cqm_rssi_notify_dup,
 	TP_PROTO(struct net_device *netdev,
 		 enum nl80211_cqm_rssi_threshold_event rssi_event),
 	TP_ARGS(netdev, rssi_event),
@@ -2351,7 +2351,7 @@ TRACE_EVENT(cfg80211_cqm_rssi_notify,
 		  NETDEV_PR_ARG, __entry->rssi_event)
 );
 
-TRACE_EVENT(cfg80211_reg_can_beacon,
+TRACE_EVENT(cfg80211_reg_can_beacon_dup,
 	TP_PROTO(struct wiphy *wiphy, struct cfg80211_chan_def *chandef,
 		 enum nl80211_iftype iftype),
 	TP_ARGS(wiphy, chandef, iftype),
@@ -2369,7 +2369,7 @@ TRACE_EVENT(cfg80211_reg_can_beacon,
 		  WIPHY_PR_ARG, CHAN_DEF_PR_ARG, __entry->iftype)
 );
 
-TRACE_EVENT(cfg80211_chandef_dfs_required,
+TRACE_EVENT(cfg80211_chandef_dfs_required_dup,
 	TP_PROTO(struct wiphy *wiphy, struct cfg80211_chan_def *chandef),
 	TP_ARGS(wiphy, chandef),
 	TP_STRUCT__entry(
@@ -2384,7 +2384,7 @@ TRACE_EVENT(cfg80211_chandef_dfs_require
 		  WIPHY_PR_ARG, CHAN_DEF_PR_ARG)
 );
 
-TRACE_EVENT(cfg80211_ch_switch_notify,
+TRACE_EVENT(cfg80211_ch_switch_notify_dup,
 	TP_PROTO(struct net_device *netdev,
 		 struct cfg80211_chan_def *chandef),
 	TP_ARGS(netdev, chandef),
@@ -2400,7 +2400,7 @@ TRACE_EVENT(cfg80211_ch_switch_notify,
 		  NETDEV_PR_ARG, CHAN_DEF_PR_ARG)
 );
 
-TRACE_EVENT(cfg80211_ch_switch_started_notify,
+TRACE_EVENT(cfg80211_ch_switch_started_notify_dup,
 	TP_PROTO(struct net_device *netdev,
 		 struct cfg80211_chan_def *chandef),
 	TP_ARGS(netdev, chandef),
@@ -2416,7 +2416,7 @@ TRACE_EVENT(cfg80211_ch_switch_started_n
 		  NETDEV_PR_ARG, CHAN_DEF_PR_ARG)
 );
 
-TRACE_EVENT(cfg80211_radar_event,
+TRACE_EVENT(cfg80211_radar_event_dup,
 	TP_PROTO(struct wiphy *wiphy, struct cfg80211_chan_def *chandef),
 	TP_ARGS(wiphy, chandef),
 	TP_STRUCT__entry(
@@ -2431,7 +2431,7 @@ TRACE_EVENT(cfg80211_radar_event,
 		  WIPHY_PR_ARG, CHAN_DEF_PR_ARG)
 );
 
-TRACE_EVENT(cfg80211_cac_event,
+TRACE_EVENT(cfg80211_cac_event_dup,
 	TP_PROTO(struct net_device *netdev, enum nl80211_radar_event evt),
 	TP_ARGS(netdev, evt),
 	TP_STRUCT__entry(
@@ -2460,17 +2460,17 @@ DECLARE_EVENT_CLASS(cfg80211_rx_evt,
 	TP_printk(NETDEV_PR_FMT ", " MAC_PR_FMT, NETDEV_PR_ARG, MAC_PR_ARG(addr))
 );
 
-DEFINE_EVENT(cfg80211_rx_evt, cfg80211_rx_spurious_frame,
+DEFINE_EVENT(cfg80211_rx_evt, cfg80211_rx_spurious_frame_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *addr),
 	TP_ARGS(netdev, addr)
 );
 
-DEFINE_EVENT(cfg80211_rx_evt, cfg80211_rx_unexpected_4addr_frame,
+DEFINE_EVENT(cfg80211_rx_evt, cfg80211_rx_unexpected_4addr_frame_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *addr),
 	TP_ARGS(netdev, addr)
 );
 
-TRACE_EVENT(cfg80211_ibss_joined,
+TRACE_EVENT(cfg80211_ibss_joined_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *bssid,
 		 struct ieee80211_channel *channel),
 	TP_ARGS(netdev, bssid, channel),
@@ -2488,7 +2488,7 @@ TRACE_EVENT(cfg80211_ibss_joined,
 		  NETDEV_PR_ARG, MAC_PR_ARG(bssid), CHAN_PR_ARG)
 );
 
-TRACE_EVENT(cfg80211_probe_status,
+TRACE_EVENT(cfg80211_probe_status_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *addr, u64 cookie,
 		 bool acked),
 	TP_ARGS(netdev, addr, cookie, acked),
@@ -2509,7 +2509,7 @@ TRACE_EVENT(cfg80211_probe_status,
 		  BOOL_TO_STR(__entry->acked))
 );
 
-TRACE_EVENT(cfg80211_cqm_pktloss_notify,
+TRACE_EVENT(cfg80211_cqm_pktloss_notify_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *peer, u32 num_packets),
 	TP_ARGS(netdev, peer, num_packets),
 	TP_STRUCT__entry(
@@ -2526,12 +2526,12 @@ TRACE_EVENT(cfg80211_cqm_pktloss_notify,
 		  NETDEV_PR_ARG, MAC_PR_ARG(peer), __entry->num_packets)
 );
 
-DEFINE_EVENT(cfg80211_netdev_mac_evt, cfg80211_gtk_rekey_notify,
+DEFINE_EVENT(cfg80211_netdev_mac_evt, cfg80211_gtk_rekey_notify_dup,
 	TP_PROTO(struct net_device *netdev, const u8 *macaddr),
 	TP_ARGS(netdev, macaddr)
 );
 
-TRACE_EVENT(cfg80211_pmksa_candidate_notify,
+TRACE_EVENT(cfg80211_pmksa_candidate_notify_dup,
 	TP_PROTO(struct net_device *netdev, int index, const u8 *bssid,
 		 bool preauth),
 	TP_ARGS(netdev, index, bssid, preauth),
@@ -2552,7 +2552,7 @@ TRACE_EVENT(cfg80211_pmksa_candidate_not
 		  BOOL_TO_STR(__entry->preauth))
 );
 
-TRACE_EVENT(cfg80211_report_obss_beacon,
+TRACE_EVENT(cfg80211_report_obss_beacon_dup,
 	TP_PROTO(struct wiphy *wiphy, const u8 *frame, size_t len,
 		 int freq, int sig_dbm),
 	TP_ARGS(wiphy, frame, len, freq, sig_dbm),
@@ -2570,7 +2570,7 @@ TRACE_EVENT(cfg80211_report_obss_beacon,
 		  WIPHY_PR_ARG, __entry->freq, __entry->sig_dbm)
 );
 
-TRACE_EVENT(cfg80211_tdls_oper_request,
+TRACE_EVENT(cfg80211_tdls_oper_request_dup,
 	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev, const u8 *peer,
 		 enum nl80211_tdls_operation oper, u16 reason_code),
 	TP_ARGS(wiphy, netdev, peer, oper, reason_code),
@@ -2593,7 +2593,7 @@ TRACE_EVENT(cfg80211_tdls_oper_request,
 		  __entry->reason_code)
 	);
 
-TRACE_EVENT(cfg80211_scan_done,
+TRACE_EVENT(cfg80211_scan_done_dup,
 	TP_PROTO(struct cfg80211_scan_request *request, bool aborted),
 	TP_ARGS(request, aborted),
 	TP_STRUCT__entry(
@@ -2623,17 +2623,17 @@ TRACE_EVENT(cfg80211_scan_done,
 	TP_printk("aborted: %s", BOOL_TO_STR(__entry->aborted))
 );
 
-DEFINE_EVENT(wiphy_only_evt, cfg80211_sched_scan_results,
+DEFINE_EVENT(wiphy_only_evt, cfg80211_sched_scan_results_dup,
 	TP_PROTO(struct wiphy *wiphy),
 	TP_ARGS(wiphy)
 );
 
-DEFINE_EVENT(wiphy_only_evt, cfg80211_sched_scan_stopped,
+DEFINE_EVENT(wiphy_only_evt, cfg80211_sched_scan_stopped_dup,
 	TP_PROTO(struct wiphy *wiphy),
 	TP_ARGS(wiphy)
 );
 
-TRACE_EVENT(cfg80211_get_bss,
+TRACE_EVENT(cfg80211_get_bss_dup,
 	TP_PROTO(struct wiphy *wiphy, struct ieee80211_channel *channel,
 		 const u8 *bssid, const u8 *ssid, size_t ssid_len,
 		 u16 capa_mask, u16 capa_val),
@@ -2660,7 +2660,7 @@ TRACE_EVENT(cfg80211_get_bss,
 		  __entry->capa_mask, __entry->capa_val)
 );
 
-TRACE_EVENT(cfg80211_inform_bss_width_frame,
+TRACE_EVENT(cfg80211_inform_bss_width_frame_dup,
 	TP_PROTO(struct wiphy *wiphy, struct ieee80211_channel *channel,
 		 enum nl80211_bss_scan_width scan_width,
 		 struct ieee80211_mgmt *mgmt, size_t len,
@@ -2729,7 +2729,7 @@ TRACE_EVENT(cfg80211_return_u32,
 	TP_printk("ret: %u", __entry->ret)
 );
 
-TRACE_EVENT(cfg80211_report_wowlan_wakeup,
+TRACE_EVENT(cfg80211_report_wowlan_wakeup_dup,
 	TP_PROTO(struct wiphy *wiphy, struct wireless_dev *wdev,
 		 struct cfg80211_wowlan_wakeup *wakeup),
 	TP_ARGS(wiphy, wdev, wakeup),
@@ -2767,7 +2767,7 @@ TRACE_EVENT(cfg80211_report_wowlan_wakeu
 	TP_printk(WIPHY_PR_FMT ", " WDEV_PR_FMT, WIPHY_PR_ARG, WDEV_PR_ARG)
 );
 
-TRACE_EVENT(cfg80211_ft_event,
+TRACE_EVENT(cfg80211_ft_event_dup,
 	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
 		 struct cfg80211_ft_event_params *ft_event),
 	TP_ARGS(wiphy, netdev, ft_event),
@@ -2793,7 +2793,7 @@ TRACE_EVENT(cfg80211_ft_event,
 		  WIPHY_PR_ARG, NETDEV_PR_ARG, MAC_PR_ARG(target_ap))
 );
 
-TRACE_EVENT(cfg80211_stop_iface,
+TRACE_EVENT(cfg80211_stop_iface_dup,
 	TP_PROTO(struct wiphy *wiphy, struct wireless_dev *wdev),
 	TP_ARGS(wiphy, wdev),
 	TP_STRUCT__entry(
--- a/net/wireless/util.c	2015-06-23 11:07:42.886851383 +0200
+++ b/net/wireless/util.c	2015-06-23 14:54:18.298861936 +0200
@@ -18,7 +18,7 @@
 
 
 struct ieee80211_rate *
-ieee80211_get_response_rate(struct ieee80211_supported_band *sband,
+ieee80211_get_response_rate_dup(struct ieee80211_supported_band *sband,
 			    u32 basic_rates, int bitrate)
 {
 	struct ieee80211_rate *result = &sband->bitrates[0];
@@ -34,9 +34,9 @@ ieee80211_get_response_rate(struct ieee8
 
 	return result;
 }
-EXPORT_SYMBOL(ieee80211_get_response_rate);
+EXPORT_SYMBOL(ieee80211_get_response_rate_dup);
 
-u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,
+u32 ieee80211_mandatory_rates_dup(struct ieee80211_supported_band *sband,
 			      enum nl80211_bss_scan_width scan_width)
 {
 	struct ieee80211_rate *bitrates;
@@ -63,9 +63,9 @@ u32 ieee80211_mandatory_rates(struct iee
 			mandatory_rates |= BIT(i);
 	return mandatory_rates;
 }
-EXPORT_SYMBOL(ieee80211_mandatory_rates);
+EXPORT_SYMBOL(ieee80211_mandatory_rates_dup);
 
-int ieee80211_channel_to_frequency(int chan, enum ieee80211_band band)
+int ieee80211_channel_to_frequency_dup(int chan, enum ieee80211_band band)
 {
 	/* see 802.11 17.3.8.3.2 and Annex J
 	 * there are overlapping channel numbers in 5GHz and 2GHz bands */
@@ -93,9 +93,9 @@ int ieee80211_channel_to_frequency(int c
 	}
 	return 0; /* not supported */
 }
-EXPORT_SYMBOL(ieee80211_channel_to_frequency);
+EXPORT_SYMBOL(ieee80211_channel_to_frequency_dup);
 
-int ieee80211_frequency_to_channel(int freq)
+int ieee80211_frequency_to_channel_dup(int freq)
 {
 	/* see 802.11 17.3.8.3.2 and Annex J */
 	if (freq == 2484)
@@ -111,9 +111,9 @@ int ieee80211_frequency_to_channel(int f
 	else
 		return 0;
 }
-EXPORT_SYMBOL(ieee80211_frequency_to_channel);
+EXPORT_SYMBOL(ieee80211_frequency_to_channel_dup);
 
-struct ieee80211_channel *__ieee80211_get_channel(struct wiphy *wiphy,
+struct ieee80211_channel *__ieee80211_get_channel_dup(struct wiphy *wiphy,
 						  int freq)
 {
 	enum ieee80211_band band;
@@ -134,7 +134,7 @@ struct ieee80211_channel *__ieee80211_ge
 
 	return NULL;
 }
-EXPORT_SYMBOL(__ieee80211_get_channel);
+EXPORT_SYMBOL(__ieee80211_get_channel_dup);
 
 static void set_mandatory_flags_band(struct ieee80211_supported_band *sband,
 				     enum ieee80211_band band)
@@ -293,7 +293,7 @@ int cfg80211_validate_key_settings(struc
 	return 0;
 }
 
-unsigned int __attribute_const__ ieee80211_hdrlen(__le16 fc)
+unsigned int __attribute_const__ ieee80211_hdrlen_dup(__le16 fc)
 {
 	unsigned int hdrlen = 24;
 
@@ -332,9 +332,9 @@ unsigned int __attribute_const__ ieee802
 out:
 	return hdrlen;
 }
-EXPORT_SYMBOL(ieee80211_hdrlen);
+EXPORT_SYMBOL(ieee80211_hdrlen_dup);
 
-unsigned int ieee80211_get_hdrlen_from_skb(const struct sk_buff *skb)
+unsigned int ieee80211_get_hdrlen_from_skb_dup(const struct sk_buff *skb)
 {
 	const struct ieee80211_hdr *hdr =
 			(const struct ieee80211_hdr *)skb->data;
@@ -342,14 +342,14 @@ unsigned int ieee80211_get_hdrlen_from_s
 
 	if (unlikely(skb->len < 10))
 		return 0;
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	if (unlikely(hdrlen > skb->len))
 		return 0;
 	return hdrlen;
 }
-EXPORT_SYMBOL(ieee80211_get_hdrlen_from_skb);
+EXPORT_SYMBOL(ieee80211_get_hdrlen_from_skb_dup);
 
-unsigned int ieee80211_get_mesh_hdrlen(struct ieee80211s_hdr *meshhdr)
+unsigned int ieee80211_get_mesh_hdrlen_dup(struct ieee80211s_hdr *meshhdr)
 {
 	int ae = meshhdr->flags & MESH_FLAGS_AE;
 	/* 802.11-2012, 8.2.4.7.3 */
@@ -363,9 +363,9 @@ unsigned int ieee80211_get_mesh_hdrlen(s
 		return 18;
 	}
 }
-EXPORT_SYMBOL(ieee80211_get_mesh_hdrlen);
+EXPORT_SYMBOL(ieee80211_get_mesh_hdrlen_dup);
 
-int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
+int ieee80211_data_to_8023_dup(struct sk_buff *skb, const u8 *addr,
 			   enum nl80211_iftype iftype)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
@@ -377,7 +377,7 @@ int ieee80211_data_to_8023(struct sk_buf
 	if (unlikely(!ieee80211_is_data_present(hdr->frame_control)))
 		return -1;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 
 	/* convert IEEE 802.11 header + possible LLC headers into Ethernet
 	 * header
@@ -421,7 +421,7 @@ int ieee80211_data_to_8023(struct sk_buf
 					offsetof(struct ieee80211s_hdr, eaddr2),
 				        src, ETH_ALEN);
 			}
-			hdrlen += ieee80211_get_mesh_hdrlen(meshdr);
+			hdrlen += ieee80211_get_mesh_hdrlen_dup(meshdr);
 		}
 		break;
 	case cpu_to_le16(IEEE80211_FCTL_FROMDS):
@@ -443,7 +443,7 @@ int ieee80211_data_to_8023(struct sk_buf
 				skb_copy_bits(skb, hdrlen +
 					offsetof(struct ieee80211s_hdr, eaddr1),
 					src, ETH_ALEN);
-			hdrlen += ieee80211_get_mesh_hdrlen(meshdr);
+			hdrlen += ieee80211_get_mesh_hdrlen_dup(meshdr);
 		}
 		break;
 	case cpu_to_le16(0):
@@ -460,9 +460,9 @@ int ieee80211_data_to_8023(struct sk_buf
 	payload = skb->data + hdrlen;
 	ethertype = (payload[6] << 8) | payload[7];
 
-	if (likely((ether_addr_equal(payload, rfc1042_header) &&
+	if (likely((ether_addr_equal(payload, rfc1042_header_dup) &&
 		    ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
-		   ether_addr_equal(payload, bridge_tunnel_header))) {
+		   ether_addr_equal(payload, bridge_tunnel_header_dup))) {
 		/* remove RFC1042 or Bridge-Tunnel encapsulation and
 		 * replace EtherType */
 		skb_pull(skb, hdrlen + 6);
@@ -481,9 +481,9 @@ int ieee80211_data_to_8023(struct sk_buf
 	}
 	return 0;
 }
-EXPORT_SYMBOL(ieee80211_data_to_8023);
+EXPORT_SYMBOL(ieee80211_data_to_8023_dup);
 
-int ieee80211_data_from_8023(struct sk_buff *skb, const u8 *addr,
+int ieee80211_data_from_8023_dup(struct sk_buff *skb, const u8 *addr,
 			     enum nl80211_iftype iftype,
 			     const u8 *bssid, bool qos)
 {
@@ -549,12 +549,12 @@ int ieee80211_data_from_8023(struct sk_b
 
 	skip_header_bytes = ETH_HLEN;
 	if (ethertype == ETH_P_AARP || ethertype == ETH_P_IPX) {
-		encaps_data = bridge_tunnel_header;
-		encaps_len = sizeof(bridge_tunnel_header);
+		encaps_data = bridge_tunnel_header_dup;
+		encaps_len = sizeof(bridge_tunnel_header_dup);
 		skip_header_bytes -= 2;
 	} else if (ethertype >= ETH_P_802_3_MIN) {
-		encaps_data = rfc1042_header;
-		encaps_len = sizeof(rfc1042_header);
+		encaps_data = rfc1042_header_dup;
+		encaps_len = sizeof(rfc1042_header_dup);
 		skip_header_bytes -= 2;
 	} else {
 		encaps_data = NULL;
@@ -598,10 +598,10 @@ int ieee80211_data_from_8023(struct sk_b
 
 	return 0;
 }
-EXPORT_SYMBOL(ieee80211_data_from_8023);
+EXPORT_SYMBOL(ieee80211_data_from_8023_dup);
 
 
-void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
+void ieee80211_amsdu_to_8023s_dup(struct sk_buff *skb, struct sk_buff_head *list,
 			      const u8 *addr, enum nl80211_iftype iftype,
 			      const unsigned int extra_headroom,
 			      bool has_80211_header)
@@ -614,7 +614,7 @@ void ieee80211_amsdu_to_8023s(struct sk_
 	u8 dst[ETH_ALEN], src[ETH_ALEN];
 
 	if (has_80211_header) {
-		err = ieee80211_data_to_8023(skb, addr, iftype);
+		err = ieee80211_data_to_8023_dup(skb, addr, iftype);
 		if (err)
 			goto out;
 
@@ -673,9 +673,9 @@ void ieee80211_amsdu_to_8023s(struct sk_
 		payload = frame->data;
 		ethertype = (payload[6] << 8) | payload[7];
 
-		if (likely((ether_addr_equal(payload, rfc1042_header) &&
+		if (likely((ether_addr_equal(payload, rfc1042_header_dup) &&
 			    ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
-			   ether_addr_equal(payload, bridge_tunnel_header))) {
+			   ether_addr_equal(payload, bridge_tunnel_header_dup))) {
 			/* remove RFC1042 or Bridge-Tunnel
 			 * encapsulation and replace EtherType */
 			skb_pull(frame, 6);
@@ -697,10 +697,10 @@ void ieee80211_amsdu_to_8023s(struct sk_
  out:
 	dev_kfree_skb(skb);
 }
-EXPORT_SYMBOL(ieee80211_amsdu_to_8023s);
+EXPORT_SYMBOL(ieee80211_amsdu_to_8023s_dup);
 
 /* Given a data frame determine the 802.1p/1d tag to use. */
-unsigned int cfg80211_classify8021d(struct sk_buff *skb,
+unsigned int cfg80211_classify8021d_dup(struct sk_buff *skb,
 				    struct cfg80211_qos_map *qos_map)
 {
 	unsigned int dscp;
@@ -764,9 +764,9 @@ unsigned int cfg80211_classify8021d(stru
 
 	return dscp >> 5;
 }
-EXPORT_SYMBOL(cfg80211_classify8021d);
+EXPORT_SYMBOL(cfg80211_classify8021d_dup);
 
-const u8 *ieee80211_bss_get_ie(struct cfg80211_bss *bss, u8 ie)
+const u8 *ieee80211_bss_get_ie_dup(struct cfg80211_bss *bss, u8 ie)
 {
 	const struct cfg80211_bss_ies *ies;
 
@@ -774,9 +774,9 @@ const u8 *ieee80211_bss_get_ie(struct cf
 	if (!ies)
 		return NULL;
 
-	return cfg80211_find_ie(ie, ies->data, ies->len);
+	return cfg80211_find_ie_dup(ie, ies->data, ies->len);
 }
-EXPORT_SYMBOL(ieee80211_bss_get_ie);
+EXPORT_SYMBOL(ieee80211_bss_get_ie_dup);
 
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev)
 {
@@ -827,7 +827,7 @@ void cfg80211_process_wdev_events(struct
 		case EVENT_CONNECT_RESULT:
 			if (!is_zero_ether_addr(ev->cr.bssid))
 				bssid = ev->cr.bssid;
-			__cfg80211_connect_result(
+			__cfg80211_connect_result_dup(
 				wdev->netdev, bssid,
 				ev->cr.req_ie, ev->cr.req_ie_len,
 				ev->cr.resp_ie, ev->cr.resp_ie_len,
@@ -836,17 +836,17 @@ void cfg80211_process_wdev_events(struct
 				NULL);
 			break;
 		case EVENT_ROAMED:
-			__cfg80211_roamed(wdev, ev->rm.bss, ev->rm.req_ie,
+			__cfg80211_roamed_dup(wdev, ev->rm.bss, ev->rm.req_ie,
 					  ev->rm.req_ie_len, ev->rm.resp_ie,
 					  ev->rm.resp_ie_len);
 			break;
 		case EVENT_DISCONNECTED:
-			__cfg80211_disconnected(wdev->netdev,
+			__cfg80211_disconnected_dup(wdev->netdev,
 						ev->dc.ie, ev->dc.ie_len,
 						ev->dc.reason, true);
 			break;
 		case EVENT_IBSS_JOINED:
-			__cfg80211_ibss_joined(wdev->netdev, ev->ij.bssid,
+			__cfg80211_ibss_joined_dup(wdev->netdev, ev->ij.bssid,
 					       ev->ij.channel);
 			break;
 		case EVENT_STOPPED:
@@ -1094,7 +1094,7 @@ static u32 cfg80211_calculate_bitrate_vh
 	return (bitrate + 50000) / 100000;
 }
 
-u32 cfg80211_calculate_bitrate(struct rate_info *rate)
+u32 cfg80211_calculate_bitrate_dup(struct rate_info *rate)
 {
 	int modulation, streams, bitrate;
 
@@ -1131,9 +1131,9 @@ u32 cfg80211_calculate_bitrate(struct ra
 	/* do NOT round down here */
 	return (bitrate + 50000) / 100000;
 }
-EXPORT_SYMBOL(cfg80211_calculate_bitrate);
+EXPORT_SYMBOL(cfg80211_calculate_bitrate_dup);
 
-int cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,
+int cfg80211_get_p2p_attr_dup(const u8 *ies, unsigned int len,
 			  enum ieee80211_p2p_attr_id attr,
 			  u8 *buf, unsigned int bufsize)
 {
@@ -1231,9 +1231,9 @@ int cfg80211_get_p2p_attr(const u8 *ies,
 
 	return -ENOENT;
 }
-EXPORT_SYMBOL(cfg80211_get_p2p_attr);
+EXPORT_SYMBOL(cfg80211_get_p2p_attr_dup);
 
-bool ieee80211_operating_class_to_band(u8 operating_class,
+bool ieee80211_operating_class_to_band_dup(u8 operating_class,
 				       enum ieee80211_band *band)
 {
 	switch (operating_class) {
@@ -1254,7 +1254,7 @@ bool ieee80211_operating_class_to_band(u
 
 	return false;
 }
-EXPORT_SYMBOL(ieee80211_operating_class_to_band);
+EXPORT_SYMBOL(ieee80211_operating_class_to_band_dup);
 
 int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 				 u32 beacon_int)
@@ -1277,7 +1277,7 @@ int cfg80211_validate_beacon_int(struct
 	return res;
 }
 
-int cfg80211_iter_combinations(struct wiphy *wiphy,
+int cfg80211_iter_combinations_dup(struct wiphy *wiphy,
 			       const int num_different_channels,
 			       const u8 radar_detect,
 			       const int iftype_num[NUM_NL80211_IFTYPES],
@@ -1362,7 +1362,7 @@ int cfg80211_iter_combinations(struct wi
 
 	return 0;
 }
-EXPORT_SYMBOL(cfg80211_iter_combinations);
+EXPORT_SYMBOL(cfg80211_iter_combinations_dup);
 
 static void
 cfg80211_iter_sum_ifcombs(const struct ieee80211_iface_combination *c,
@@ -1372,14 +1372,14 @@ cfg80211_iter_sum_ifcombs(const struct i
 	(*num)++;
 }
 
-int cfg80211_check_combinations(struct wiphy *wiphy,
+int cfg80211_check_combinations_dup(struct wiphy *wiphy,
 				const int num_different_channels,
 				const u8 radar_detect,
 				const int iftype_num[NUM_NL80211_IFTYPES])
 {
 	int err, num = 0;
 
-	err = cfg80211_iter_combinations(wiphy, num_different_channels,
+	err = cfg80211_iter_combinations_dup(wiphy, num_different_channels,
 					 radar_detect, iftype_num,
 					 cfg80211_iter_sum_ifcombs, &num);
 	if (err)
@@ -1389,7 +1389,7 @@ int cfg80211_check_combinations(struct w
 
 	return 0;
 }
-EXPORT_SYMBOL(cfg80211_check_combinations);
+EXPORT_SYMBOL(cfg80211_check_combinations_dup);
 
 int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
 				 struct wireless_dev *wdev,
@@ -1501,7 +1501,7 @@ int cfg80211_can_use_iftype_chan(struct
 	if (total == 1 && !radar_detect)
 		return 0;
 
-	return cfg80211_check_combinations(&rdev->wiphy, num_different_channels,
+	return cfg80211_check_combinations_dup(&rdev->wiphy, num_different_channels,
 					   radar_detect, num);
 }
 
@@ -1543,7 +1543,7 @@ int ieee80211_get_ratemask(struct ieee80
 	return 0;
 }
 
-unsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy)
+unsigned int ieee80211_get_num_supported_channels_dup(struct wiphy *wiphy)
 {
 	enum ieee80211_band band;
 	unsigned int n_channels = 0;
@@ -1554,9 +1554,9 @@ unsigned int ieee80211_get_num_supported
 
 	return n_channels;
 }
-EXPORT_SYMBOL(ieee80211_get_num_supported_channels);
+EXPORT_SYMBOL(ieee80211_get_num_supported_channels_dup);
 
-int cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,
+int cfg80211_get_station_dup(struct net_device *dev, const u8 *mac_addr,
 			 struct station_info *sinfo)
 {
 	struct cfg80211_registered_device *rdev;
@@ -1572,15 +1572,15 @@ int cfg80211_get_station(struct net_devi
 
 	return rdev_get_station(rdev, dev, mac_addr, sinfo);
 }
-EXPORT_SYMBOL(cfg80211_get_station);
+EXPORT_SYMBOL(cfg80211_get_station_dup);
 
 /* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation */
 /* Ethernet-II snap header (RFC1042 for most EtherTypes) */
-const unsigned char rfc1042_header[] __aligned(2) =
+const unsigned char rfc1042_header_dup[] __aligned(2) =
 	{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
-EXPORT_SYMBOL(rfc1042_header);
+EXPORT_SYMBOL(rfc1042_header_dup);
 
 /* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
-const unsigned char bridge_tunnel_header[] __aligned(2) =
+const unsigned char bridge_tunnel_header_dup[] __aligned(2) =
 	{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
-EXPORT_SYMBOL(bridge_tunnel_header);
+EXPORT_SYMBOL(bridge_tunnel_header_dup);
--- a/net/wireless/wext-compat.c	2015-06-23 11:07:42.887851395 +0200
+++ b/net/wireless/wext-compat.c	2015-06-23 14:54:18.348862160 +0200
@@ -21,7 +21,7 @@
 #include "core.h"
 #include "rdev-ops.h"
 
-int cfg80211_wext_giwname(struct net_device *dev,
+int cfg80211_wext_giwname_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  char *name, char *extra)
 {
@@ -63,9 +63,9 @@ int cfg80211_wext_giwname(struct net_dev
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_giwname);
+EXPORT_SYMBOL_GPL(cfg80211_wext_giwname_dup);
 
-int cfg80211_wext_siwmode(struct net_device *dev, struct iw_request_info *info,
+int cfg80211_wext_siwmode_dup(struct net_device *dev, struct iw_request_info *info,
 			  u32 *mode, char *extra)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -99,9 +99,9 @@ int cfg80211_wext_siwmode(struct net_dev
 
 	return cfg80211_change_iface(rdev, dev, type, NULL, &vifparams);
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_siwmode);
+EXPORT_SYMBOL_GPL(cfg80211_wext_siwmode_dup);
 
-int cfg80211_wext_giwmode(struct net_device *dev, struct iw_request_info *info,
+int cfg80211_wext_giwmode_dup(struct net_device *dev, struct iw_request_info *info,
 			  u32 *mode, char *extra)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -134,10 +134,10 @@ int cfg80211_wext_giwmode(struct net_dev
 	}
 	return 0;
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_giwmode);
+EXPORT_SYMBOL_GPL(cfg80211_wext_giwmode_dup);
 
 
-int cfg80211_wext_giwrange(struct net_device *dev,
+int cfg80211_wext_giwrange_dup(struct net_device *dev,
 			   struct iw_request_info *info,
 			   struct iw_point *data, char *extra)
 {
@@ -228,7 +228,7 @@ int cfg80211_wext_giwrange(struct net_de
 
 			if (!(chan->flags & IEEE80211_CHAN_DISABLED)) {
 				range->freq[c].i =
-					ieee80211_frequency_to_channel(
+					ieee80211_frequency_to_channel_dup(
 						chan->center_freq);
 				range->freq[c].m = chan->center_freq;
 				range->freq[c].e = 6;
@@ -248,7 +248,7 @@ int cfg80211_wext_giwrange(struct net_de
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_giwrange);
+EXPORT_SYMBOL_GPL(cfg80211_wext_giwrange_dup);
 
 
 /**
@@ -270,7 +270,7 @@ int cfg80211_wext_freq(struct iw_freq *f
 			return 0;
 		if (freq->m > 14)
 			band = IEEE80211_BAND_5GHZ;
-		return ieee80211_channel_to_frequency(freq->m, band);
+		return ieee80211_channel_to_frequency_dup(freq->m, band);
 	} else {
 		int i, div = 1000000;
 		for (i = 0; i < freq->e; i++)
@@ -281,7 +281,7 @@ int cfg80211_wext_freq(struct iw_freq *f
 	}
 }
 
-int cfg80211_wext_siwrts(struct net_device *dev,
+int cfg80211_wext_siwrts_dup(struct net_device *dev,
 			 struct iw_request_info *info,
 			 struct iw_param *rts, char *extra)
 {
@@ -303,9 +303,9 @@ int cfg80211_wext_siwrts(struct net_devi
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_siwrts);
+EXPORT_SYMBOL_GPL(cfg80211_wext_siwrts_dup);
 
-int cfg80211_wext_giwrts(struct net_device *dev,
+int cfg80211_wext_giwrts_dup(struct net_device *dev,
 			 struct iw_request_info *info,
 			 struct iw_param *rts, char *extra)
 {
@@ -317,9 +317,9 @@ int cfg80211_wext_giwrts(struct net_devi
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_giwrts);
+EXPORT_SYMBOL_GPL(cfg80211_wext_giwrts_dup);
 
-int cfg80211_wext_siwfrag(struct net_device *dev,
+int cfg80211_wext_siwfrag_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_param *frag, char *extra)
 {
@@ -343,9 +343,9 @@ int cfg80211_wext_siwfrag(struct net_dev
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_siwfrag);
+EXPORT_SYMBOL_GPL(cfg80211_wext_siwfrag_dup);
 
-int cfg80211_wext_giwfrag(struct net_device *dev,
+int cfg80211_wext_giwfrag_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_param *frag, char *extra)
 {
@@ -357,7 +357,7 @@ int cfg80211_wext_giwfrag(struct net_dev
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_giwfrag);
+EXPORT_SYMBOL_GPL(cfg80211_wext_giwfrag_dup);
 
 static int cfg80211_wext_siwretry(struct net_device *dev,
 				  struct iw_request_info *info,
@@ -399,7 +399,7 @@ static int cfg80211_wext_siwretry(struct
 	return err;
 }
 
-int cfg80211_wext_giwretry(struct net_device *dev,
+int cfg80211_wext_giwretry_dup(struct net_device *dev,
 			   struct iw_request_info *info,
 			   struct iw_param *retry, char *extra)
 {
@@ -427,7 +427,7 @@ int cfg80211_wext_giwretry(struct net_de
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(cfg80211_wext_giwretry);
+EXPORT_SYMBOL_GPL(cfg80211_wext_giwretry_dup);
 
 static int __cfg80211_set_encryption(struct cfg80211_registered_device *rdev,
 				     struct net_device *dev, bool pairwise,
@@ -1303,7 +1303,7 @@ static int cfg80211_wext_giwrate(struct
 	if (!(sinfo.filled & STATION_INFO_TX_BITRATE))
 		return -EOPNOTSUPP;
 
-	rate->value = 100000 * cfg80211_calculate_bitrate(&sinfo.txrate);
+	rate->value = 100000 * cfg80211_calculate_bitrate_dup(&sinfo.txrate);
 
 	return 0;
 }
@@ -1488,29 +1488,29 @@ static int cfg80211_wext_siwpmksa(struct
 }
 
 static const iw_handler cfg80211_handlers[] = {
-	[IW_IOCTL_IDX(SIOCGIWNAME)]	= (iw_handler) cfg80211_wext_giwname,
+	[IW_IOCTL_IDX(SIOCGIWNAME)]	= (iw_handler) cfg80211_wext_giwname_dup,
 	[IW_IOCTL_IDX(SIOCSIWFREQ)]	= (iw_handler) cfg80211_wext_siwfreq,
 	[IW_IOCTL_IDX(SIOCGIWFREQ)]	= (iw_handler) cfg80211_wext_giwfreq,
-	[IW_IOCTL_IDX(SIOCSIWMODE)]	= (iw_handler) cfg80211_wext_siwmode,
-	[IW_IOCTL_IDX(SIOCGIWMODE)]	= (iw_handler) cfg80211_wext_giwmode,
-	[IW_IOCTL_IDX(SIOCGIWRANGE)]	= (iw_handler) cfg80211_wext_giwrange,
+	[IW_IOCTL_IDX(SIOCSIWMODE)]	= (iw_handler) cfg80211_wext_siwmode_dup,
+	[IW_IOCTL_IDX(SIOCGIWMODE)]	= (iw_handler) cfg80211_wext_giwmode_dup,
+	[IW_IOCTL_IDX(SIOCGIWRANGE)]	= (iw_handler) cfg80211_wext_giwrange_dup,
 	[IW_IOCTL_IDX(SIOCSIWAP)]	= (iw_handler) cfg80211_wext_siwap,
 	[IW_IOCTL_IDX(SIOCGIWAP)]	= (iw_handler) cfg80211_wext_giwap,
 	[IW_IOCTL_IDX(SIOCSIWMLME)]	= (iw_handler) cfg80211_wext_siwmlme,
-	[IW_IOCTL_IDX(SIOCSIWSCAN)]	= (iw_handler) cfg80211_wext_siwscan,
-	[IW_IOCTL_IDX(SIOCGIWSCAN)]	= (iw_handler) cfg80211_wext_giwscan,
+	[IW_IOCTL_IDX(SIOCSIWSCAN)]	= (iw_handler) cfg80211_wext_siwscan_dup,
+	[IW_IOCTL_IDX(SIOCGIWSCAN)]	= (iw_handler) cfg80211_wext_giwscan_dup,
 	[IW_IOCTL_IDX(SIOCSIWESSID)]	= (iw_handler) cfg80211_wext_siwessid,
 	[IW_IOCTL_IDX(SIOCGIWESSID)]	= (iw_handler) cfg80211_wext_giwessid,
 	[IW_IOCTL_IDX(SIOCSIWRATE)]	= (iw_handler) cfg80211_wext_siwrate,
 	[IW_IOCTL_IDX(SIOCGIWRATE)]	= (iw_handler) cfg80211_wext_giwrate,
-	[IW_IOCTL_IDX(SIOCSIWRTS)]	= (iw_handler) cfg80211_wext_siwrts,
-	[IW_IOCTL_IDX(SIOCGIWRTS)]	= (iw_handler) cfg80211_wext_giwrts,
-	[IW_IOCTL_IDX(SIOCSIWFRAG)]	= (iw_handler) cfg80211_wext_siwfrag,
-	[IW_IOCTL_IDX(SIOCGIWFRAG)]	= (iw_handler) cfg80211_wext_giwfrag,
+	[IW_IOCTL_IDX(SIOCSIWRTS)]	= (iw_handler) cfg80211_wext_siwrts_dup,
+	[IW_IOCTL_IDX(SIOCGIWRTS)]	= (iw_handler) cfg80211_wext_giwrts_dup,
+	[IW_IOCTL_IDX(SIOCSIWFRAG)]	= (iw_handler) cfg80211_wext_siwfrag_dup,
+	[IW_IOCTL_IDX(SIOCGIWFRAG)]	= (iw_handler) cfg80211_wext_giwfrag_dup,
 	[IW_IOCTL_IDX(SIOCSIWTXPOW)]	= (iw_handler) cfg80211_wext_siwtxpower,
 	[IW_IOCTL_IDX(SIOCGIWTXPOW)]	= (iw_handler) cfg80211_wext_giwtxpower,
 	[IW_IOCTL_IDX(SIOCSIWRETRY)]	= (iw_handler) cfg80211_wext_siwretry,
-	[IW_IOCTL_IDX(SIOCGIWRETRY)]	= (iw_handler) cfg80211_wext_giwretry,
+	[IW_IOCTL_IDX(SIOCGIWRETRY)]	= (iw_handler) cfg80211_wext_giwretry_dup,
 	[IW_IOCTL_IDX(SIOCSIWENCODE)]	= (iw_handler) cfg80211_wext_siwencode,
 	[IW_IOCTL_IDX(SIOCGIWENCODE)]	= (iw_handler) cfg80211_wext_giwencode,
 	[IW_IOCTL_IDX(SIOCSIWPOWER)]	= (iw_handler) cfg80211_wext_siwpower,
--- a/net/wireless/wext-core.c	2015-06-24 12:23:07.800271402 +0200
+++ b/net/wireless/wext-core.c	2015-06-24 12:23:16.512379504 +0200
@@ -20,6 +20,12 @@
 #include <net/wext.h>
 #include <net/net_namespace.h>
 
+#define DRV_NAME        "wext-core"
+#define DRV_DESCRIPTION	"wext"
+
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_LICENSE("GPL");
+
 typedef int (*wext_ioctl_func)(struct net_device *, struct iwreq *,
 			       unsigned int, struct iw_request_info *,
 			       iw_handler);
@@ -417,7 +423,7 @@ static struct nlmsghdr *rtnetlink_ifinfo
  * Send the event on the appropriate channels.
  * May be called from interrupt context.
  */
-void wireless_send_event(struct net_device *	dev,
+void wireless_send_event_dup(struct net_device *	dev,
 			 unsigned int		cmd,
 			 union iwreq_data *	wrqu,
 			 const char *		extra)
@@ -600,7 +606,7 @@ void wireless_send_event(struct net_devi
 	skb_queue_tail(&dev_net(dev)->wext_nlevents, skb);
 	schedule_work(&wireless_nlevent_work);
 }
-EXPORT_SYMBOL(wireless_send_event);
+EXPORT_SYMBOL(wireless_send_event_dup);
 
 
 
@@ -833,9 +839,9 @@ static int ioctl_standard_iw_point(struc
 			/* If the event is restricted, don't
 			 * export the payload.
 			 */
-			wireless_send_event(dev, cmd, data, NULL);
+			wireless_send_event_dup(dev, cmd, data, NULL);
 		else
-			wireless_send_event(dev, cmd, data, extra);
+			wireless_send_event_dup(dev, cmd, data, extra);
 	}
 
 out:
@@ -990,7 +996,7 @@ static int ioctl_standard_call(struct ne
 		/* Generate an event to notify listeners of the change */
 		if ((descr->flags & IW_DESCR_FLAG_EVENT) &&
 		   ((ret == 0) || (ret == -EIWCOMMIT)))
-			wireless_send_event(dev, cmd, &(iwr->u), NULL);
+			wireless_send_event_dup(dev, cmd, &(iwr->u), NULL);
 	} else {
 		ret = ioctl_standard_iw_point(&iwr->u.data, cmd, descr,
 					      handler, dev, info);
--- a/net/wireless/wext-sme.c	2015-06-23 11:07:42.887851395 +0200
+++ b/net/wireless/wext-sme.c	2015-06-23 14:54:18.445862596 +0200
@@ -237,7 +237,7 @@ int cfg80211_mgd_wext_giwessid(struct ne
 		const u8 *ie;
 
 		rcu_read_lock();
-		ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,
+		ie = ieee80211_bss_get_ie_dup(&wdev->current_bss->pub,
 					  WLAN_EID_SSID);
 		if (ie) {
 			data->flags = 1;
--- a/net/wireless/wext-spy.c	2015-06-23 11:07:42.887851395 +0200
+++ b/net/wireless/wext-spy.c	2015-06-23 14:54:18.497862830 +0200
@@ -23,7 +23,7 @@ static inline struct iw_spy_data *get_sp
 	return NULL;
 }
 
-int iw_handler_set_spy(struct net_device *	dev,
+int iw_handler_set_spy_dup(struct net_device *	dev,
 		       struct iw_request_info *	info,
 		       union iwreq_data *	wrqu,
 		       char *			extra)
@@ -36,15 +36,15 @@ int iw_handler_set_spy(struct net_device
 		return -EOPNOTSUPP;
 
 	/* Disable spy collection while we copy the addresses.
-	 * While we copy addresses, any call to wireless_spy_update()
+	 * While we copy addresses, any call to wireless_spy_update_dup()
 	 * will NOP. This is OK, as anyway the addresses are changing. */
 	spydata->spy_number = 0;
 
-	/* We want to operate without locking, because wireless_spy_update()
+	/* We want to operate without locking, because wireless_spy_update_dup()
 	 * most likely will happen in the interrupt handler, and therefore
 	 * have its own locking constraints and needs performance.
 	 * The rtnl_lock() make sure we don't race with the other iw_handlers.
-	 * This make sure wireless_spy_update() "see" that the spy list
+	 * This make sure wireless_spy_update_dup() "see" that the spy list
 	 * is temporarily disabled. */
 	smp_wmb();
 
@@ -69,9 +69,9 @@ int iw_handler_set_spy(struct net_device
 
 	return 0;
 }
-EXPORT_SYMBOL(iw_handler_set_spy);
+EXPORT_SYMBOL(iw_handler_set_spy_dup);
 
-int iw_handler_get_spy(struct net_device *	dev,
+int iw_handler_get_spy_dup(struct net_device *	dev,
 		       struct iw_request_info *	info,
 		       union iwreq_data *	wrqu,
 		       char *			extra)
@@ -101,13 +101,13 @@ int iw_handler_get_spy(struct net_device
 		spydata->spy_stat[i].updated &= ~IW_QUAL_ALL_UPDATED;
 	return 0;
 }
-EXPORT_SYMBOL(iw_handler_get_spy);
+EXPORT_SYMBOL(iw_handler_get_spy_dup);
 
 /*------------------------------------------------------------------*/
 /*
  * Standard Wireless Handler : set spy threshold
  */
-int iw_handler_set_thrspy(struct net_device *	dev,
+int iw_handler_set_thrspy_dup(struct net_device *	dev,
 			  struct iw_request_info *info,
 			  union iwreq_data *	wrqu,
 			  char *		extra)
@@ -128,13 +128,13 @@ int iw_handler_set_thrspy(struct net_dev
 
 	return 0;
 }
-EXPORT_SYMBOL(iw_handler_set_thrspy);
+EXPORT_SYMBOL(iw_handler_set_thrspy_dup);
 
 /*------------------------------------------------------------------*/
 /*
  * Standard Wireless Handler : get spy threshold
  */
-int iw_handler_get_thrspy(struct net_device *	dev,
+int iw_handler_get_thrspy_dup(struct net_device *	dev,
 			  struct iw_request_info *info,
 			  union iwreq_data *	wrqu,
 			  char *		extra)
@@ -152,7 +152,7 @@ int iw_handler_get_thrspy(struct net_dev
 
 	return 0;
 }
-EXPORT_SYMBOL(iw_handler_get_thrspy);
+EXPORT_SYMBOL(iw_handler_get_thrspy_dup);
 
 /*------------------------------------------------------------------*/
 /*
@@ -179,7 +179,7 @@ static void iw_send_thrspy_event(struct
 	       2 * sizeof(struct iw_quality));
 
 	/* Send event to user space */
-	wireless_send_event(dev, SIOCGIWTHRSPY, &wrqu, (char *) &threshold);
+	wireless_send_event_dup(dev, SIOCGIWTHRSPY, &wrqu, (char *) &threshold);
 }
 
 /* ---------------------------------------------------------------- */
@@ -189,7 +189,7 @@ static void iw_send_thrspy_event(struct
  * small, this is good enough. If we wanted to support larger number of
  * spy addresses, we should use something more efficient...
  */
-void wireless_spy_update(struct net_device *	dev,
+void wireless_spy_update_dup(struct net_device *	dev,
 			 unsigned char *	address,
 			 struct iw_quality *	wstats)
 {
@@ -229,4 +229,4 @@ void wireless_spy_update(struct net_devi
 		}
 	}
 }
-EXPORT_SYMBOL(wireless_spy_update);
+EXPORT_SYMBOL(wireless_spy_update_dup);
--- a/net/wireless/ethtool.c
+++ b/net/wireless/ethtool.c
@@ -3,7 +3,7 @@
 #include "core.h"
 #include "rdev-ops.h"
 
-void cfg80211_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+void cfg80211_get_drvinfo_dup(struct net_device *dev, struct ethtool_drvinfo *info)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
 
@@ -21,4 +21,4 @@ void cfg80211_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
 	strlcpy(info->bus_info, dev_name(wiphy_dev(wdev->wiphy)),
 		sizeof(info->bus_info));
 }
-EXPORT_SYMBOL(cfg80211_get_drvinfo);
+EXPORT_SYMBOL(cfg80211_get_drvinfo_dup);
--- a/include/linux/nl80211.h	2015-06-23 11:07:42.625848362 +0200
+++ b/include/linux/nl80211.h	2015-06-23 16:42:01.688814709 +0200
@@ -4382,7 +4382,7 @@ enum nl80211_crit_proto_id {
 /**
  * enum nl80211_rxmgmt_flags - flags for received management frame.
  *
- * Used by cfg80211_rx_mgmt()
+ * Used by cfg80211_rx_mgmt_dup()
  *
  * @NL80211_RXMGMT_FLAG_ANSWERED: frame was answered by device/driver.
  */
--- a/include/net/cfg80211-wext.h	2015-06-23 11:07:42.664848813 +0200
+++ b/include/net/cfg80211-wext.h	2015-06-23 16:42:01.806816115 +0200
@@ -20,35 +20,35 @@
  * These are used only by drivers that aren't yet fully
  * converted to cfg80211.
  */
-int cfg80211_wext_giwname(struct net_device *dev,
+int cfg80211_wext_giwname_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  char *name, char *extra);
-int cfg80211_wext_siwmode(struct net_device *dev, struct iw_request_info *info,
+int cfg80211_wext_siwmode_dup(struct net_device *dev, struct iw_request_info *info,
 			  u32 *mode, char *extra);
-int cfg80211_wext_giwmode(struct net_device *dev, struct iw_request_info *info,
+int cfg80211_wext_giwmode_dup(struct net_device *dev, struct iw_request_info *info,
 			  u32 *mode, char *extra);
-int cfg80211_wext_siwscan(struct net_device *dev,
+int cfg80211_wext_siwscan_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  union iwreq_data *wrqu, char *extra);
-int cfg80211_wext_giwscan(struct net_device *dev,
+int cfg80211_wext_giwscan_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_point *data, char *extra);
-int cfg80211_wext_giwrange(struct net_device *dev,
+int cfg80211_wext_giwrange_dup(struct net_device *dev,
 			   struct iw_request_info *info,
 			   struct iw_point *data, char *extra);
-int cfg80211_wext_siwrts(struct net_device *dev,
+int cfg80211_wext_siwrts_dup(struct net_device *dev,
 			 struct iw_request_info *info,
 			 struct iw_param *rts, char *extra);
-int cfg80211_wext_giwrts(struct net_device *dev,
+int cfg80211_wext_giwrts_dup(struct net_device *dev,
 			 struct iw_request_info *info,
 			 struct iw_param *rts, char *extra);
-int cfg80211_wext_siwfrag(struct net_device *dev,
+int cfg80211_wext_siwfrag_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_param *frag, char *extra);
-int cfg80211_wext_giwfrag(struct net_device *dev,
+int cfg80211_wext_giwfrag_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_param *frag, char *extra);
-int cfg80211_wext_giwretry(struct net_device *dev,
+int cfg80211_wext_giwretry_dup(struct net_device *dev,
 			   struct iw_request_info *info,
 			   struct iw_param *retry, char *extra);
 
--- a/include/net/cfg80211.h	2015-06-23 11:07:42.665848825 +0200
+++ b/include/net/cfg80211.h	2015-06-23 16:42:01.843816555 +0200
@@ -393,14 +393,14 @@ cfg80211_get_chandef_type(const struct c
 }
 
 /**
- * cfg80211_chandef_create - create channel definition using channel type
+ * cfg80211_chandef_create_dup - create channel definition using channel type
  * @chandef: the channel definition struct to fill
  * @channel: the control channel
  * @chantype: the channel type
  *
  * Given a channel type, create a channel definition.
  */
-void cfg80211_chandef_create(struct cfg80211_chan_def *chandef,
+void cfg80211_chandef_create_dup(struct cfg80211_chan_def *chandef,
 			     struct ieee80211_channel *channel,
 			     enum nl80211_channel_type chantype);
 
@@ -423,7 +423,7 @@ cfg80211_chandef_identical(const struct
 }
 
 /**
- * cfg80211_chandef_compatible - check if two channel definitions are compatible
+ * cfg80211_chandef_compatible_dup - check if two channel definitions are compatible
  * @chandef1: first channel definition
  * @chandef2: second channel definition
  *
@@ -431,36 +431,36 @@ cfg80211_chandef_identical(const struct
  * chandef1 or chandef2 otherwise.
  */
 const struct cfg80211_chan_def *
-cfg80211_chandef_compatible(const struct cfg80211_chan_def *chandef1,
+cfg80211_chandef_compatible_dup(const struct cfg80211_chan_def *chandef1,
 			    const struct cfg80211_chan_def *chandef2);
 
 /**
- * cfg80211_chandef_valid - check if a channel definition is valid
+ * cfg80211_chandef_valid_dup - check if a channel definition is valid
  * @chandef: the channel definition to check
  * Return: %true if the channel definition is valid. %false otherwise.
  */
-bool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef);
+bool cfg80211_chandef_valid_dup(const struct cfg80211_chan_def *chandef);
 
 /**
- * cfg80211_chandef_usable - check if secondary channels can be used
+ * cfg80211_chandef_usable_dup - check if secondary channels can be used
  * @wiphy: the wiphy to validate against
  * @chandef: the channel definition to check
  * @prohibited_flags: the regulatory channel flags that must not be set
  * Return: %true if secondary channels are usable. %false otherwise.
  */
-bool cfg80211_chandef_usable(struct wiphy *wiphy,
+bool cfg80211_chandef_usable_dup(struct wiphy *wiphy,
 			     const struct cfg80211_chan_def *chandef,
 			     u32 prohibited_flags);
 
 /**
- * cfg80211_chandef_dfs_required - checks if radar detection is required
+ * cfg80211_chandef_dfs_required_dup - checks if radar detection is required
  * @wiphy: the wiphy to validate against
  * @chandef: the channel definition to check
  * @iftype: the interface type as specified in &enum nl80211_iftype
  * Returns:
  *	1 if radar detection is required, 0 if it is not, < 0 on error
  */
-int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
+int cfg80211_chandef_dfs_required_dup(struct wiphy *wiphy,
 				  const struct cfg80211_chan_def *chandef,
 				  enum nl80211_iftype iftype);
 
@@ -849,7 +849,7 @@ enum cfg80211_station_type {
 };
 
 /**
- * cfg80211_check_station_change - validate parameter changes
+ * cfg80211_check_station_change_dup - validate parameter changes
  * @wiphy: the wiphy this operates on
  * @params: the new parameters for a station
  * @statype: the type of station being modified
@@ -860,7 +860,7 @@ enum cfg80211_station_type {
  * not will return an error code. Note that it may modify the parameters for
  * backward compatibility reasons, so don't use them before calling this.
  */
-int cfg80211_check_station_change(struct wiphy *wiphy,
+int cfg80211_check_station_change_dup(struct wiphy *wiphy,
 				  struct station_parameters *params,
 				  enum cfg80211_station_type statype);
 
@@ -1046,7 +1046,7 @@ struct sta_bss_parameters {
  * @assoc_req_ies: IEs from (Re)Association Request.
  *	This is used only when in AP mode with drivers that do not use
  *	user space MLME/SME implementation. The information is provided for
- *	the cfg80211_new_sta() calls to notify user space of the IEs.
+ *	the cfg80211_new_sta_dup() calls to notify user space of the IEs.
  * @assoc_req_ies_len: Length of assoc_req_ies buffer in octets.
  * @sta_flags: station flags mask & values
  * @beacon_loss_count: Number of times beacon loss event has triggered.
@@ -1108,7 +1108,7 @@ struct station_info {
 };
 
 /**
- * cfg80211_get_station - retrieve information about a given station
+ * cfg80211_get_station_dup - retrieve information about a given station
  * @dev: the device where the station is supposed to be connected to
  * @mac_addr: the mac address of the station of interest
  * @sinfo: pointer to the structure to fill with the information
@@ -1117,7 +1117,7 @@ struct station_info {
  * otherwise returns a negative error code and the content of sinfo has to be
  * considered undefined.
  */
-int cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,
+int cfg80211_get_station_dup(struct net_device *dev, const u8 *mac_addr,
 			 struct station_info *sinfo);
 
 /**
@@ -1630,7 +1630,7 @@ struct cfg80211_bss {
 };
 
 /**
- * ieee80211_bss_get_ie - find IE with given ID
+ * ieee80211_bss_get_ie_dup - find IE with given ID
  * @bss: the bss to search
  * @ie: the IE ID
  *
@@ -1638,7 +1638,7 @@ struct cfg80211_bss {
  * rcu_read_lock() must be held when calling this function.
  * Return: %NULL if not found.
  */
-const u8 *ieee80211_bss_get_ie(struct cfg80211_bss *bss, u8 ie);
+const u8 *ieee80211_bss_get_ie_dup(struct cfg80211_bss *bss, u8 ie);
 
 
 /**
@@ -1690,7 +1690,7 @@ enum cfg80211_assoc_req_flags {
  * (re)association.
  * @bss: The BSS to associate with. If the call is successful the driver is
  *	given a reference that it must give back to cfg80211_send_rx_assoc()
- *	or to cfg80211_assoc_timeout(). To ensure proper refcounting, new
+ *	or to cfg80211_assoc_timeout_dup(). To ensure proper refcounting, new
  *	association requests while already associating must be rejected.
  * @ie: Extra IEs to add to (Re)Association Request frame or %NULL
  * @ie_len: Length of ie buffer in octets
@@ -2235,7 +2235,7 @@ struct cfg80211_qos_map {
  *	validated in cfg80211, in particular the auth/assoc/authorized flags
  *	might come to the driver in invalid combinations -- make sure to check
  *	them, also against the existing state! Drivers must call
- *	cfg80211_check_station_change() to validate the information.
+ *	cfg80211_check_station_change_dup() to validate the information.
  * @get_station: get station information for the station identified by @mac
  * @dump_station: dump station callback -- resume dump at index @idx
  *
@@ -2271,7 +2271,7 @@ struct cfg80211_qos_map {
  *	be stored for when a monitor interface becomes active.
  *
  * @scan: Request to do a scan. If returning zero, the scan request is given
- *	the driver, and will be valid until passed to cfg80211_scan_done().
+ *	the driver, and will be valid until passed to cfg80211_scan_done_dup().
  *	For scan results, call cfg80211_inform_bss(); you can call this outside
  *	the scan/scan_done bracket too.
  *
@@ -2285,15 +2285,15 @@ struct cfg80211_qos_map {
  *	(invoked with the wireless_dev mutex held)
  *
  * @connect: Connect to the ESS with the specified parameters. When connected,
- *	call cfg80211_connect_result() with status code %WLAN_STATUS_SUCCESS.
- *	If the connection fails for some reason, call cfg80211_connect_result()
+ *	call cfg80211_connect_result_dup() with status code %WLAN_STATUS_SUCCESS.
+ *	If the connection fails for some reason, call cfg80211_connect_result_dup()
  *	with the status from the AP.
  *	(invoked with the wireless_dev mutex held)
  * @disconnect: Disconnect from the BSS/ESS.
  *	(invoked with the wireless_dev mutex held)
  *
  * @join_ibss: Join the specified IBSS (or create if necessary). Once done, call
- *	cfg80211_ibss_joined(), also call that function when changing BSSID due
+ *	cfg80211_ibss_joined_dup(), also call that function when changing BSSID due
  *	to a merge.
  *	(invoked with the wireless_dev mutex held)
  * @leave_ibss: Leave the IBSS.
@@ -2326,7 +2326,7 @@ struct cfg80211_qos_map {
  *	channel for the specified duration to complete an off-channel
  *	operation (e.g., public action frame exchange). When the driver is
  *	ready on the requested channel, it must indicate this with an event
- *	notification by calling cfg80211_ready_on_channel().
+ *	notification by calling cfg80211_ready_on_channel_dup().
  * @cancel_remain_on_channel: Cancel an on-going remain-on-channel operation.
  *	This allows the operation to be terminated prior to timeout based on
  *	the duration value.
@@ -2359,7 +2359,7 @@ struct cfg80211_qos_map {
  *	call must stop the scheduled scan and be ready for starting a new one
  *	before it returns, i.e. @sched_scan_start may be called immediately
  *	after that again and should not fail in that case. The driver should
- *	not call cfg80211_sched_scan_stopped() for a requested stop (when this
+ *	not call cfg80211_sched_scan_stopped_dup() for a requested stop (when this
  *	method returns 0.)
  *
  * @mgmt_frame_register: Notify driver that a management frame type was
@@ -2377,7 +2377,7 @@ struct cfg80211_qos_map {
  * @tdls_oper: Perform a high-level TDLS operation (e.g. TDLS link setup).
  *
  * @probe_client: probe an associated client, must return a cookie that it
- *	later passes to cfg80211_probe_status().
+ *	later passes to cfg80211_probe_status_dup().
  *
  * @set_noack_map: Set the NoAck Map for the TIDs.
  *
@@ -2411,7 +2411,7 @@ struct cfg80211_qos_map {
  * @channel_switch: initiate channel-switch procedure (with CSA). Driver is
  *	responsible for veryfing if the switch is possible. Since this is
  *	inherently tricky driver may decide to disconnect an interface later
- *	with cfg80211_stop_iface(). This doesn't mean driver can accept
+ *	with cfg80211_stop_iface_dup(). This doesn't mean driver can accept
  *	everything. It should do it's best to verify requests and reject them
  *	as soon as possible.
  *
@@ -2743,7 +2743,7 @@ struct cfg80211_ops {
  * @WIPHY_FLAG_HAVE_AP_SME: device integrates AP SME
  * @WIPHY_FLAG_REPORTS_OBSS: the device will report beacons from other BSSes
  *	when there are virtual interfaces in AP mode by calling
- *	cfg80211_report_obss_beacon().
+ *	cfg80211_report_obss_beacon_dup().
  * @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD: When operating as an AP, the device
  *	responds to probe-requests in hardware.
  * @WIPHY_FLAG_OFFCHAN_TX: Device supports direct off-channel TX.
@@ -2976,10 +2976,10 @@ struct wiphy_vendor_command {
 /**
  * struct wiphy - wireless hardware description
  * @reg_notifier: the driver's regulatory notification callback,
- *	note that if your driver uses wiphy_apply_custom_regulatory()
+ *	note that if your driver uses wiphy_apply_custom_regulatory_dup()
  *	the reg_notifier's request can be passed as NULL
  * @regd: the driver's regulatory domain, if one was requested via
- * 	the regulatory_hint() API. This can be used by the driver
+ * 	the regulatory_hint_dup() API. This can be used by the driver
  *	on the reg_notifier() if it chooses to ignore future
  *	regulatory domain changes caused by other drivers.
  * @signal_type: signal type reported in &struct cfg80211_bss.
@@ -3298,7 +3298,7 @@ static inline const char *wiphy_name(con
 }
 
 /**
- * wiphy_new_nm - create a new wiphy for use with cfg80211
+ * wiphy_new_nm_dup - create a new wiphy for use with cfg80211
  *
  * @ops: The configuration operations for this device
  * @sizeof_priv: The size of the private area to allocate
@@ -3311,7 +3311,7 @@ static inline const char *wiphy_name(con
  * Return: A pointer to the new wiphy. This pointer must be
  * assigned to each netdev's ieee80211_ptr for proper operation.
  */
-struct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,
+struct wiphy *wiphy_new_nm_dup(const struct cfg80211_ops *ops, int sizeof_priv,
 			   const char *requested_name);
 
 /**
@@ -3329,20 +3329,20 @@ struct wiphy *wiphy_new_nm(const struct
 static inline struct wiphy *wiphy_new(const struct cfg80211_ops *ops,
 				      int sizeof_priv)
 {
-	return wiphy_new_nm(ops, sizeof_priv, NULL);
+	return wiphy_new_nm_dup(ops, sizeof_priv, NULL);
 }
 
 /**
- * wiphy_register - register a wiphy with cfg80211
+ * wiphy_register_dup - register a wiphy with cfg80211
  *
  * @wiphy: The wiphy to register.
  *
  * Return: A non-negative wiphy index or a negative error code.
  */
-int wiphy_register(struct wiphy *wiphy);
+int wiphy_register_dup(struct wiphy *wiphy);
 
 /**
- * wiphy_unregister - deregister a wiphy from cfg80211
+ * wiphy_unregister_dup - deregister a wiphy from cfg80211
  *
  * @wiphy: The wiphy to unregister.
  *
@@ -3350,14 +3350,14 @@ int wiphy_register(struct wiphy *wiphy);
  * pointer, but the call may sleep to wait for an outstanding
  * request that is being handled.
  */
-void wiphy_unregister(struct wiphy *wiphy);
+void wiphy_unregister_dup(struct wiphy *wiphy);
 
 /**
- * wiphy_free - free wiphy
+ * wiphy_free_dup - free wiphy
  *
  * @wiphy: The wiphy to free
  */
-void wiphy_free(struct wiphy *wiphy);
+void wiphy_free_dup(struct wiphy *wiphy);
 
 /* internal structs */
 struct cfg80211_conn;
@@ -3512,19 +3512,19 @@ static inline void *wdev_priv(struct wir
  */
 
 /**
- * ieee80211_channel_to_frequency - convert channel number to frequency
+ * ieee80211_channel_to_frequency_dup - convert channel number to frequency
  * @chan: channel number
  * @band: band, necessary due to channel number overlap
  * Return: The corresponding frequency (in MHz), or 0 if the conversion failed.
  */
-int ieee80211_channel_to_frequency(int chan, enum ieee80211_band band);
+int ieee80211_channel_to_frequency_dup(int chan, enum ieee80211_band band);
 
 /**
- * ieee80211_frequency_to_channel - convert frequency to channel number
+ * ieee80211_frequency_to_channel_dup - convert frequency to channel number
  * @freq: center frequency
  * Return: The corresponding channel, or 0 if the conversion failed.
  */
-int ieee80211_frequency_to_channel(int freq);
+int ieee80211_frequency_to_channel_dup(int freq);
 
 /*
  * Name indirection necessary because the ieee80211 code also has
@@ -3533,7 +3533,7 @@ int ieee80211_frequency_to_channel(int f
  * to include both header files you'll (rightfully!) get a symbol
  * clash.
  */
-struct ieee80211_channel *__ieee80211_get_channel(struct wiphy *wiphy,
+struct ieee80211_channel *__ieee80211_get_channel_dup(struct wiphy *wiphy,
 						  int freq);
 /**
  * ieee80211_get_channel - get channel struct from wiphy for specified frequency
@@ -3544,11 +3544,11 @@ struct ieee80211_channel *__ieee80211_ge
 static inline struct ieee80211_channel *
 ieee80211_get_channel(struct wiphy *wiphy, int freq)
 {
-	return __ieee80211_get_channel(wiphy, freq);
+	return __ieee80211_get_channel_dup(wiphy, freq);
 }
 
 /**
- * ieee80211_get_response_rate - get basic rate for a given rate
+ * ieee80211_get_response_rate_dup - get basic rate for a given rate
  *
  * @sband: the band to look for rates in
  * @basic_rates: bitmap of basic rates
@@ -3560,18 +3560,18 @@ ieee80211_get_channel(struct wiphy *wiph
  * rates in the band's bitrate table.
  */
 struct ieee80211_rate *
-ieee80211_get_response_rate(struct ieee80211_supported_band *sband,
+ieee80211_get_response_rate_dup(struct ieee80211_supported_band *sband,
 			    u32 basic_rates, int bitrate);
 
 /**
- * ieee80211_mandatory_rates - get mandatory rates for a given band
+ * ieee80211_mandatory_rates_dup - get mandatory rates for a given band
  * @sband: the band to look for rates in
  * @scan_width: width of the control channel
  *
  * This function returns a bitmap of the mandatory rates for the given
  * band, bits are set according to the rate position in the bitrates array.
  */
-u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,
+u32 ieee80211_mandatory_rates_dup(struct ieee80211_supported_band *sband,
 			      enum nl80211_bss_scan_width scan_width);
 
 /*
@@ -3600,10 +3600,10 @@ struct ieee80211_radiotap_vendor_namespa
 /**
  * struct ieee80211_radiotap_iterator - tracks walk thru present radiotap args
  * @this_arg_index: index of current arg, valid after each successful call
- *	to ieee80211_radiotap_iterator_next()
+ *	to ieee80211_radiotap_iterator_next_dup()
  * @this_arg: pointer to current radiotap arg; it is valid after each
- *	call to ieee80211_radiotap_iterator_next() but also after
- *	ieee80211_radiotap_iterator_init() where it will point to
+ *	call to ieee80211_radiotap_iterator_next_dup() but also after
+ *	ieee80211_radiotap_iterator_init_dup() where it will point to
  *	the beginning of the actual data portion
  * @this_arg_size: length of the current arg, for convenience
  * @current_namespace: pointer to the current namespace definition
@@ -3647,20 +3647,20 @@ struct ieee80211_radiotap_iterator {
 };
 
 int
-ieee80211_radiotap_iterator_init(struct ieee80211_radiotap_iterator *iterator,
+ieee80211_radiotap_iterator_init_dup(struct ieee80211_radiotap_iterator *iterator,
 				 struct ieee80211_radiotap_header *radiotap_header,
 				 int max_length,
 				 const struct ieee80211_radiotap_vendor_namespaces *vns);
 
 int
-ieee80211_radiotap_iterator_next(struct ieee80211_radiotap_iterator *iterator);
+ieee80211_radiotap_iterator_next_dup(struct ieee80211_radiotap_iterator *iterator);
 
 
-extern const unsigned char rfc1042_header[6];
-extern const unsigned char bridge_tunnel_header[6];
+extern const unsigned char rfc1042_header_dup[6];
+extern const unsigned char bridge_tunnel_header_dup[6];
 
 /**
- * ieee80211_get_hdrlen_from_skb - get header length from data
+ * ieee80211_get_hdrlen_from_skb_dup - get header length from data
  *
  * @skb: the frame
  *
@@ -3671,23 +3671,23 @@ extern const unsigned char bridge_tunnel
  * headers). Or 0 if the data in the sk_buff is too short to contain a valid
  * 802.11 header.
  */
-unsigned int ieee80211_get_hdrlen_from_skb(const struct sk_buff *skb);
+unsigned int ieee80211_get_hdrlen_from_skb_dup(const struct sk_buff *skb);
 
 /**
- * ieee80211_hdrlen - get header length in bytes from frame control
+ * ieee80211_hdrlen_dup - get header length in bytes from frame control
  * @fc: frame control field in little-endian format
  * Return: The header length in bytes.
  */
-unsigned int __attribute_const__ ieee80211_hdrlen(__le16 fc);
+unsigned int __attribute_const__ ieee80211_hdrlen_dup(__le16 fc);
 
 /**
- * ieee80211_get_mesh_hdrlen - get mesh extension header length
+ * ieee80211_get_mesh_hdrlen_dup - get mesh extension header length
  * @meshhdr: the mesh extension header, only the flags field
  *	(first byte) will be accessed
  * Return: The length of the extension header, which is always at
  * least 6 bytes and at most 18 if address 5 and 6 are present.
  */
-unsigned int ieee80211_get_mesh_hdrlen(struct ieee80211s_hdr *meshhdr);
+unsigned int ieee80211_get_mesh_hdrlen_dup(struct ieee80211s_hdr *meshhdr);
 
 /**
  * DOC: Data path helpers
@@ -3698,17 +3698,17 @@ unsigned int ieee80211_get_mesh_hdrlen(s
  */
 
 /**
- * ieee80211_data_to_8023 - convert an 802.11 data frame to 802.3
+ * ieee80211_data_to_8023_dup - convert an 802.11 data frame to 802.3
  * @skb: the 802.11 data frame
  * @addr: the device MAC address
  * @iftype: the virtual interface type
  * Return: 0 on success. Non-zero on error.
  */
-int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
+int ieee80211_data_to_8023_dup(struct sk_buff *skb, const u8 *addr,
 			   enum nl80211_iftype iftype);
 
 /**
- * ieee80211_data_from_8023 - convert an 802.3 frame to 802.11
+ * ieee80211_data_from_8023_dup - convert an 802.3 frame to 802.11
  * @skb: the 802.3 frame
  * @addr: the device MAC address
  * @iftype: the virtual interface type
@@ -3716,12 +3716,12 @@ int ieee80211_data_to_8023(struct sk_buf
  * @qos: build 802.11 QoS data frame
  * Return: 0 on success, or a negative error code.
  */
-int ieee80211_data_from_8023(struct sk_buff *skb, const u8 *addr,
+int ieee80211_data_from_8023_dup(struct sk_buff *skb, const u8 *addr,
 			     enum nl80211_iftype iftype, const u8 *bssid,
 			     bool qos);
 
 /**
- * ieee80211_amsdu_to_8023s - decode an IEEE 802.11n A-MSDU frame
+ * ieee80211_amsdu_to_8023s_dup - decode an IEEE 802.11n A-MSDU frame
  *
  * Decode an IEEE 802.11n A-MSDU frame and convert it to a list of
  * 802.3 frames. The @list will be empty if the decode fails. The
@@ -3735,22 +3735,22 @@ int ieee80211_data_from_8023(struct sk_b
  * @extra_headroom: The hardware extra headroom for SKBs in the @list.
  * @has_80211_header: Set it true if SKB is with IEEE 802.11 header.
  */
-void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
+void ieee80211_amsdu_to_8023s_dup(struct sk_buff *skb, struct sk_buff_head *list,
 			      const u8 *addr, enum nl80211_iftype iftype,
 			      const unsigned int extra_headroom,
 			      bool has_80211_header);
 
 /**
- * cfg80211_classify8021d - determine the 802.1p/1d tag for a data frame
+ * cfg80211_classify8021d_dup - determine the 802.1p/1d tag for a data frame
  * @skb: the data frame
  * @qos_map: Interworking QoS mapping or %NULL if not in use
  * Return: The 802.1p/1d tag.
  */
-unsigned int cfg80211_classify8021d(struct sk_buff *skb,
+unsigned int cfg80211_classify8021d_dup(struct sk_buff *skb,
 				    struct cfg80211_qos_map *qos_map);
 
 /**
- * cfg80211_find_ie - find information element in data
+ * cfg80211_find_ie_dup - find information element in data
  *
  * @eid: element ID
  * @ies: data consisting of IEs
@@ -3764,10 +3764,10 @@ unsigned int cfg80211_classify8021d(stru
  * Note: There are no checks on the element length other than
  * having to fit into the given data.
  */
-const u8 *cfg80211_find_ie(u8 eid, const u8 *ies, int len);
+const u8 *cfg80211_find_ie_dup(u8 eid, const u8 *ies, int len);
 
 /**
- * cfg80211_find_vendor_ie - find vendor specific information element in data
+ * cfg80211_find_vendor_ie_dup - find vendor specific information element in data
  *
  * @oui: vendor OUI
  * @oui_type: vendor-specific OUI type
@@ -3782,7 +3782,7 @@ const u8 *cfg80211_find_ie(u8 eid, const
  * Note: There are no checks on the element length other than having to fit into
  * the given data.
  */
-const u8 *cfg80211_find_vendor_ie(unsigned int oui, u8 oui_type,
+const u8 *cfg80211_find_vendor_ie_dup(unsigned int oui, u8 oui_type,
 				  const u8 *ies, int len);
 
 /**
@@ -3792,7 +3792,7 @@ const u8 *cfg80211_find_vendor_ie(unsign
  */
 
 /**
- * regulatory_hint - driver hint to the wireless core a regulatory domain
+ * regulatory_hint_dup - driver hint to the wireless core a regulatory domain
  * @wiphy: the wireless device giving the hint (used only for reporting
  *	conflicts)
  * @alpha2: the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
@@ -3808,18 +3808,18 @@ const u8 *cfg80211_find_vendor_ie(unsign
  * for a regulatory domain structure for the respective country.
  *
  * The wiphy must have been registered to cfg80211 prior to this call.
- * For cfg80211 drivers this means you must first use wiphy_register(),
- * for mac80211 drivers you must first use ieee80211_register_hw().
+ * For cfg80211 drivers this means you must first use wiphy_register_dup(),
+ * for mac80211 drivers you must first use ieee80211_register_hw_dup().
  *
  * Drivers should check the return value, its possible you can get
  * an -ENOMEM.
  *
  * Return: 0 on success. -ENOMEM.
  */
-int regulatory_hint(struct wiphy *wiphy, const char *alpha2);
+int regulatory_hint_dup(struct wiphy *wiphy, const char *alpha2);
 
 /**
- * wiphy_apply_custom_regulatory - apply a custom driver regulatory domain
+ * wiphy_apply_custom_regulatory_dup - apply a custom driver regulatory domain
  * @wiphy: the wireless device we want to process the regulatory domain on
  * @regd: the custom regulatory domain to use for this wiphy
  *
@@ -3833,11 +3833,11 @@ int regulatory_hint(struct wiphy *wiphy,
  * REGULATORY_CUSTOM_REG or cfg80211 will set it for the wiphy
  * that called this helper.
  */
-void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
+void wiphy_apply_custom_regulatory_dup(struct wiphy *wiphy,
 				   const struct ieee80211_regdomain *regd);
 
 /**
- * freq_reg_info - get regulatory information for the given frequency
+ * freq_reg_info_dup - get regulatory information for the given frequency
  * @wiphy: the wiphy for which we want to process this rule for
  * @center_freq: Frequency in KHz for which we want regulatory information for
  *
@@ -3854,17 +3854,17 @@ void wiphy_apply_custom_regulatory(struc
  * See freq_in_rule_band() for our current definition of a band -- this is
  * purely subjective and right now it's 802.11 specific.
  */
-const struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,
+const struct ieee80211_reg_rule *freq_reg_info_dup(struct wiphy *wiphy,
 					       u32 center_freq);
 
 /**
- * reg_initiator_name - map regulatory request initiator enum to name
+ * reg_initiator_name_dup - map regulatory request initiator enum to name
  * @initiator: the regulatory request initiator
  *
  * You can use this to map the regulatory request initiator enum to a
  * proper string representation.
  */
-const char *reg_initiator_name(enum nl80211_reg_initiator initiator);
+const char *reg_initiator_name_dup(enum nl80211_reg_initiator initiator);
 
 /*
  * callbacks for asynchronous cfg80211 methods, notification
@@ -3872,23 +3872,23 @@ const char *reg_initiator_name(enum nl80
  */
 
 /**
- * cfg80211_scan_done - notify that scan finished
+ * cfg80211_scan_done_dup - notify that scan finished
  *
  * @request: the corresponding scan request
  * @aborted: set to true if the scan was aborted for any reason,
  *	userspace will be notified of that
  */
-void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted);
+void cfg80211_scan_done_dup(struct cfg80211_scan_request *request, bool aborted);
 
 /**
- * cfg80211_sched_scan_results - notify that new scan results are available
+ * cfg80211_sched_scan_results_dup - notify that new scan results are available
  *
  * @wiphy: the wiphy which got scheduled scan results
  */
-void cfg80211_sched_scan_results(struct wiphy *wiphy);
+void cfg80211_sched_scan_results_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_sched_scan_stopped - notify that the scheduled scan has stopped
+ * cfg80211_sched_scan_stopped_dup - notify that the scheduled scan has stopped
  *
  * @wiphy: the wiphy on which the scheduled scan stopped
  *
@@ -3896,10 +3896,10 @@ void cfg80211_sched_scan_results(struct
  * scheduled scan had to be stopped, for whatever reason.  The driver
  * is then called back via the sched_scan_stop operation when done.
  */
-void cfg80211_sched_scan_stopped(struct wiphy *wiphy);
+void cfg80211_sched_scan_stopped_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_sched_scan_stopped_rtnl - notify that the scheduled scan has stopped
+ * cfg80211_sched_scan_stopped_rtnl_dup - notify that the scheduled scan has stopped
  *
  * @wiphy: the wiphy on which the scheduled scan stopped
  *
@@ -3908,10 +3908,10 @@ void cfg80211_sched_scan_stopped(struct
  * is then called back via the sched_scan_stop operation when done.
  * This function should be called with rtnl locked.
  */
-void cfg80211_sched_scan_stopped_rtnl(struct wiphy *wiphy);
+void cfg80211_sched_scan_stopped_rtnl_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_inform_bss_width_frame - inform cfg80211 of a received BSS frame
+ * cfg80211_inform_bss_width_frame_dup - inform cfg80211 of a received BSS frame
  *
  * @wiphy: the wiphy reporting the BSS
  * @rx_channel: The channel the frame was received on
@@ -3924,11 +3924,11 @@ void cfg80211_sched_scan_stopped_rtnl(st
  * This informs cfg80211 that BSS information was found and
  * the BSS should be updated/added.
  *
- * Return: A referenced struct, must be released with cfg80211_put_bss()!
+ * Return: A referenced struct, must be released with cfg80211_put_bss_dup()!
  * Or %NULL on error.
  */
 struct cfg80211_bss * __must_check
-cfg80211_inform_bss_width_frame(struct wiphy *wiphy,
+cfg80211_inform_bss_width_frame_dup(struct wiphy *wiphy,
 				struct ieee80211_channel *rx_channel,
 				enum nl80211_bss_scan_width scan_width,
 				struct ieee80211_mgmt *mgmt, size_t len,
@@ -3940,7 +3940,7 @@ cfg80211_inform_bss_frame(struct wiphy *
 			  struct ieee80211_mgmt *mgmt, size_t len,
 			  s32 signal, gfp_t gfp)
 {
-	return cfg80211_inform_bss_width_frame(wiphy, rx_channel,
+	return cfg80211_inform_bss_width_frame_dup(wiphy, rx_channel,
 					       NL80211_BSS_CHAN_WIDTH_20,
 					       mgmt, len, signal, gfp);
 }
@@ -3959,7 +3959,7 @@ enum cfg80211_bss_frame_type {
 };
 
 /**
- * cfg80211_inform_bss_width - inform cfg80211 of a new BSS
+ * cfg80211_inform_bss_width_dup - inform cfg80211 of a new BSS
  *
  * @wiphy: the wiphy reporting the BSS
  * @rx_channel: The channel the frame was received on
@@ -3977,11 +3977,11 @@ enum cfg80211_bss_frame_type {
  * This informs cfg80211 that BSS information was found and
  * the BSS should be updated/added.
  *
- * Return: A referenced struct, must be released with cfg80211_put_bss()!
+ * Return: A referenced struct, must be released with cfg80211_put_bss_dup()!
  * Or %NULL on error.
  */
 struct cfg80211_bss * __must_check
-cfg80211_inform_bss_width(struct wiphy *wiphy,
+cfg80211_inform_bss_width_dup(struct wiphy *wiphy,
 			  struct ieee80211_channel *rx_channel,
 			  enum nl80211_bss_scan_width scan_width,
 			  enum cfg80211_bss_frame_type ftype,
@@ -3997,14 +3997,14 @@ cfg80211_inform_bss(struct wiphy *wiphy,
 		    u16 beacon_interval, const u8 *ie, size_t ielen,
 		    s32 signal, gfp_t gfp)
 {
-	return cfg80211_inform_bss_width(wiphy, rx_channel,
+	return cfg80211_inform_bss_width_dup(wiphy, rx_channel,
 					 NL80211_BSS_CHAN_WIDTH_20, ftype,
 					 bssid, tsf, capability,
 					 beacon_interval, ie, ielen, signal,
 					 gfp);
 }
 
-struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
+struct cfg80211_bss *cfg80211_get_bss_dup(struct wiphy *wiphy,
 				      struct ieee80211_channel *channel,
 				      const u8 *bssid,
 				      const u8 *ssid, size_t ssid_len,
@@ -4014,30 +4014,30 @@ cfg80211_get_ibss(struct wiphy *wiphy,
 		  struct ieee80211_channel *channel,
 		  const u8 *ssid, size_t ssid_len)
 {
-	return cfg80211_get_bss(wiphy, channel, NULL, ssid, ssid_len,
+	return cfg80211_get_bss_dup(wiphy, channel, NULL, ssid, ssid_len,
 				WLAN_CAPABILITY_IBSS, WLAN_CAPABILITY_IBSS);
 }
 
 /**
- * cfg80211_ref_bss - reference BSS struct
+ * cfg80211_ref_bss_dup - reference BSS struct
  * @wiphy: the wiphy this BSS struct belongs to
  * @bss: the BSS struct to reference
  *
  * Increments the refcount of the given BSS struct.
  */
-void cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+void cfg80211_ref_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *bss);
 
 /**
- * cfg80211_put_bss - unref BSS struct
+ * cfg80211_put_bss_dup - unref BSS struct
  * @wiphy: the wiphy this BSS struct belongs to
  * @bss: the BSS struct
  *
  * Decrements the refcount of the given BSS struct.
  */
-void cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+void cfg80211_put_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *bss);
 
 /**
- * cfg80211_unlink_bss - unlink BSS from internal data structures
+ * cfg80211_unlink_bss_dup - unlink BSS from internal data structures
  * @wiphy: the wiphy
  * @bss: the bss to remove
  *
@@ -4046,7 +4046,7 @@ void cfg80211_put_bss(struct wiphy *wiph
  * function when you detect a BSS is gone. Normally BSSes will also time
  * out, so it is not necessary to use this function at all.
  */
-void cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+void cfg80211_unlink_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *bss);
 
 static inline enum nl80211_bss_scan_width
 cfg80211_chandef_to_scan_width(const struct cfg80211_chan_def *chandef)
@@ -4062,7 +4062,7 @@ cfg80211_chandef_to_scan_width(const str
 }
 
 /**
- * cfg80211_rx_mlme_mgmt - notification of processed MLME management frame
+ * cfg80211_rx_mlme_mgmt_dup - notification of processed MLME management frame
  * @dev: network device
  * @buf: authentication frame (header + body)
  * @len: length of the frame data
@@ -4070,30 +4070,30 @@ cfg80211_chandef_to_scan_width(const str
  * This function is called whenever an authentication, disassociation or
  * deauthentication frame has been received and processed in station mode.
  * After being asked to authenticate via cfg80211_ops::auth() the driver must
- * call either this function or cfg80211_auth_timeout().
+ * call either this function or cfg80211_auth_timeout_dup().
  * After being asked to associate via cfg80211_ops::assoc() the driver must
- * call either this function or cfg80211_auth_timeout().
+ * call either this function or cfg80211_auth_timeout_dup().
  * While connected, the driver must calls this for received and processed
  * disassociation and deauthentication frames. If the frame couldn't be used
  * because it was unprotected, the driver must call the function
- * cfg80211_rx_unprot_mlme_mgmt() instead.
+ * cfg80211_rx_unprot_mlme_mgmt_dup() instead.
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
+void cfg80211_rx_mlme_mgmt_dup(struct net_device *dev, const u8 *buf, size_t len);
 
 /**
- * cfg80211_auth_timeout - notification of timed out authentication
+ * cfg80211_auth_timeout_dup - notification of timed out authentication
  * @dev: network device
  * @addr: The MAC address of the device with which the authentication timed out
  *
  * This function may sleep. The caller must hold the corresponding wdev's
  * mutex.
  */
-void cfg80211_auth_timeout(struct net_device *dev, const u8 *addr);
+void cfg80211_auth_timeout_dup(struct net_device *dev, const u8 *addr);
 
 /**
- * cfg80211_rx_assoc_resp - notification of processed association response
+ * cfg80211_rx_assoc_resp_dup - notification of processed association response
  * @dev: network device
  * @bss: the BSS that association was requested with, ownership of the pointer
  *	moves to cfg80211 in this call
@@ -4102,26 +4102,26 @@ void cfg80211_auth_timeout(struct net_de
  * @uapsd_queues: bitmap of ACs configured to uapsd. -1 if n/a.
  *
  * After being asked to associate via cfg80211_ops::assoc() the driver must
- * call either this function or cfg80211_auth_timeout().
+ * call either this function or cfg80211_auth_timeout_dup().
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_rx_assoc_resp(struct net_device *dev,
+void cfg80211_rx_assoc_resp_dup(struct net_device *dev,
 			    struct cfg80211_bss *bss,
 			    const u8 *buf, size_t len,
 			    int uapsd_queues);
 
 /**
- * cfg80211_assoc_timeout - notification of timed out association
+ * cfg80211_assoc_timeout_dup - notification of timed out association
  * @dev: network device
  * @bss: The BSS entry with which association timed out.
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss);
+void cfg80211_assoc_timeout_dup(struct net_device *dev, struct cfg80211_bss *bss);
 
 /**
- * cfg80211_tx_mlme_mgmt - notification of transmitted deauth/disassoc frame
+ * cfg80211_tx_mlme_mgmt_dup - notification of transmitted deauth/disassoc frame
  * @dev: network device
  * @buf: 802.11 frame (header + body)
  * @len: length of the frame data
@@ -4131,10 +4131,10 @@ void cfg80211_assoc_timeout(struct net_d
  * locally generated ones. This function may sleep. The caller must hold the
  * corresponding wdev's mutex.
  */
-void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
+void cfg80211_tx_mlme_mgmt_dup(struct net_device *dev, const u8 *buf, size_t len);
 
 /**
- * cfg80211_rx_unprot_mlme_mgmt - notification of unprotected mlme mgmt frame
+ * cfg80211_rx_unprot_mlme_mgmt_dup - notification of unprotected mlme mgmt frame
  * @dev: network device
  * @buf: deauthentication frame (header + body)
  * @len: length of the frame data
@@ -4143,11 +4143,11 @@ void cfg80211_tx_mlme_mgmt(struct net_de
  * frame has been dropped in station mode because of MFP being used but the
  * frame was not protected. This function may sleep.
  */
-void cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev,
+void cfg80211_rx_unprot_mlme_mgmt_dup(struct net_device *dev,
 				  const u8 *buf, size_t len);
 
 /**
- * cfg80211_michael_mic_failure - notification of Michael MIC failure (TKIP)
+ * cfg80211_michael_mic_failure_dup - notification of Michael MIC failure (TKIP)
  * @dev: network device
  * @addr: The source MAC address of the frame
  * @key_type: The key type that the received frame used
@@ -4159,12 +4159,12 @@ void cfg80211_rx_unprot_mlme_mgmt(struct
  * received frame. This matches with MLME-MICHAELMICFAILURE.indication()
  * primitive.
  */
-void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
+void cfg80211_michael_mic_failure_dup(struct net_device *dev, const u8 *addr,
 				  enum nl80211_key_type key_type, int key_id,
 				  const u8 *tsc, gfp_t gfp);
 
 /**
- * cfg80211_ibss_joined - notify cfg80211 that device joined an IBSS
+ * cfg80211_ibss_joined_dup - notify cfg80211 that device joined an IBSS
  *
  * @dev: network device
  * @bssid: the BSSID of the IBSS joined
@@ -4178,7 +4178,7 @@ void cfg80211_michael_mic_failure(struct
  * with the locally generated beacon -- this guarantees that there is
  * always a scan result for this IBSS. cfg80211 will handle the rest.
  */
-void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+void cfg80211_ibss_joined_dup(struct net_device *dev, const u8 *bssid,
 			  struct ieee80211_channel *channel, gfp_t gfp);
 
 /**
@@ -4194,7 +4194,7 @@ void cfg80211_ibss_joined(struct net_dev
  * detected, most likely via a beacon or, less likely, via a probe response.
  * cfg80211 then sends a notification to userspace.
  */
-void cfg80211_notify_new_peer_candidate(struct net_device *dev,
+void cfg80211_notify_new_peer_candidate_dup(struct net_device *dev,
 		const u8 *macaddr, const u8 *ie, u8 ie_len, gfp_t gfp);
 
 /**
@@ -4212,23 +4212,23 @@ void cfg80211_notify_new_peer_candidate(
  */
 
 /**
- * wiphy_rfkill_set_hw_state - notify cfg80211 about hw block state
+ * wiphy_rfkill_set_hw_state_dup - notify cfg80211 about hw block state
  * @wiphy: the wiphy
  * @blocked: block status
  */
-void wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked);
+void wiphy_rfkill_set_hw_state_dup(struct wiphy *wiphy, bool blocked);
 
 /**
- * wiphy_rfkill_start_polling - start polling rfkill
+ * wiphy_rfkill_start_polling_dup - start polling rfkill
  * @wiphy: the wiphy
  */
-void wiphy_rfkill_start_polling(struct wiphy *wiphy);
+void wiphy_rfkill_start_polling_dup(struct wiphy *wiphy);
 
 /**
- * wiphy_rfkill_stop_polling - stop polling rfkill
+ * wiphy_rfkill_stop_polling_dup - stop polling rfkill
  * @wiphy: the wiphy
  */
-void wiphy_rfkill_stop_polling(struct wiphy *wiphy);
+void wiphy_rfkill_stop_polling_dup(struct wiphy *wiphy);
 
 /**
  * DOC: Vendor commands
@@ -4250,18 +4250,18 @@ void wiphy_rfkill_stop_polling(struct wi
  * managers etc. need.
  */
 
-struct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,
+struct sk_buff *__cfg80211_alloc_reply_skb_dup(struct wiphy *wiphy,
 					   enum nl80211_commands cmd,
 					   enum nl80211_attrs attr,
 					   int approxlen);
 
-struct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,
+struct sk_buff *__cfg80211_alloc_event_skb_dup(struct wiphy *wiphy,
 					   enum nl80211_commands cmd,
 					   enum nl80211_attrs attr,
 					   int vendor_event_idx,
 					   int approxlen, gfp_t gfp);
 
-void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp);
+void __cfg80211_send_event_skb_dup(struct sk_buff *skb, gfp_t gfp);
 
 /**
  * cfg80211_vendor_cmd_alloc_reply_skb - allocate vendor command reply
@@ -4281,7 +4281,7 @@ void __cfg80211_send_event_skb(struct sk
  * which can then read that data out of the vendor data attribute.
  * You must not modify the skb in any other way.
  *
- * When done, call cfg80211_vendor_cmd_reply() with the skb and return
+ * When done, call cfg80211_vendor_cmd_reply_dup() with the skb and return
  * its error code as the result of the doit() operation.
  *
  * Return: An allocated and pre-filled skb. %NULL if any errors happen.
@@ -4289,12 +4289,12 @@ void __cfg80211_send_event_skb(struct sk
 static inline struct sk_buff *
 cfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
 {
-	return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_VENDOR,
+	return __cfg80211_alloc_reply_skb_dup(wiphy, NL80211_CMD_VENDOR,
 					  NL80211_ATTR_VENDOR_DATA, approxlen);
 }
 
 /**
- * cfg80211_vendor_cmd_reply - send the reply skb
+ * cfg80211_vendor_cmd_reply_dup - send the reply skb
  * @skb: The skb, must have been allocated with
  *	cfg80211_vendor_cmd_alloc_reply_skb()
  *
@@ -4305,7 +4305,7 @@ cfg80211_vendor_cmd_alloc_reply_skb(stru
  *
  * Return: An error code or 0 on success.
  */
-int cfg80211_vendor_cmd_reply(struct sk_buff *skb);
+int cfg80211_vendor_cmd_reply_dup(struct sk_buff *skb);
 
 /**
  * cfg80211_vendor_event_alloc - allocate vendor-specific event skb
@@ -4327,7 +4327,7 @@ static inline struct sk_buff *
 cfg80211_vendor_event_alloc(struct wiphy *wiphy, int approxlen,
 			    int event_idx, gfp_t gfp)
 {
-	return __cfg80211_alloc_event_skb(wiphy, NL80211_CMD_VENDOR,
+	return __cfg80211_alloc_event_skb_dup(wiphy, NL80211_CMD_VENDOR,
 					  NL80211_ATTR_VENDOR_DATA,
 					  event_idx, approxlen, gfp);
 }
@@ -4342,7 +4342,7 @@ cfg80211_vendor_event_alloc(struct wiphy
  */
 static inline void cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp)
 {
-	__cfg80211_send_event_skb(skb, gfp);
+	__cfg80211_send_event_skb_dup(skb, gfp);
 }
 
 #ifdef CONFIG_NL80211_TESTMODE
@@ -4383,7 +4383,7 @@ static inline void cfg80211_vendor_event
 static inline struct sk_buff *
 cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
 {
-	return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_TESTMODE,
+	return __cfg80211_alloc_reply_skb_dup(wiphy, NL80211_CMD_TESTMODE,
 					  NL80211_ATTR_TESTDATA, approxlen);
 }
 
@@ -4401,7 +4401,7 @@ cfg80211_testmode_alloc_reply_skb(struct
  */
 static inline int cfg80211_testmode_reply(struct sk_buff *skb)
 {
-	return cfg80211_vendor_cmd_reply(skb);
+	return cfg80211_vendor_cmd_reply_dup(skb);
 }
 
 /**
@@ -4428,7 +4428,7 @@ static inline int cfg80211_testmode_repl
 static inline struct sk_buff *
 cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy, int approxlen, gfp_t gfp)
 {
-	return __cfg80211_alloc_event_skb(wiphy, NL80211_CMD_TESTMODE,
+	return __cfg80211_alloc_event_skb_dup(wiphy, NL80211_CMD_TESTMODE,
 					  NL80211_ATTR_TESTDATA, -1,
 					  approxlen, gfp);
 }
@@ -4445,7 +4445,7 @@ cfg80211_testmode_alloc_event_skb(struct
  */
 static inline void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)
 {
-	__cfg80211_send_event_skb(skb, gfp);
+	__cfg80211_send_event_skb_dup(skb, gfp);
 }
 
 #define CFG80211_TESTMODE_CMD(cmd)	.testmode_cmd = (cmd),
@@ -4456,7 +4456,7 @@ static inline void cfg80211_testmode_eve
 #endif
 
 /**
- * cfg80211_connect_result - notify cfg80211 of connection result
+ * cfg80211_connect_result_dup - notify cfg80211 of connection result
  *
  * @dev: network device
  * @bssid: the BSSID of the AP
@@ -4472,13 +4472,13 @@ static inline void cfg80211_testmode_eve
  * It should be called by the underlying driver whenever connect() has
  * succeeded.
  */
-void cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
+void cfg80211_connect_result_dup(struct net_device *dev, const u8 *bssid,
 			     const u8 *req_ie, size_t req_ie_len,
 			     const u8 *resp_ie, size_t resp_ie_len,
 			     u16 status, gfp_t gfp);
 
 /**
- * cfg80211_roamed - notify cfg80211 of roaming
+ * cfg80211_roamed_dup - notify cfg80211 of roaming
  *
  * @dev: network device
  * @channel: the channel of the new AP
@@ -4492,14 +4492,14 @@ void cfg80211_connect_result(struct net_
  * It should be called by the underlying driver whenever it roamed
  * from one AP to another while connected.
  */
-void cfg80211_roamed(struct net_device *dev,
+void cfg80211_roamed_dup(struct net_device *dev,
 		     struct ieee80211_channel *channel,
 		     const u8 *bssid,
 		     const u8 *req_ie, size_t req_ie_len,
 		     const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp);
 
 /**
- * cfg80211_roamed_bss - notify cfg80211 of roaming
+ * cfg80211_roamed_bss_dup - notify cfg80211 of roaming
  *
  * @dev: network device
  * @bss: entry of bss to which STA got roamed
@@ -4515,17 +4515,17 @@ void cfg80211_roamed(struct net_device *
  * while connected. Drivers which have roaming implemented in firmware
  * may use this function to avoid a race in bss entry timeout where the bss
  * entry of the new AP is seen in the driver, but gets timed out by the time
- * it is accessed in __cfg80211_roamed() due to delay in scheduling
+ * it is accessed in __cfg80211_roamed_dup() due to delay in scheduling
  * rdev->event_work. In case of any failures, the reference is released
- * either in cfg80211_roamed_bss() or in __cfg80211_romed(), Otherwise,
+ * either in cfg80211_roamed_bss_dup() or in __cfg80211_romed(), Otherwise,
  * it will be released while diconneting from the current bss.
  */
-void cfg80211_roamed_bss(struct net_device *dev, struct cfg80211_bss *bss,
+void cfg80211_roamed_bss_dup(struct net_device *dev, struct cfg80211_bss *bss,
 			 const u8 *req_ie, size_t req_ie_len,
 			 const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp);
 
 /**
- * cfg80211_disconnected - notify cfg80211 that connection was dropped
+ * cfg80211_disconnected_dup - notify cfg80211 that connection was dropped
  *
  * @dev: network device
  * @ie: information elements of the deauth/disassoc frame (may be %NULL)
@@ -4536,11 +4536,11 @@ void cfg80211_roamed_bss(struct net_devi
  * After it calls this function, the driver should enter an idle state
  * and not try to connect to any AP any more.
  */
-void cfg80211_disconnected(struct net_device *dev, u16 reason,
+void cfg80211_disconnected_dup(struct net_device *dev, u16 reason,
 			   const u8 *ie, size_t ie_len, gfp_t gfp);
 
 /**
- * cfg80211_ready_on_channel - notification of remain_on_channel start
+ * cfg80211_ready_on_channel_dup - notification of remain_on_channel start
  * @wdev: wireless device
  * @cookie: the request cookie
  * @chan: The current channel (from remain_on_channel request)
@@ -4548,44 +4548,44 @@ void cfg80211_disconnected(struct net_de
  *	channel
  * @gfp: allocation flags
  */
-void cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_ready_on_channel_dup(struct wireless_dev *wdev, u64 cookie,
 			       struct ieee80211_channel *chan,
 			       unsigned int duration, gfp_t gfp);
 
 /**
- * cfg80211_remain_on_channel_expired - remain_on_channel duration expired
+ * cfg80211_remain_on_channel_expired_dup - remain_on_channel duration expired
  * @wdev: wireless device
  * @cookie: the request cookie
  * @chan: The current channel (from remain_on_channel request)
  * @gfp: allocation flags
  */
-void cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_remain_on_channel_expired_dup(struct wireless_dev *wdev, u64 cookie,
 					struct ieee80211_channel *chan,
 					gfp_t gfp);
 
 
 /**
- * cfg80211_new_sta - notify userspace about station
+ * cfg80211_new_sta_dup - notify userspace about station
  *
  * @dev: the netdev
  * @mac_addr: the station's address
  * @sinfo: the station information
  * @gfp: allocation flags
  */
-void cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,
+void cfg80211_new_sta_dup(struct net_device *dev, const u8 *mac_addr,
 		      struct station_info *sinfo, gfp_t gfp);
 
 /**
- * cfg80211_del_sta - notify userspace about deletion of a station
+ * cfg80211_del_sta_dup - notify userspace about deletion of a station
  *
  * @dev: the netdev
  * @mac_addr: the station's address
  * @gfp: allocation flags
  */
-void cfg80211_del_sta(struct net_device *dev, const u8 *mac_addr, gfp_t gfp);
+void cfg80211_del_sta_dup(struct net_device *dev, const u8 *mac_addr, gfp_t gfp);
 
 /**
- * cfg80211_conn_failed - connection request failed notification
+ * cfg80211_conn_failed_dup - connection request failed notification
  *
  * @dev: the netdev
  * @mac_addr: the station's address
@@ -4599,12 +4599,12 @@ void cfg80211_del_sta(struct net_device
  * The reason for connection failure can be any of the value from
  * nl80211_connect_failed_reason enum
  */
-void cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,
+void cfg80211_conn_failed_dup(struct net_device *dev, const u8 *mac_addr,
 			  enum nl80211_connect_failed_reason reason,
 			  gfp_t gfp);
 
 /**
- * cfg80211_rx_mgmt - notification of received, unprocessed management frame
+ * cfg80211_rx_mgmt_dup - notification of received, unprocessed management frame
  * @wdev: wireless device receiving the frame
  * @freq: Frequency on which the frame was received in MHz
  * @sig_dbm: signal strength in mBm, or 0 if unknown
@@ -4620,11 +4620,11 @@ void cfg80211_conn_failed(struct net_dev
  * action frames; %false otherwise, in which case for action frames the
  * driver is responsible for rejecting the frame.
  */
-bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_dbm,
+bool cfg80211_rx_mgmt_dup(struct wireless_dev *wdev, int freq, int sig_dbm,
 		      const u8 *buf, size_t len, u32 flags);
 
 /**
- * cfg80211_mgmt_tx_status - notification of TX status for management frame
+ * cfg80211_mgmt_tx_status_dup - notification of TX status for management frame
  * @wdev: wireless device receiving the frame
  * @cookie: Cookie returned by cfg80211_ops::mgmt_tx()
  * @buf: Management frame (header + body)
@@ -4636,12 +4636,12 @@ bool cfg80211_rx_mgmt(struct wireless_de
  * transmitted with cfg80211_ops::mgmt_tx() to report the TX status of the
  * transmission attempt.
  */
-void cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_mgmt_tx_status_dup(struct wireless_dev *wdev, u64 cookie,
 			     const u8 *buf, size_t len, bool ack, gfp_t gfp);
 
 
 /**
- * cfg80211_cqm_rssi_notify - connection quality monitoring rssi event
+ * cfg80211_cqm_rssi_notify_dup - connection quality monitoring rssi event
  * @dev: network device
  * @rssi_event: the triggered RSSI event
  * @gfp: context flags
@@ -4649,12 +4649,12 @@ void cfg80211_mgmt_tx_status(struct wire
  * This function is called when a configured connection quality monitoring
  * rssi threshold reached event occurs.
  */
-void cfg80211_cqm_rssi_notify(struct net_device *dev,
+void cfg80211_cqm_rssi_notify_dup(struct net_device *dev,
 			      enum nl80211_cqm_rssi_threshold_event rssi_event,
 			      gfp_t gfp);
 
 /**
- * cfg80211_cqm_pktloss_notify - notify userspace about packetloss to peer
+ * cfg80211_cqm_pktloss_notify_dup - notify userspace about packetloss to peer
  * @dev: network device
  * @peer: peer's MAC address
  * @num_packets: how many packets were lost -- should be a fixed threshold
@@ -4662,11 +4662,11 @@ void cfg80211_cqm_rssi_notify(struct net
  *	threshold (to account for temporary interference)
  * @gfp: context flags
  */
-void cfg80211_cqm_pktloss_notify(struct net_device *dev,
+void cfg80211_cqm_pktloss_notify_dup(struct net_device *dev,
 				 const u8 *peer, u32 num_packets, gfp_t gfp);
 
 /**
- * cfg80211_cqm_txe_notify - TX error rate event
+ * cfg80211_cqm_txe_notify_dup - TX error rate event
  * @dev: network device
  * @peer: peer's MAC address
  * @num_packets: how many packets were lost
@@ -4677,31 +4677,31 @@ void cfg80211_cqm_pktloss_notify(struct
  * Notify userspace when configured % TX failures over number of packets in a
  * given interval is exceeded.
  */
-void cfg80211_cqm_txe_notify(struct net_device *dev, const u8 *peer,
+void cfg80211_cqm_txe_notify_dup(struct net_device *dev, const u8 *peer,
 			     u32 num_packets, u32 rate, u32 intvl, gfp_t gfp);
 
 /**
- * cfg80211_cqm_beacon_loss_notify - beacon loss event
+ * cfg80211_cqm_beacon_loss_notify_dup - beacon loss event
  * @dev: network device
  * @gfp: context flags
  *
  * Notify userspace about beacon loss from the connected AP.
  */
-void cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp);
+void cfg80211_cqm_beacon_loss_notify_dup(struct net_device *dev, gfp_t gfp);
 
 /**
- * cfg80211_radar_event - radar detection event
+ * cfg80211_radar_event_dup - radar detection event
  * @wiphy: the wiphy
  * @chandef: chandef for the current channel
  * @gfp: context flags
  *
  * This function is called when a radar is detected on the current chanenl.
  */
-void cfg80211_radar_event(struct wiphy *wiphy,
+void cfg80211_radar_event_dup(struct wiphy *wiphy,
 			  struct cfg80211_chan_def *chandef, gfp_t gfp);
 
 /**
- * cfg80211_cac_event - Channel availability check (CAC) event
+ * cfg80211_cac_event_dup - Channel availability check (CAC) event
  * @netdev: network device
  * @chandef: chandef for the current channel
  * @event: type of event
@@ -4711,34 +4711,34 @@ void cfg80211_radar_event(struct wiphy *
  * or aborted. This must be called to notify the completion of a CAC process,
  * also by full-MAC drivers.
  */
-void cfg80211_cac_event(struct net_device *netdev,
+void cfg80211_cac_event_dup(struct net_device *netdev,
 			const struct cfg80211_chan_def *chandef,
 			enum nl80211_radar_event event, gfp_t gfp);
 
 
 /**
- * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying
+ * cfg80211_gtk_rekey_notify_dup - notify userspace about driver rekeying
  * @dev: network device
  * @bssid: BSSID of AP (to avoid races)
  * @replay_ctr: new replay counter
  * @gfp: allocation flags
  */
-void cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,
+void cfg80211_gtk_rekey_notify_dup(struct net_device *dev, const u8 *bssid,
 			       const u8 *replay_ctr, gfp_t gfp);
 
 /**
- * cfg80211_pmksa_candidate_notify - notify about PMKSA caching candidate
+ * cfg80211_pmksa_candidate_notify_dup - notify about PMKSA caching candidate
  * @dev: network device
  * @index: candidate index (the smaller the index, the higher the priority)
  * @bssid: BSSID of AP
  * @preauth: Whether AP advertises support for RSN pre-authentication
  * @gfp: allocation flags
  */
-void cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,
+void cfg80211_pmksa_candidate_notify_dup(struct net_device *dev, int index,
 				     const u8 *bssid, bool preauth, gfp_t gfp);
 
 /**
- * cfg80211_rx_spurious_frame - inform userspace about a spurious frame
+ * cfg80211_rx_spurious_frame_dup - inform userspace about a spurious frame
  * @dev: The device the frame matched to
  * @addr: the transmitter address
  * @gfp: context flags
@@ -4749,11 +4749,11 @@ void cfg80211_pmksa_candidate_notify(str
  * Return: %true if the frame was passed to userspace (or this failed
  * for a reason other than not having a subscription.)
  */
-bool cfg80211_rx_spurious_frame(struct net_device *dev,
+bool cfg80211_rx_spurious_frame_dup(struct net_device *dev,
 				const u8 *addr, gfp_t gfp);
 
 /**
- * cfg80211_rx_unexpected_4addr_frame - inform about unexpected WDS frame
+ * cfg80211_rx_unexpected_4addr_frame_dup - inform about unexpected WDS frame
  * @dev: The device the frame matched to
  * @addr: the transmitter address
  * @gfp: context flags
@@ -4765,22 +4765,22 @@ bool cfg80211_rx_spurious_frame(struct n
  * Return: %true if the frame was passed to userspace (or this failed
  * for a reason other than not having a subscription.)
  */
-bool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,
+bool cfg80211_rx_unexpected_4addr_frame_dup(struct net_device *dev,
 					const u8 *addr, gfp_t gfp);
 
 /**
- * cfg80211_probe_status - notify userspace about probe status
+ * cfg80211_probe_status_dup - notify userspace about probe status
  * @dev: the device the probe was sent on
  * @addr: the address of the peer
  * @cookie: the cookie filled in @probe_client previously
  * @acked: indicates whether probe was acked or not
  * @gfp: allocation flags
  */
-void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
+void cfg80211_probe_status_dup(struct net_device *dev, const u8 *addr,
 			   u64 cookie, bool acked, gfp_t gfp);
 
 /**
- * cfg80211_report_obss_beacon - report beacon from other APs
+ * cfg80211_report_obss_beacon_dup - report beacon from other APs
  * @wiphy: The wiphy that received the beacon
  * @frame: the frame
  * @len: length of the frame
@@ -4791,12 +4791,12 @@ void cfg80211_probe_status(struct net_de
  * received. It is not useful to call this when there is no
  * netdev that is in AP/GO mode.
  */
-void cfg80211_report_obss_beacon(struct wiphy *wiphy,
+void cfg80211_report_obss_beacon_dup(struct wiphy *wiphy,
 				 const u8 *frame, size_t len,
 				 int freq, int sig_dbm);
 
 /**
- * cfg80211_reg_can_beacon - check if beaconing is allowed
+ * cfg80211_reg_can_beacon_dup - check if beaconing is allowed
  * @wiphy: the wiphy
  * @chandef: the channel definition
  * @iftype: interface type
@@ -4804,23 +4804,23 @@ void cfg80211_report_obss_beacon(struct
  * Return: %true if there is no secondary channel or the secondary channel(s)
  * can be used for beaconing (i.e. is not a radar channel etc.)
  */
-bool cfg80211_reg_can_beacon(struct wiphy *wiphy,
+bool cfg80211_reg_can_beacon_dup(struct wiphy *wiphy,
 			     struct cfg80211_chan_def *chandef,
 			     enum nl80211_iftype iftype);
 
 /*
- * cfg80211_ch_switch_notify - update wdev channel and notify userspace
+ * cfg80211_ch_switch_notify_dup - update wdev channel and notify userspace
  * @dev: the device which switched channels
  * @chandef: the new channel definition
  *
  * Caller must acquire wdev_lock, therefore must only be called from sleepable
  * driver context!
  */
-void cfg80211_ch_switch_notify(struct net_device *dev,
+void cfg80211_ch_switch_notify_dup(struct net_device *dev,
 			       struct cfg80211_chan_def *chandef);
 
 /*
- * cfg80211_ch_switch_started_notify - notify channel switch start
+ * cfg80211_ch_switch_started_notify_dup - notify channel switch start
  * @dev: the device on which the channel switch started
  * @chandef: the future channel definition
  * @count: the number of TBTTs until the channel switch happens
@@ -4829,23 +4829,23 @@ void cfg80211_ch_switch_notify(struct ne
  * started, so that it can take appropriate actions (eg. starting
  * channel switch on other vifs), if necessary.
  */
-void cfg80211_ch_switch_started_notify(struct net_device *dev,
+void cfg80211_ch_switch_started_notify_dup(struct net_device *dev,
 				       struct cfg80211_chan_def *chandef,
 				       u8 count);
 
 /**
- * ieee80211_operating_class_to_band - convert operating class to band
+ * ieee80211_operating_class_to_band_dup - convert operating class to band
  *
  * @operating_class: the operating class to convert
  * @band: band pointer to fill
  *
  * Returns %true if the conversion was successful, %false otherwise.
  */
-bool ieee80211_operating_class_to_band(u8 operating_class,
+bool ieee80211_operating_class_to_band_dup(u8 operating_class,
 				       enum ieee80211_band *band);
 
 /*
- * cfg80211_tdls_oper_request - request userspace to perform TDLS operation
+ * cfg80211_tdls_oper_request_dup - request userspace to perform TDLS operation
  * @dev: the device on which the operation is requested
  * @peer: the MAC address of the peer device
  * @oper: the requested TDLS operation (NL80211_TDLS_SETUP or
@@ -4859,20 +4859,20 @@ bool ieee80211_operating_class_to_band(u
  * if it can automatically determine when a TDLS link could be useful (e.g.,
  * based on traffic and signal strength for a peer).
  */
-void cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,
+void cfg80211_tdls_oper_request_dup(struct net_device *dev, const u8 *peer,
 				enum nl80211_tdls_operation oper,
 				u16 reason_code, gfp_t gfp);
 
 /*
- * cfg80211_calculate_bitrate - calculate actual bitrate (in 100Kbps units)
+ * cfg80211_calculate_bitrate_dup - calculate actual bitrate (in 100Kbps units)
  * @rate: given rate_info to calculate bitrate from
  *
  * return 0 if MCS index >= 32
  */
-u32 cfg80211_calculate_bitrate(struct rate_info *rate);
+u32 cfg80211_calculate_bitrate_dup(struct rate_info *rate);
 
 /**
- * cfg80211_unregister_wdev - remove the given wdev
+ * cfg80211_unregister_wdev_dup - remove the given wdev
  * @wdev: struct wireless_dev to remove
  *
  * Call this function only for wdevs that have no netdev assigned,
@@ -4885,10 +4885,10 @@ u32 cfg80211_calculate_bitrate(struct ra
  *
  * Requires the RTNL to be held.
  */
-void cfg80211_unregister_wdev(struct wireless_dev *wdev);
+void cfg80211_unregister_wdev_dup(struct wireless_dev *wdev);
 
 /**
- * struct cfg80211_ft_event - FT Information Elements
+ * struct cfg80211_ft_event_dup - FT Information Elements
  * @ies: FT IEs
  * @ies_len: length of the FT IE in bytes
  * @target_ap: target AP's MAC address
@@ -4904,15 +4904,15 @@ struct cfg80211_ft_event_params {
 };
 
 /**
- * cfg80211_ft_event - notify userspace about FT IE and RIC IE
+ * cfg80211_ft_event_dup - notify userspace about FT IE and RIC IE
  * @netdev: network device
  * @ft_event: IE information
  */
-void cfg80211_ft_event(struct net_device *netdev,
+void cfg80211_ft_event_dup(struct net_device *netdev,
 		       struct cfg80211_ft_event_params *ft_event);
 
 /**
- * cfg80211_get_p2p_attr - find and copy a P2P attribute from IE buffer
+ * cfg80211_get_p2p_attr_dup - find and copy a P2P attribute from IE buffer
  * @ies: the input IE buffer
  * @len: the input length
  * @attr: the attribute ID to find
@@ -4927,12 +4927,12 @@ void cfg80211_ft_event(struct net_device
  * malformed or the attribute can't be found (respectively), or the
  * length of the found attribute (which can be zero).
  */
-int cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,
+int cfg80211_get_p2p_attr_dup(const u8 *ies, unsigned int len,
 			  enum ieee80211_p2p_attr_id attr,
 			  u8 *buf, unsigned int bufsize);
 
 /**
- * cfg80211_report_wowlan_wakeup - report wakeup from WoWLAN
+ * cfg80211_report_wowlan_wakeup_dup - report wakeup from WoWLAN
  * @wdev: the wireless device reporting the wakeup
  * @wakeup: the wakeup report
  * @gfp: allocation flags
@@ -4942,12 +4942,12 @@ int cfg80211_get_p2p_attr(const u8 *ies,
  * pass %NULL as the @wakeup parameter to advertise that something
  * else caused the wakeup.
  */
-void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
+void cfg80211_report_wowlan_wakeup_dup(struct wireless_dev *wdev,
 				   struct cfg80211_wowlan_wakeup *wakeup,
 				   gfp_t gfp);
 
 /**
- * cfg80211_crit_proto_stopped() - indicate critical protocol stopped by driver.
+ * cfg80211_crit_proto_stopped_dup() - indicate critical protocol stopped by driver.
  *
  * @wdev: the wireless device for which critical protocol is stopped.
  * @gfp: allocation flags
@@ -4956,18 +4956,18 @@ void cfg80211_report_wowlan_wakeup(struc
  * operation back to normal. One reason could be that the duration given
  * by .crit_proto_start() has expired.
  */
-void cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp);
+void cfg80211_crit_proto_stopped_dup(struct wireless_dev *wdev, gfp_t gfp);
 
 /**
- * ieee80211_get_num_supported_channels - get number of channels device has
+ * ieee80211_get_num_supported_channels_dup - get number of channels device has
  * @wiphy: the wiphy
  *
  * Return: the number of channels supported by the device.
  */
-unsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy);
+unsigned int ieee80211_get_num_supported_channels_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_check_combinations - check interface combinations
+ * cfg80211_check_combinations_dup - check interface combinations
  *
  * @wiphy: the wiphy
  * @num_different_channels: the number of different channels we want
@@ -4983,13 +4983,13 @@ unsigned int ieee80211_get_num_supported
  * combination of interfaces and their types are allowed according to
  * the interface combinations.
  */
-int cfg80211_check_combinations(struct wiphy *wiphy,
+int cfg80211_check_combinations_dup(struct wiphy *wiphy,
 				const int num_different_channels,
 				const u8 radar_detect,
 				const int iftype_num[NUM_NL80211_IFTYPES]);
 
 /**
- * cfg80211_iter_combinations - iterate over matching combinations
+ * cfg80211_iter_combinations_dup - iterate over matching combinations
  *
  * @wiphy: the wiphy
  * @num_different_channels: the number of different channels we want
@@ -5007,7 +5007,7 @@ int cfg80211_check_combinations(struct w
  * combinations it fits in at a given moment, e.g. for channel switching
  * purposes.
  */
-int cfg80211_iter_combinations(struct wiphy *wiphy,
+int cfg80211_iter_combinations_dup(struct wiphy *wiphy,
 			       const int num_different_channels,
 			       const u8 radar_detect,
 			       const int iftype_num[NUM_NL80211_IFTYPES],
@@ -5016,7 +5016,7 @@ int cfg80211_iter_combinations(struct wi
 			       void *data);
 
 /*
- * cfg80211_stop_iface - trigger interface disconnection
+ * cfg80211_stop_iface_dup - trigger interface disconnection
  *
  * @wiphy: the wiphy
  * @wdev: wireless device
@@ -5027,11 +5027,11 @@ int cfg80211_iter_combinations(struct wi
  *
  * Note: This doesn't need any locks and is asynchronous.
  */
-void cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,
+void cfg80211_stop_iface_dup(struct wiphy *wiphy, struct wireless_dev *wdev,
 			 gfp_t gfp);
 
 /**
- * cfg80211_shutdown_all_interfaces - shut down all interfaces for a wiphy
+ * cfg80211_shutdown_all_interfaces_dup - shut down all interfaces for a wiphy
  * @wiphy: the wiphy to shut down
  *
  * This function shuts down all interfaces belonging to this wiphy by
@@ -5042,7 +5042,7 @@ void cfg80211_stop_iface(struct wiphy *w
  * Callers must hold the RTNL and be able to deal with callbacks into
  * the driver while the function is running.
  */
-void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy);
+void cfg80211_shutdown_all_interfaces_dup(struct wiphy *wiphy);
 
 
 /* ethtool helper */
@@ -5046,7 +5046,7 @@ void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy);
 
 
 /* ethtool helper */
-void cfg80211_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info);
+void cfg80211_get_drvinfo_dup(struct net_device *dev, struct ethtool_drvinfo *info);
 
 /* Logging, debugging and troubleshooting/diagnostic helpers. */
 
--- a/include/net/iw_handler.h	2015-06-23 11:07:42.670848883 +0200
+++ b/include/net/iw_handler.h	2015-06-23 16:42:01.921817484 +0200
@@ -216,7 +216,7 @@
  * --------
  *	- Move event definition in <linux/wireless.h>
  *	- Add Wireless Event support :
- *		o wireless_send_event() prototype
+ *		o wireless_send_event_dup() prototype
  *		o iwe_stream_add_event/point() inline functions
  * V3 to V4
  * --------
@@ -440,7 +440,7 @@ extern int dev_get_wireless_info(char *
 /* Second : functions that may be called by driver modules */
 
 /* Send a single event to user space */
-extern void wireless_send_event(struct net_device *	dev,
+extern void wireless_send_event_dup(struct net_device *	dev,
 				unsigned int		cmd,
 				union iwreq_data *	wrqu,
 				const char *		extra);
@@ -449,27 +449,27 @@ extern void wireless_send_event(struct n
  * More on that later... */
 
 /* Standard handler for SIOCSIWSPY */
-extern int iw_handler_set_spy(struct net_device *	dev,
+extern int iw_handler_set_spy_dup(struct net_device *	dev,
 			      struct iw_request_info *	info,
 			      union iwreq_data *	wrqu,
 			      char *			extra);
 /* Standard handler for SIOCGIWSPY */
-extern int iw_handler_get_spy(struct net_device *	dev,
+extern int iw_handler_get_spy_dup(struct net_device *	dev,
 			      struct iw_request_info *	info,
 			      union iwreq_data *	wrqu,
 			      char *			extra);
 /* Standard handler for SIOCSIWTHRSPY */
-extern int iw_handler_set_thrspy(struct net_device *	dev,
+extern int iw_handler_set_thrspy_dup(struct net_device *	dev,
 				 struct iw_request_info *info,
 				 union iwreq_data *	wrqu,
 				 char *			extra);
 /* Standard handler for SIOCGIWTHRSPY */
-extern int iw_handler_get_thrspy(struct net_device *	dev,
+extern int iw_handler_get_thrspy_dup(struct net_device *	dev,
 				 struct iw_request_info *info,
 				 union iwreq_data *	wrqu,
 				 char *			extra);
 /* Driver call to update spy records */
-extern void wireless_spy_update(struct net_device *	dev,
+extern void wireless_spy_update_dup(struct net_device *	dev,
 				unsigned char *		address,
 				struct iw_quality *	wstats);
 
--- a/include/net/lib80211.h	2015-06-23 11:07:42.670848883 +0200
+++ b/include/net/lib80211.h	2015-06-23 16:42:01.961817961 +0200
@@ -114,13 +114,13 @@ struct lib80211_crypt_info {
 	int crypt_quiesced;
 };
 
-int lib80211_crypt_info_init(struct lib80211_crypt_info *info, char *name,
+int lib80211_crypt_info_init_dup(struct lib80211_crypt_info *info, char *name,
                                 spinlock_t *lock);
-void lib80211_crypt_info_free(struct lib80211_crypt_info *info);
-int lib80211_register_crypto_ops(struct lib80211_crypto_ops *ops);
-int lib80211_unregister_crypto_ops(struct lib80211_crypto_ops *ops);
-struct lib80211_crypto_ops *lib80211_get_crypto_ops(const char *name);
-void lib80211_crypt_delayed_deinit(struct lib80211_crypt_info *info,
+void lib80211_crypt_info_free_dup(struct lib80211_crypt_info *info);
+int lib80211_register_crypto_ops_dup(struct lib80211_crypto_ops *ops);
+int lib80211_unregister_crypto_ops_dup(struct lib80211_crypto_ops *ops);
+struct lib80211_crypto_ops *lib80211_get_crypto_ops_dup(const char *name);
+void lib80211_crypt_delayed_deinit_dup(struct lib80211_crypt_info *info,
 				    struct lib80211_crypt_data **crypt);
 
 #endif /* LIB80211_H */
--- a/include/net/mac80211.h	2015-06-23 11:07:42.672848906 +0200
+++ b/include/net/mac80211.h	2015-06-23 16:42:02.005818485 +0200
@@ -36,7 +36,7 @@ struct inet6_dev;
 /**
  * DOC: Calling mac80211 from interrupts
  *
- * Only ieee80211_tx_status_irqsafe() and ieee80211_rx_irqsafe() can be
+ * Only ieee80211_tx_status_irqsafe_dup() and ieee80211_rx_irqsafe_dup() can be
  * called in hardware interrupt context. The low-level driver must not call any
  * other functions in hardware interrupt context. If there is a need for such
  * call, the low-level driver should first ACK the interrupt and perform the
@@ -566,7 +566,7 @@ struct ieee80211_bss_conf {
  * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.
  *	This flag is actually used for management frame especially for P2P
  *	frames not being sent at CCK rate in 2GHz band.
- * @IEEE80211_TX_STATUS_EOSP: This packet marks the end of service period,
+ * @ieee80211_tx_status_EOSP: This packet marks the end of service period,
  *	when its status is reported the service period ends. For frames in
  *	an SP that mac80211 transmits, it is already set; for driver frames
  *	the driver may set this flag. It is also used to do the same for
@@ -611,7 +611,7 @@ enum mac80211_tx_info_flags {
 	IEEE80211_TX_CTL_TX_OFFCHAN		= BIT(25),
 	IEEE80211_TX_INTFL_TKIP_MIC_FAILURE	= BIT(26),
 	IEEE80211_TX_CTL_NO_CCK_RATE		= BIT(27),
-	IEEE80211_TX_STATUS_EOSP		= BIT(28),
+	ieee80211_tx_status_EOSP		= BIT(28),
 	IEEE80211_TX_CTL_USE_MINRATE		= BIT(29),
 	IEEE80211_TX_CTL_DONTFRAG		= BIT(30),
 	IEEE80211_TX_CTL_PS_RESPONSE		= BIT(31),
@@ -642,7 +642,7 @@ enum mac80211_tx_control_flags {
 	IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |	      \
 	IEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_NO_PS_BUFFER |    \
 	IEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |		      \
-	IEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)
+	IEEE80211_TX_CTL_STBC | ieee80211_tx_status_EOSP)
 
 /**
  * enum mac80211_rate_control_flags - per-rate flags set by the
@@ -664,7 +664,7 @@ enum mac80211_tx_control_flags {
  * @IEEE80211_TX_RC_80_MHZ_WIDTH: Indicates 80 MHz transmission
  * @IEEE80211_TX_RC_160_MHZ_WIDTH: Indicates 160 MHz transmission
  *	(80+80 isn't supported yet)
- * @IEEE80211_TX_RC_DUP_DATA: The frame should be transmitted on both of the
+ * @IEEE80211_TX_RC_DATA: The frame should be transmitted on both of the
  *	adjacent 20 MHz channels, if the current channel type is
  *	NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.
  * @IEEE80211_TX_RC_SHORT_GI: Short Guard interval should be used for this rate.
@@ -678,7 +678,7 @@ enum mac80211_rate_control_flags {
 	IEEE80211_TX_RC_MCS			= BIT(3),
 	IEEE80211_TX_RC_GREEN_FIELD		= BIT(4),
 	IEEE80211_TX_RC_40_MHZ_WIDTH		= BIT(5),
-	IEEE80211_TX_RC_DUP_DATA		= BIT(6),
+	IEEE80211_TX_RC_DATA		= BIT(6),
 	IEEE80211_TX_RC_SHORT_GI		= BIT(7),
 	IEEE80211_TX_RC_VHT_MCS			= BIT(8),
 	IEEE80211_TX_RC_80_MHZ_WIDTH		= BIT(9),
@@ -1327,7 +1327,7 @@ static inline bool ieee80211_vif_is_mesh
 }
 
 /**
- * wdev_to_ieee80211_vif - return a vif struct from a wdev
+ * wdev_to_ieee80211_vif_dup - return a vif struct from a wdev
  * @wdev: the wdev to get the vif for
  *
  * This can be used by mac80211 drivers with direct cfg80211 APIs
@@ -1337,7 +1337,7 @@ static inline bool ieee80211_vif_is_mesh
  * associated with a vif that the driver knows about (e.g. monitor
  * or AP_VLAN interfaces.)
  */
-struct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev);
+struct ieee80211_vif *wdev_to_ieee80211_vif_dup(struct wireless_dev *wdev);
 
 /**
  * enum ieee80211_key_flags - key flags
@@ -1618,7 +1618,7 @@ struct ieee80211_tx_control {
  *	rely on the host system for such buffering. This option is used
  *	to configure the IEEE 802.11 upper layer to buffer broadcast and
  *	multicast frames when there are power saving stations so that
- *	the driver can fetch them with ieee80211_get_buffered_bc().
+ *	the driver can fetch them with ieee80211_get_buffered_bc_dup().
  *
  * @IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE:
  *	Hardware is not capable of short slot operation on the 2.4 GHz band.
@@ -1795,7 +1795,7 @@ enum ieee80211_hw_flags {
  *
  * @rate_control_algorithm: rate control algorithm for this hardware.
  *	If unset (NULL), the default algorithm will be used. Must be
- *	set before calling ieee80211_register_hw().
+ *	set before calling ieee80211_register_hw_dup().
  *
  * @vif_data_size: size (in bytes) of the drv_priv data area
  *	within &struct ieee80211_vif.
@@ -1920,7 +1920,7 @@ struct ieee80211_tdls_ch_sw_params {
 };
 
 /**
- * wiphy_to_ieee80211_hw - return a mac80211 driver hw struct from a wiphy
+ * wiphy_to_ieee80211_hw_dup - return a mac80211 driver hw struct from a wiphy
  *
  * @wiphy: the &struct wiphy which we want to query
  *
@@ -1932,7 +1932,7 @@ struct ieee80211_tdls_ch_sw_params {
  *
  * Return: The mac80211 driver hw struct of @wiphy.
  */
-struct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy);
+struct ieee80211_hw *wiphy_to_ieee80211_hw_dup(struct wiphy *wiphy);
 
 /**
  * SET_IEEE80211_DEV - set device for 802.11 hardware
@@ -1984,14 +1984,14 @@ ieee80211_get_alt_retry_rate(const struc
 }
 
 /**
- * ieee80211_free_txskb - free TX skb
+ * ieee80211_free_txskb_dup - free TX skb
  * @hw: the hardware
  * @skb: the skb
  *
  * Free a transmit skb. Use this funtion when some failure
  * to transmit happened and thus status cannot be reported.
  */
-void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
+void ieee80211_free_txskb_dup(struct ieee80211_hw *hw, struct sk_buff *skb);
 
 /**
  * DOC: Hardware crypto acceleration
@@ -2119,11 +2119,11 @@ void ieee80211_free_txskb(struct ieee802
  * interface capability. The driver needs to enable beacon filter support
  * whenever power save is enabled, that is %IEEE80211_CONF_PS is set. When
  * power save is enabled, the stack will not check for beacon loss and the
- * driver needs to notify about loss of beacons with ieee80211_beacon_loss().
+ * driver needs to notify about loss of beacons with ieee80211_beacon_loss_dup().
  *
  * The time (or number of beacons missed) until the firmware notifies the
  * driver of a beacon loss event (which in turn causes the driver to call
- * ieee80211_beacon_loss()) should be configurable and will be controlled
+ * ieee80211_beacon_loss_dup()) should be configurable and will be controlled
  * by mac80211 and the roaming algorithm in the future.
  *
  * Since there may be constantly changing information elements that nothing
@@ -2246,7 +2246,7 @@ void ieee80211_free_txskb(struct ieee802
  * driver implementation: %IEEE80211_HW_AP_LINK_PS. If this flag is set,
  * mac80211 expects the driver to handle most of the state machine for
  * powersaving clients and will ignore the PM bit in incoming frames.
- * Drivers then use ieee80211_sta_ps_transition() to inform mac80211 of
+ * Drivers then use ieee80211_sta_ps_transition_dup() to inform mac80211 of
  * stations' powersave transitions. In this mode, mac80211 also doesn't
  * handle PS-Poll/uAPSD.
  *
@@ -2270,7 +2270,7 @@ void ieee80211_free_txskb(struct ieee802
  * callback; this callback is optional. mac80211 will then transmit
  * the frames as usual and set the %IEEE80211_TX_CTL_NO_PS_BUFFER
  * on each frame. The last frame in the service period (or the only
- * response to a PS-Poll) also has %IEEE80211_TX_STATUS_EOSP set to
+ * response to a PS-Poll) also has %ieee80211_tx_status_EOSP set to
  * indicate that it ends the service period; as this frame must have
  * TX status report it also sets %IEEE80211_TX_CTL_REQ_TX_STATUS.
  * When TX status is reported for this frame, the service period is
@@ -2286,13 +2286,13 @@ void ieee80211_free_txskb(struct ieee802
  * processing of the EOSP. The cause is that allowing frames to be
  * transmitted to a certain station is out-of-band communication to
  * the device. To allow this problem to be solved, the driver can
- * call ieee80211_sta_block_awake() if frames are buffered when it
+ * call ieee80211_sta_block_awake_dup() if frames are buffered when it
  * is notified that the station went to sleep. When all these frames
  * have been filtered (see above), it must call the function again
  * to indicate that the station is no longer blocked.
  *
  * If the driver buffers frames in the driver for aggregation in any
- * way, it must use the ieee80211_sta_set_buffered() call when it is
+ * way, it must use the ieee80211_sta_set_buffered_dup() call when it is
  * notified of the station going to sleep to inform mac80211 of any
  * TIDs that have frames buffered. Note that when a station wakes up
  * this information is reset (hence the requirement to call it when
@@ -2311,14 +2311,14 @@ void ieee80211_free_txskb(struct ieee802
  * filter those response frames except in the case of frames that
  * are buffered in the driver -- those must remain buffered to avoid
  * reordering. Because it is possible that no frames are released
- * in this case, the driver must call ieee80211_sta_eosp()
+ * in this case, the driver must call ieee80211_sta_eosp_dup()
  * to indicate to mac80211 that the service period ended anyway.
  *
  * Finally, if frames from multiple TIDs are released from mac80211
  * but the driver might reorder them, it must clear & set the flags
- * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)
+ * appropriately (only the last frame may have %ieee80211_tx_status_EOSP)
  * and also take care of the EOSP and MORE_DATA bits in the frame.
- * The driver may also use ieee80211_sta_eosp() in this case.
+ * The driver may also use ieee80211_sta_eosp_dup() in this case.
  *
  * Note that if the driver ever buffers frames other than QoS-data
  * frames, it must take care to never send a non-QoS-data frame as
@@ -2348,7 +2348,7 @@ void ieee80211_free_txskb(struct ieee802
  * if necessary will queue the frame on the right software queue that mirrors
  * the hardware queue.
  * Additionally, the driver has to then use these HW queue IDs for the queue
- * management functions (ieee80211_stop_queue() et al.)
+ * management functions (ieee80211_stop_queue_dup() et al.)
  *
  * The driver is free to set up the queue mappings as needed, multiple virtual
  * interfaces may map to the same hardware queues if needed. The setup has to
@@ -2439,7 +2439,7 @@ enum ieee80211_filter_flags {
  *
  * Note that drivers MUST be able to deal with a TX aggregation
  * session being stopped even before they OK'ed starting it by
- * calling ieee80211_start_tx_ba_cb_irqsafe, because the peer
+ * calling ieee80211_start_tx_ba_cb_irqsafe_dup, because the peer
  * might receive the addBA frame and send a delBA right away!
  *
  * @IEEE80211_AMPDU_RX_START: start RX aggregation
@@ -2448,13 +2448,13 @@ enum ieee80211_filter_flags {
  * @IEEE80211_AMPDU_TX_OPERATIONAL: TX aggregation has become operational
  * @IEEE80211_AMPDU_TX_STOP_CONT: stop TX aggregation but continue transmitting
  *	queued packets, now unaggregated. After all packets are transmitted the
- *	driver has to call ieee80211_stop_tx_ba_cb_irqsafe().
+ *	driver has to call ieee80211_stop_tx_ba_cb_irqsafe_dup().
  * @IEEE80211_AMPDU_TX_STOP_FLUSH: stop TX aggregation and flush all packets,
  *	called when the station is removed. There's no need or reason to call
- *	ieee80211_stop_tx_ba_cb_irqsafe() in this case as mac80211 assumes the
+ *	ieee80211_stop_tx_ba_cb_irqsafe_dup() in this case as mac80211 assumes the
  *	session is gone and removes the station.
  * @IEEE80211_AMPDU_TX_STOP_FLUSH_CONT: called when TX aggregation is stopped
- *	but the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe() yet and
+ *	but the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe_dup() yet and
  *	now the connection is dropped and the station will be removed. Drivers
  *	should clean up and drop remaining packets when this is called.
  */
@@ -2652,7 +2652,7 @@ enum ieee80211_reconfig_type {
  *	host is suspended, it can assign this callback to retrieve the data
  *	necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
  *	After rekeying was done it should (for example during resume) notify
- *	userspace of the new replay counter using ieee80211_gtk_rekey_notify().
+ *	userspace of the new replay counter using ieee80211_gtk_rekey_notify_dup().
  *
  * @set_default_unicast_key: Set the default (unicast) key index, useful for
  *	WEP when the device sends data packets autonomously, e.g. for ARP
@@ -2667,7 +2667,7 @@ enum ieee80211_reconfig_type {
  *	entire IEs after the SSID, so that drivers need not look at these
  *	at all but just send them after the SSID -- mac80211 includes the
  *	(extended) supported rates and HT information (where applicable).
- *	When the scan finishes, ieee80211_scan_completed() must be called;
+ *	When the scan finishes, ieee80211_scan_completed_dup() must be called;
  *	note that it also must be called when the scan cannot finish due to
  *	any error unless this callback returned a negative error code.
  *	The callback can sleep.
@@ -2675,18 +2675,18 @@ enum ieee80211_reconfig_type {
  * @cancel_hw_scan: Ask the low-level tp cancel the active hw scan.
  *	The driver should ask the hardware to cancel the scan (if possible),
  *	but the scan will be completed only after the driver will call
- *	ieee80211_scan_completed().
+ *	ieee80211_scan_completed_dup().
  *	This callback is needed for wowlan, to prevent enqueueing a new
  *	scan_work after the low-level driver was already suspended.
  *	The callback can sleep.
  *
  * @sched_scan_start: Ask the hardware to start scanning repeatedly at
  *	specific intervals.  The driver must call the
- *	ieee80211_sched_scan_results() function whenever it finds results.
+ *	ieee80211_sched_scan_results_dup() function whenever it finds results.
  *	This process will continue until sched_scan_stop is called.
  *
  * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.
- *	In this case, ieee80211_sched_scan_stopped() must not be called.
+ *	In this case, ieee80211_sched_scan_stopped_dup() must not be called.
  *
  * @sw_scan_start: Notifier function that is called just before a software scan
  *	is started. Can be NULL, if the driver doesn't need this notification.
@@ -2822,7 +2822,7 @@ enum ieee80211_reconfig_type {
  *
  * @rfkill_poll: Poll rfkill hardware state. If you need this, you also
  *	need to set wiphy->rfkill_poll to %true before registration,
- *	and need to call wiphy_rfkill_set_hw_state() in the callback.
+ *	and need to call wiphy_rfkill_set_hw_state_dup() in the callback.
  *	The callback can sleep.
  *
  * @set_coverage_class: Set slot time for given coverage class as specified
@@ -2845,7 +2845,7 @@ enum ieee80211_reconfig_type {
  *
  * @channel_switch: Drivers that need (or want) to offload the channel
  *	switch operation for CSAs received from the AP may implement this
- *	callback. They must then call ieee80211_chswitch_done() to indicate
+ *	callback. They must then call ieee80211_chswitch_done_dup() to indicate
  *	completion of the channel switch.
  *
  * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.
@@ -2856,12 +2856,12 @@ enum ieee80211_reconfig_type {
  * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).
  *
  * @remain_on_channel: Starts an off-channel period on the given channel, must
- *	call back to ieee80211_ready_on_channel() when on that channel. Note
+ *	call back to ieee80211_ready_on_channel_dup() when on that channel. Note
  *	that normal channel traffic is not stopped as this is intended for hw
  *	offload. Frames to transmit on the off-channel channel are transmitted
  *	normally except for the %IEEE80211_TX_CTL_TX_OFFCHAN flag. When the
  *	duration (which will always be non-zero) expires, the driver must call
- *	ieee80211_remain_on_channel_expired().
+ *	ieee80211_remain_on_channel_expired_dup().
  *	Note that this callback may be called while the device is in IDLE and
  *	must be accepted in this case.
  *	This callback may sleep.
@@ -2895,7 +2895,7 @@ enum ieee80211_reconfig_type {
  *	from, for PS-poll it will always have only a single bit set.
  *	In the case this is used for a PS-poll initiated release, the
  *	@num_frames parameter will always be 1 so code can be shared. In
- *	this case the driver must also set %IEEE80211_TX_STATUS_EOSP flag
+ *	this case the driver must also set %ieee80211_tx_status_EOSP flag
  *	on the TX status (and must report TX status) so that the PS-poll
  *	period is properly ended. This is used to avoid sending multiple
  *	responses for a retried PS-poll frame.
@@ -2903,20 +2903,20 @@ enum ieee80211_reconfig_type {
  *	bigger than one, but the driver may send fewer frames (it must send
  *	at least one, however). In this case it is also responsible for
  *	setting the EOSP flag in the QoS header of the frames. Also, when the
- *	service period ends, the driver must set %IEEE80211_TX_STATUS_EOSP
+ *	service period ends, the driver must set %ieee80211_tx_status_EOSP
  *	on the last frame in the SP. Alternatively, it may call the function
- *	ieee80211_sta_eosp() to inform mac80211 of the end of the SP.
+ *	ieee80211_sta_eosp_dup() to inform mac80211 of the end of the SP.
  *	This callback must be atomic.
  * @allow_buffered_frames: Prepare device to allow the given number of frames
  *	to go out to the given station. The frames will be sent by mac80211
  *	via the usual TX path after this call. The TX information for frames
  *	released will also have the %IEEE80211_TX_CTL_NO_PS_BUFFER flag set
- *	and the last one will also have %IEEE80211_TX_STATUS_EOSP set. In case
+ *	and the last one will also have %ieee80211_tx_status_EOSP set. In case
  *	frames from multiple TIDs are released and the driver might reorder
- *	them between the TIDs, it must set the %IEEE80211_TX_STATUS_EOSP flag
+ *	them between the TIDs, it must set the %ieee80211_tx_status_EOSP flag
  *	on the last frame and clear it on all others and also handle the EOSP
  *	bit in the QoS header correctly. Alternatively, it can also call the
- *	ieee80211_sta_eosp() function.
+ *	ieee80211_sta_eosp_dup() function.
  *	The @tids parameter is a bitmap and tells the driver which TIDs the
  *	frames will be on; it will at most have two bits set.
  *	This callback must be atomic.
@@ -2975,7 +2975,7 @@ enum ieee80211_reconfig_type {
  *	disabled/enabled via @bss_info_changed.
  * @stop_ap: Stop operation on the AP interface.
  *
- * @reconfig_complete: Called after a call to ieee80211_restart_hw() and
+ * @reconfig_complete: Called after a call to ieee80211_restart_hw_dup() and
  *	during resume, when the reconfiguration has completed.
  *	This can help the driver implement the reconfiguration step (and
  *	indicate mac80211 is ready to receive frames).
@@ -2989,10 +2989,10 @@ enum ieee80211_reconfig_type {
  *	Beacons are modified to include CSA or ECSA IEs before calling this
  *	function. The corresponding count fields in these IEs must be
  *	decremented, and when they reach 1 the driver must call
- *	ieee80211_csa_finish(). Drivers which use ieee80211_beacon_get()
+ *	ieee80211_csa_finish_dup(). Drivers which use ieee80211_beacon_get()
  *	get the csa counter decremented by mac80211, but must check if it is
- *	1 using ieee80211_csa_is_complete() after the beacon has been
- *	transmitted and then call ieee80211_csa_finish().
+ *	1 using ieee80211_csa_is_complete_dup() after the beacon has been
+ *	transmitted and then call ieee80211_csa_finish_dup().
  *	If the CSA count starts as zero or 1, this function will not be called,
  *	since there won't be any time to beacon before the switch anyway.
  * @pre_channel_switch: This is an optional callback that is called
@@ -3267,7 +3267,7 @@ struct ieee80211_ops {
 };
 
 /**
- * ieee80211_alloc_hw_nm - Allocate a new hardware device
+ * ieee80211_alloc_hw_nm_dup - Allocate a new hardware device
  *
  * This must be called once for each hardware device. The returned pointer
  * must be used to refer to this device when calling other functions.
@@ -3282,7 +3282,7 @@ struct ieee80211_ops {
  *
  * Return: A pointer to the new hardware device, or %NULL on error.
  */
-struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
+struct ieee80211_hw *ieee80211_alloc_hw_nm_dup(size_t priv_data_len,
 					   const struct ieee80211_ops *ops,
 					   const char *requested_name);
 
@@ -3304,11 +3304,11 @@ static inline
 struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,
 					const struct ieee80211_ops *ops)
 {
-	return ieee80211_alloc_hw_nm(priv_data_len, ops, NULL);
+	return ieee80211_alloc_hw_nm_dup(priv_data_len, ops, NULL);
 }
 
 /**
- * ieee80211_register_hw - Register hardware device
+ * ieee80211_register_hw_dup - Register hardware device
  *
  * You must call this function before any other functions in
  * mac80211. Note that before a hardware can be registered, you
@@ -3318,7 +3318,7 @@ struct ieee80211_hw *ieee80211_alloc_hw(
  *
  * Return: 0 on success. An error code otherwise.
  */
-int ieee80211_register_hw(struct ieee80211_hw *hw);
+int ieee80211_register_hw_dup(struct ieee80211_hw *hw);
 
 /**
  * struct ieee80211_tpt_blink - throughput blink description
@@ -3345,11 +3345,11 @@ enum ieee80211_tpt_led_trigger_flags {
 };
 
 #ifdef CONFIG_MAC80211_LEDS
-char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,
+char *__ieee80211_get_tx_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_get_rx_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_get_assoc_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_get_radio_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_create_tpt_led_trigger_dup(struct ieee80211_hw *hw,
 					 unsigned int flags,
 					 const struct ieee80211_tpt_blink *blink_table,
 					 unsigned int blink_table_len);
@@ -3369,7 +3369,7 @@ char *__ieee80211_create_tpt_led_trigger
 static inline char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_tx_led_name(hw);
+	return __ieee80211_get_tx_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3390,7 +3390,7 @@ static inline char *ieee80211_get_tx_led
 static inline char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_rx_led_name(hw);
+	return __ieee80211_get_rx_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3411,7 +3411,7 @@ static inline char *ieee80211_get_rx_led
 static inline char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_assoc_led_name(hw);
+	return __ieee80211_get_assoc_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3432,7 +3432,7 @@ static inline char *ieee80211_get_assoc_
 static inline char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_radio_led_name(hw);
+	return __ieee80211_get_radio_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3448,7 +3448,7 @@ static inline char *ieee80211_get_radio_
  * Return: %NULL (in case of error, or if no LED triggers are
  * configured) or the name of the new trigger.
  *
- * Note: This function must be called before ieee80211_register_hw().
+ * Note: This function must be called before ieee80211_register_hw_dup().
  */
 static inline char *
 ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,
@@ -3456,7 +3456,7 @@ ieee80211_create_tpt_led_trigger(struct
 				 unsigned int blink_table_len)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_create_tpt_led_trigger(hw, flags, blink_table,
+	return __ieee80211_create_tpt_led_trigger_dup(hw, flags, blink_table,
 						  blink_table_len);
 #else
 	return NULL;
@@ -3464,28 +3464,28 @@ ieee80211_create_tpt_led_trigger(struct
 }
 
 /**
- * ieee80211_unregister_hw - Unregister a hardware device
+ * ieee80211_unregister_hw_dup - Unregister a hardware device
  *
  * This function instructs mac80211 to free allocated resources
  * and unregister netdevices from the networking subsystem.
  *
  * @hw: the hardware to unregister
  */
-void ieee80211_unregister_hw(struct ieee80211_hw *hw);
+void ieee80211_unregister_hw_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_free_hw - free hardware descriptor
+ * ieee80211_free_hw_dup - free hardware descriptor
  *
  * This function frees everything that was allocated, including the
- * private data for the driver. You must call ieee80211_unregister_hw()
+ * private data for the driver. You must call ieee80211_unregister_hw_dup()
  * before calling this function.
  *
  * @hw: the hardware to free
  */
-void ieee80211_free_hw(struct ieee80211_hw *hw);
+void ieee80211_free_hw_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_restart_hw - restart hardware completely
+ * ieee80211_restart_hw_dup - restart hardware completely
  *
  * Call this function when the hardware was restarted for some reason
  * (hardware error, ...) and the driver is unable to restore its state
@@ -3496,10 +3496,10 @@ void ieee80211_free_hw(struct ieee80211_
  *
  * @hw: the hardware to restart
  */
-void ieee80211_restart_hw(struct ieee80211_hw *hw);
+void ieee80211_restart_hw_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_napi_add - initialize mac80211 NAPI context
+ * ieee80211_napi_add_dup - initialize mac80211 NAPI context
  * @hw: the hardware to initialize the NAPI context on
  * @napi: the NAPI context to initialize
  * @napi_dev: dummy NAPI netdevice, here to not waste the space if the
@@ -3509,13 +3509,13 @@ void ieee80211_restart_hw(struct ieee802
  *
  * See also netif_napi_add().
  */
-void ieee80211_napi_add(struct ieee80211_hw *hw, struct napi_struct *napi,
+void ieee80211_napi_add_dup(struct ieee80211_hw *hw, struct napi_struct *napi,
 			struct net_device *napi_dev,
 			int (*poll)(struct napi_struct *, int),
 			int weight);
 
 /**
- * ieee80211_rx - receive frame
+ * ieee80211_rx_dup - receive frame
  *
  * Use this function to hand received frames to mac80211. The receive
  * buffer in @skb must start with an IEEE 802.11 header. In case of a
@@ -3525,41 +3525,41 @@ void ieee80211_napi_add(struct ieee80211
  *
  * This function may not be called in IRQ context. Calls to this function
  * for a single hardware must be synchronized against each other. Calls to
- * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be
+ * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe_dup() may not be
  * mixed for a single hardware. Must not run concurrently with
- * ieee80211_tx_status() or ieee80211_tx_status_ni().
+ * ieee80211_tx_status_dup() or ieee80211_tx_status_ni().
  *
  * In process context use instead ieee80211_rx_ni().
  *
  * @hw: the hardware this frame came in on
  * @skb: the buffer to receive, owned by mac80211 after this call
  */
-void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb);
+void ieee80211_rx_dup(struct ieee80211_hw *hw, struct sk_buff *skb);
 
 /**
- * ieee80211_rx_irqsafe - receive frame
+ * ieee80211_rx_irqsafe_dup - receive frame
  *
- * Like ieee80211_rx() but can be called in IRQ context
+ * Like ieee80211_rx_dup() but can be called in IRQ context
  * (internally defers to a tasklet.)
  *
- * Calls to this function, ieee80211_rx() or ieee80211_rx_ni() may not
+ * Calls to this function, ieee80211_rx_dup() or ieee80211_rx_ni() may not
  * be mixed for a single hardware.Must not run concurrently with
- * ieee80211_tx_status() or ieee80211_tx_status_ni().
+ * ieee80211_tx_status_dup() or ieee80211_tx_status_ni().
  *
  * @hw: the hardware this frame came in on
  * @skb: the buffer to receive, owned by mac80211 after this call
  */
-void ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb);
+void ieee80211_rx_irqsafe_dup(struct ieee80211_hw *hw, struct sk_buff *skb);
 
 /**
  * ieee80211_rx_ni - receive frame (in process context)
  *
- * Like ieee80211_rx() but can be called in process context
+ * Like ieee80211_rx_dup() but can be called in process context
  * (internally disables bottom halves).
  *
- * Calls to this function, ieee80211_rx() and ieee80211_rx_irqsafe() may
+ * Calls to this function, ieee80211_rx_dup() and ieee80211_rx_irqsafe_dup() may
  * not be mixed for a single hardware. Must not run concurrently with
- * ieee80211_tx_status() or ieee80211_tx_status_ni().
+ * ieee80211_tx_status_dup() or ieee80211_tx_status_ni().
  *
  * @hw: the hardware this frame came in on
  * @skb: the buffer to receive, owned by mac80211 after this call
@@ -3568,12 +3568,12 @@ static inline void ieee80211_rx_ni(struc
 				   struct sk_buff *skb)
 {
 	local_bh_disable();
-	ieee80211_rx(hw, skb);
+	ieee80211_rx_dup(hw, skb);
 	local_bh_enable();
 }
 
 /**
- * ieee80211_sta_ps_transition - PS transition for connected sta
+ * ieee80211_sta_ps_transition_dup - PS transition for connected sta
  *
  * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS
  * flag set, use this function to inform mac80211 about a connected station
@@ -3589,20 +3589,20 @@ static inline void ieee80211_rx_ni(struc
  *
  * Return: 0 on success. -EINVAL when the requested PS mode is already set.
  */
-int ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start);
+int ieee80211_sta_ps_transition_dup(struct ieee80211_sta *sta, bool start);
 
 /**
  * ieee80211_sta_ps_transition_ni - PS transition for connected sta
  *                                  (in process context)
  *
- * Like ieee80211_sta_ps_transition() but can be called in process context
+ * Like ieee80211_sta_ps_transition_dup() but can be called in process context
  * (internally disables bottom halves). Concurrent call restriction still
  * applies.
  *
  * @sta: currently connected sta
  * @start: start or stop PS
  *
- * Return: Like ieee80211_sta_ps_transition().
+ * Return: Like ieee80211_sta_ps_transition_dup().
  */
 static inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,
 						  bool start)
@@ -3610,7 +3610,7 @@ static inline int ieee80211_sta_ps_trans
 	int ret;
 
 	local_bh_disable();
-	ret = ieee80211_sta_ps_transition(sta, start);
+	ret = ieee80211_sta_ps_transition_dup(sta, start);
 	local_bh_enable();
 
 	return ret;
@@ -3620,10 +3620,10 @@ static inline int ieee80211_sta_ps_trans
  * The TX headroom reserved by mac80211 for its own tx_status functions.
  * This is enough for the radiotap header.
  */
-#define IEEE80211_TX_STATUS_HEADROOM	14
+#define ieee80211_tx_status_HEADROOM	14
 
 /**
- * ieee80211_sta_set_buffered - inform mac80211 about driver-buffered frames
+ * ieee80211_sta_set_buffered_dup - inform mac80211 about driver-buffered frames
  * @sta: &struct ieee80211_sta pointer for the sleeping station
  * @tid: the TID that has buffered frames
  * @buffered: indicates whether or not frames are buffered for this TID
@@ -3650,11 +3650,11 @@ static inline int ieee80211_sta_ps_trans
  * TID to the AC as required instead of keeping track in all drivers that
  * use this API.
  */
-void ieee80211_sta_set_buffered(struct ieee80211_sta *sta,
+void ieee80211_sta_set_buffered_dup(struct ieee80211_sta *sta,
 				u8 tid, bool buffered);
 
 /**
- * ieee80211_get_tx_rates - get the selected transmit rates for a packet
+ * ieee80211_get_tx_rates_dup - get the selected transmit rates for a packet
  *
  * Call this function in a driver with per-packet rate selection support
  * to combine the rate info in the packet tx info with the most recent
@@ -3666,14 +3666,14 @@ void ieee80211_sta_set_buffered(struct i
  * @dest: buffer for extracted rate/retry information
  * @max_rates: maximum number of rates to fetch
  */
-void ieee80211_get_tx_rates(struct ieee80211_vif *vif,
+void ieee80211_get_tx_rates_dup(struct ieee80211_vif *vif,
 			    struct ieee80211_sta *sta,
 			    struct sk_buff *skb,
 			    struct ieee80211_tx_rate *dest,
 			    int max_rates);
 
 /**
- * ieee80211_tx_status - transmit status callback
+ * ieee80211_tx_status_dup - transmit status callback
  *
  * Call this function for all transmitted frames after they have been
  * transmitted. It is permissible to not call this function for
@@ -3681,43 +3681,43 @@ void ieee80211_get_tx_rates(struct ieee8
  *
  * This function may not be called in IRQ context. Calls to this function
  * for a single hardware must be synchronized against each other. Calls
- * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe()
+ * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe_dup()
  * may not be mixed for a single hardware. Must not run concurrently with
- * ieee80211_rx() or ieee80211_rx_ni().
+ * ieee80211_rx_dup() or ieee80211_rx_ni().
  *
  * @hw: the hardware the frame was transmitted by
  * @skb: the frame that was transmitted, owned by mac80211 after this call
  */
-void ieee80211_tx_status(struct ieee80211_hw *hw,
+void ieee80211_tx_status_dup(struct ieee80211_hw *hw,
 			 struct sk_buff *skb);
 
 /**
- * ieee80211_tx_status_noskb - transmit status callback without skb
+ * ieee80211_tx_status_noskb_dup - transmit status callback without skb
  *
- * This function can be used as a replacement for ieee80211_tx_status
+ * This function can be used as a replacement for ieee80211_tx_status_dup
  * in drivers that cannot reliably map tx status information back to
  * specific skbs.
  *
  * Calls to this function for a single hardware must be synchronized
  * against each other. Calls to this function, ieee80211_tx_status_ni()
- * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.
+ * and ieee80211_tx_status_irqsafe_dup() may not be mixed for a single hardware.
  *
  * @hw: the hardware the frame was transmitted by
  * @sta: the receiver station to which this packet is sent
  *	(NULL for multicast packets)
  * @info: tx status information
  */
-void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,
+void ieee80211_tx_status_noskb_dup(struct ieee80211_hw *hw,
 			       struct ieee80211_sta *sta,
 			       struct ieee80211_tx_info *info);
 
 /**
  * ieee80211_tx_status_ni - transmit status callback (in process context)
  *
- * Like ieee80211_tx_status() but can be called in process context.
+ * Like ieee80211_tx_status_dup() but can be called in process context.
  *
- * Calls to this function, ieee80211_tx_status() and
- * ieee80211_tx_status_irqsafe() may not be mixed
+ * Calls to this function, ieee80211_tx_status_dup() and
+ * ieee80211_tx_status_irqsafe_dup() may not be mixed
  * for a single hardware.
  *
  * @hw: the hardware the frame was transmitted by
@@ -3727,27 +3727,27 @@ static inline void ieee80211_tx_status_n
 					  struct sk_buff *skb)
 {
 	local_bh_disable();
-	ieee80211_tx_status(hw, skb);
+	ieee80211_tx_status_dup(hw, skb);
 	local_bh_enable();
 }
 
 /**
- * ieee80211_tx_status_irqsafe - IRQ-safe transmit status callback
+ * ieee80211_tx_status_irqsafe_dup - IRQ-safe transmit status callback
  *
- * Like ieee80211_tx_status() but can be called in IRQ context
+ * Like ieee80211_tx_status_dup() but can be called in IRQ context
  * (internally defers to a tasklet.)
  *
- * Calls to this function, ieee80211_tx_status() and
+ * Calls to this function, ieee80211_tx_status_dup() and
  * ieee80211_tx_status_ni() may not be mixed for a single hardware.
  *
  * @hw: the hardware the frame was transmitted by
  * @skb: the frame that was transmitted, owned by mac80211 after this call
  */
-void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,
+void ieee80211_tx_status_irqsafe_dup(struct ieee80211_hw *hw,
 				 struct sk_buff *skb);
 
 /**
- * ieee80211_report_low_ack - report non-responding station
+ * ieee80211_report_low_ack_dup - report non-responding station
  *
  * When operating in AP-mode, call this function to report a non-responding
  * connected STA.
@@ -3755,7 +3755,7 @@ void ieee80211_tx_status_irqsafe(struct
  * @sta: the non-responding connected sta
  * @num_packets: number of packets sent to @sta without a response
  */
-void ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);
+void ieee80211_report_low_ack_dup(struct ieee80211_sta *sta, u32 num_packets);
 
 #define IEEE80211_MAX_CSA_COUNTERS_NUM 2
 
@@ -3775,7 +3775,7 @@ struct ieee80211_mutable_offsets {
 };
 
 /**
- * ieee80211_beacon_get_template - beacon template generation function
+ * ieee80211_beacon_get_template_dup - beacon template generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @offs: &struct ieee80211_mutable_offsets pointer to struct that will
@@ -3794,12 +3794,12 @@ struct ieee80211_mutable_offsets {
  * Return: The beacon template. %NULL on error.
  */
 struct sk_buff *
-ieee80211_beacon_get_template(struct ieee80211_hw *hw,
+ieee80211_beacon_get_template_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif,
 			      struct ieee80211_mutable_offsets *offs);
 
 /**
- * ieee80211_beacon_get_tim - beacon generation function
+ * ieee80211_beacon_get_tim_dup - beacon generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @tim_offset: pointer to variable that will receive the TIM IE offset.
@@ -3820,7 +3820,7 @@ ieee80211_beacon_get_template(struct iee
  *
  * Return: The beacon template. %NULL on error.
  */
-struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_beacon_get_tim_dup(struct ieee80211_hw *hw,
 					 struct ieee80211_vif *vif,
 					 u16 *tim_offset, u16 *tim_length);
 
@@ -3829,47 +3829,47 @@ struct sk_buff *ieee80211_beacon_get_tim
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
- * See ieee80211_beacon_get_tim().
+ * See ieee80211_beacon_get_tim_dup().
  *
- * Return: See ieee80211_beacon_get_tim().
+ * Return: See ieee80211_beacon_get_tim_dup().
  */
 static inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,
 						   struct ieee80211_vif *vif)
 {
-	return ieee80211_beacon_get_tim(hw, vif, NULL, NULL);
+	return ieee80211_beacon_get_tim_dup(hw, vif, NULL, NULL);
 }
 
 /**
- * ieee80211_csa_update_counter - request mac80211 to decrement the csa counter
+ * ieee80211_csa_update_counter_dup - request mac80211 to decrement the csa counter
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
  * The csa counter should be updated after each beacon transmission.
  * This function is called implicitly when
- * ieee80211_beacon_get/ieee80211_beacon_get_tim are called, however if the
+ * ieee80211_beacon_get/ieee80211_beacon_get_tim_dup are called, however if the
  * beacon frames are generated by the device, the driver should call this
  * function after each beacon transmission to sync mac80211's csa counters.
  *
  * Return: new csa counter value
  */
-u8 ieee80211_csa_update_counter(struct ieee80211_vif *vif);
+u8 ieee80211_csa_update_counter_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_csa_finish - notify mac80211 about channel switch
+ * ieee80211_csa_finish_dup - notify mac80211 about channel switch
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
  * After a channel switch announcement was scheduled and the counter in this
  * announcement hits 1, this function must be called by the driver to
  * notify mac80211 that the channel can be changed.
  */
-void ieee80211_csa_finish(struct ieee80211_vif *vif);
+void ieee80211_csa_finish_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_csa_is_complete - find out if counters reached 1
+ * ieee80211_csa_is_complete_dup - find out if counters reached 1
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
  * This function returns whether the channel switch counters reached zero.
  */
-bool ieee80211_csa_is_complete(struct ieee80211_vif *vif);
+bool ieee80211_csa_is_complete_dup(struct ieee80211_vif *vif);
 
 
 /**
@@ -3888,7 +3888,7 @@ struct sk_buff *ieee80211_proberesp_get(
 					struct ieee80211_vif *vif);
 
 /**
- * ieee80211_pspoll_get - retrieve a PS Poll template
+ * ieee80211_pspoll_get_dup - retrieve a PS Poll template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -3901,11 +3901,11 @@ struct sk_buff *ieee80211_proberesp_get(
  *
  * Return: The PS Poll template. %NULL on error.
  */
-struct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_pspoll_get_dup(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif);
 
 /**
- * ieee80211_nullfunc_get - retrieve a nullfunc template
+ * ieee80211_nullfunc_get_dup - retrieve a nullfunc template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -3918,11 +3918,11 @@ struct sk_buff *ieee80211_pspoll_get(str
  *
  * Return: The nullfunc template. %NULL on error.
  */
-struct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_nullfunc_get_dup(struct ieee80211_hw *hw,
 				       struct ieee80211_vif *vif);
 
 /**
- * ieee80211_probereq_get - retrieve a Probe Request template
+ * ieee80211_probereq_get_dup - retrieve a Probe Request template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @src_addr: source MAC address
  * @ssid: SSID buffer
@@ -3934,13 +3934,13 @@ struct sk_buff *ieee80211_nullfunc_get(s
  *
  * Return: The Probe Request template. %NULL on error.
  */
-struct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_probereq_get_dup(struct ieee80211_hw *hw,
 				       const u8 *src_addr,
 				       const u8 *ssid, size_t ssid_len,
 				       size_t tailroom);
 
 /**
- * ieee80211_rts_get - RTS frame generation function
+ * ieee80211_rts_get_dup - RTS frame generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame: pointer to the frame that is going to be protected by the RTS.
@@ -3953,13 +3953,13 @@ struct sk_buff *ieee80211_probereq_get(s
  * the next RTS frame from the 802.11 code. The low-level is responsible
  * for calling this function before and RTS frame is needed.
  */
-void ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+void ieee80211_rts_get_dup(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		       const void *frame, size_t frame_len,
 		       const struct ieee80211_tx_info *frame_txctl,
 		       struct ieee80211_rts *rts);
 
 /**
- * ieee80211_rts_duration - Get the duration field for an RTS frame
+ * ieee80211_rts_duration_dup - Get the duration field for an RTS frame
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame_len: the length of the frame that is going to be protected by the RTS.
@@ -3971,12 +3971,12 @@ void ieee80211_rts_get(struct ieee80211_
  *
  * Return: The duration.
  */
-__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_rts_duration_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif, size_t frame_len,
 			      const struct ieee80211_tx_info *frame_txctl);
 
 /**
- * ieee80211_ctstoself_get - CTS-to-self frame generation function
+ * ieee80211_ctstoself_get_dup - CTS-to-self frame generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame: pointer to the frame that is going to be protected by the CTS-to-self.
@@ -3989,14 +3989,14 @@ __le16 ieee80211_rts_duration(struct iee
  * the next CTS-to-self frame from the 802.11 code. The low-level is responsible
  * for calling this function before and CTS-to-self frame is needed.
  */
-void ieee80211_ctstoself_get(struct ieee80211_hw *hw,
+void ieee80211_ctstoself_get_dup(struct ieee80211_hw *hw,
 			     struct ieee80211_vif *vif,
 			     const void *frame, size_t frame_len,
 			     const struct ieee80211_tx_info *frame_txctl,
 			     struct ieee80211_cts *cts);
 
 /**
- * ieee80211_ctstoself_duration - Get the duration field for a CTS-to-self frame
+ * ieee80211_ctstoself_duration_dup - Get the duration field for a CTS-to-self frame
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame_len: the length of the frame that is going to be protected by the CTS-to-self.
@@ -4008,13 +4008,13 @@ void ieee80211_ctstoself_get(struct ieee
  *
  * Return: The duration.
  */
-__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_ctstoself_duration_dup(struct ieee80211_hw *hw,
 				    struct ieee80211_vif *vif,
 				    size_t frame_len,
 				    const struct ieee80211_tx_info *frame_txctl);
 
 /**
- * ieee80211_generic_frame_duration - Calculate the duration field for a frame
+ * ieee80211_generic_frame_duration_dup - Calculate the duration field for a frame
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @band: the band to calculate the frame duration on
@@ -4026,14 +4026,14 @@ __le16 ieee80211_ctstoself_duration(stru
  *
  * Return: The duration.
  */
-__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_generic_frame_duration_dup(struct ieee80211_hw *hw,
 					struct ieee80211_vif *vif,
 					enum ieee80211_band band,
 					size_t frame_len,
 					struct ieee80211_rate *rate);
 
 /**
- * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames
+ * ieee80211_get_buffered_bc_dup - accessing buffered broadcast and multicast frames
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4048,16 +4048,16 @@ __le16 ieee80211_generic_frame_duration(
  *
  * Note: buffered frames are returned only after DTIM beacon frame was
  * generated with ieee80211_beacon_get() and the low-level driver must thus
- * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc() returns
+ * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc_dup() returns
  * NULL if the previous generated beacon was not DTIM, so the low-level driver
  * does not need to check for DTIM beacons separately and should be able to
  * use common code for all beacons.
  */
 struct sk_buff *
-ieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+ieee80211_get_buffered_bc_dup(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
 
 /**
- * ieee80211_get_tkip_p1k_iv - get a TKIP phase 1 key for IV32
+ * ieee80211_get_tkip_p1k_iv_dup - get a TKIP phase 1 key for IV32
  *
  * This function returns the TKIP phase 1 key for the given IV32.
  *
@@ -4065,7 +4065,7 @@ ieee80211_get_buffered_bc(struct ieee802
  * @iv32: IV32 to get the P1K for
  * @p1k: a buffer to which the key will be written, as 5 u16 values
  */
-void ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_p1k_iv_dup(struct ieee80211_key_conf *keyconf,
 			       u32 iv32, u16 *p1k);
 
 /**
@@ -4083,14 +4083,14 @@ static inline void ieee80211_get_tkip_p1
 					  struct sk_buff *skb, u16 *p1k)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	const u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);
+	const u8 *data = (u8 *)hdr + ieee80211_hdrlen_dup(hdr->frame_control);
 	u32 iv32 = get_unaligned_le32(&data[4]);
 
-	ieee80211_get_tkip_p1k_iv(keyconf, iv32, p1k);
+	ieee80211_get_tkip_p1k_iv_dup(keyconf, iv32, p1k);
 }
 
 /**
- * ieee80211_get_tkip_rx_p1k - get a TKIP phase 1 key for RX
+ * ieee80211_get_tkip_rx_p1k_dup - get a TKIP phase 1 key for RX
  *
  * This function returns the TKIP phase 1 key for the given IV32
  * and transmitter address.
@@ -4100,11 +4100,11 @@ static inline void ieee80211_get_tkip_p1
  * @iv32: IV32 to get the P1K for
  * @p1k: a buffer to which the key will be written, as 5 u16 values
  */
-void ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_rx_p1k_dup(struct ieee80211_key_conf *keyconf,
 			       const u8 *ta, u32 iv32, u16 *p1k);
 
 /**
- * ieee80211_get_tkip_p2k - get a TKIP phase 2 key
+ * ieee80211_get_tkip_p2k_dup - get a TKIP phase 2 key
  *
  * This function computes the TKIP RC4 key for the IV values
  * in the packet.
@@ -4114,11 +4114,11 @@ void ieee80211_get_tkip_rx_p1k(struct ie
  *	encrypted with this key
  * @p2k: a buffer to which the key will be written, 16 bytes
  */
-void ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_p2k_dup(struct ieee80211_key_conf *keyconf,
 			    struct sk_buff *skb, u8 *p2k);
 
 /**
- * ieee80211_aes_cmac_calculate_k1_k2 - calculate the AES-CMAC sub keys
+ * ieee80211_aes_cmac_calculate_k1_k2_dup - calculate the AES-CMAC sub keys
  *
  * This function computes the two AES-CMAC sub-keys, based on the
  * previously installed master key.
@@ -4127,7 +4127,7 @@ void ieee80211_get_tkip_p2k(struct ieee8
  * @k1: a buffer to be filled with the 1st sub-key
  * @k2: a buffer to be filled with the 2nd sub-key
  */
-void ieee80211_aes_cmac_calculate_k1_k2(struct ieee80211_key_conf *keyconf,
+void ieee80211_aes_cmac_calculate_k1_k2_dup(struct ieee80211_key_conf *keyconf,
 					u8 *k1, u8 *k2);
 
 /**
@@ -4155,7 +4155,7 @@ struct ieee80211_key_seq {
 };
 
 /**
- * ieee80211_get_key_tx_seq - get key TX sequence counter
+ * ieee80211_get_key_tx_seq_dup - get key TX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @seq: buffer to receive the sequence data
@@ -4168,11 +4168,11 @@ struct ieee80211_key_seq {
  * can be done concurrently, for example when queues are stopped
  * and the stop has been synchronized.
  */
-void ieee80211_get_key_tx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_key_tx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_get_key_rx_seq - get key RX sequence counter
+ * ieee80211_get_key_rx_seq_dup - get key RX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @tid: The TID, or -1 for the management frame value (CCMP only);
@@ -4187,11 +4187,11 @@ void ieee80211_get_key_tx_seq(struct iee
  * Note that this function may only be called when no RX processing
  * can be done concurrently.
  */
-void ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_key_rx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      int tid, struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_set_key_tx_seq - set key TX sequence counter
+ * ieee80211_set_key_tx_seq_dup - set key TX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @seq: new sequence data
@@ -4204,11 +4204,11 @@ void ieee80211_get_key_rx_seq(struct iee
  * Note that this function may only be called when no TX processing
  * can be done concurrently.
  */
-void ieee80211_set_key_tx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_set_key_tx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_set_key_rx_seq - set key RX sequence counter
+ * ieee80211_set_key_rx_seq_dup - set key RX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @tid: The TID, or -1 for the management frame value (CCMP only);
@@ -4224,11 +4224,11 @@ void ieee80211_set_key_tx_seq(struct iee
  * Note that this function may only be called when no RX processing
  * can be done concurrently.
  */
-void ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_set_key_rx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      int tid, struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_remove_key - remove the given key
+ * ieee80211_remove_key_dup - remove the given key
  * @keyconf: the parameter passed with the set key
  *
  * Remove the given key. If the key was uploaded to the hardware at the
@@ -4236,12 +4236,12 @@ void ieee80211_set_key_rx_seq(struct iee
  * instead assumed to have been removed already.
  *
  * Note that due to locking considerations this function can (currently)
- * only be called during key iteration (ieee80211_iter_keys().)
+ * only be called during key iteration (ieee80211_iter_keys_dup().)
  */
-void ieee80211_remove_key(struct ieee80211_key_conf *keyconf);
+void ieee80211_remove_key_dup(struct ieee80211_key_conf *keyconf);
 
 /**
- * ieee80211_gtk_rekey_add - add a GTK key from rekeying during WoWLAN
+ * ieee80211_gtk_rekey_add_dup - add a GTK key from rekeying during WoWLAN
  * @vif: the virtual interface to add the key on
  * @keyconf: new key data
  *
@@ -4261,48 +4261,48 @@ void ieee80211_remove_key(struct ieee802
  * the return code 1 to reconfigure the device, this key will be part
  * of the reconfiguration.
  *
- * Note that the driver should also call ieee80211_set_key_rx_seq()
+ * Note that the driver should also call ieee80211_set_key_rx_seq_dup()
  * for the new key for each TID to set up sequence counters properly.
  *
  * IMPORTANT: If this replaces a key that is present in the hardware,
  * then it will attempt to remove it during this call. In many cases
- * this isn't what you want, so call ieee80211_remove_key() first for
+ * this isn't what you want, so call ieee80211_remove_key_dup() first for
  * the key that's being replaced.
  */
 struct ieee80211_key_conf *
-ieee80211_gtk_rekey_add(struct ieee80211_vif *vif,
+ieee80211_gtk_rekey_add_dup(struct ieee80211_vif *vif,
 			struct ieee80211_key_conf *keyconf);
 
 /**
- * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying
+ * ieee80211_gtk_rekey_notify_dup - notify userspace supplicant of rekeying
  * @vif: virtual interface the rekeying was done on
  * @bssid: The BSSID of the AP, for checking association
  * @replay_ctr: the new replay counter after GTK rekeying
  * @gfp: allocation flags
  */
-void ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,
+void ieee80211_gtk_rekey_notify_dup(struct ieee80211_vif *vif, const u8 *bssid,
 				const u8 *replay_ctr, gfp_t gfp);
 
 /**
- * ieee80211_wake_queue - wake specific queue
+ * ieee80211_wake_queue_dup - wake specific queue
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @queue: queue number (counted from zero).
  *
  * Drivers should use this function instead of netif_wake_queue.
  */
-void ieee80211_wake_queue(struct ieee80211_hw *hw, int queue);
+void ieee80211_wake_queue_dup(struct ieee80211_hw *hw, int queue);
 
 /**
- * ieee80211_stop_queue - stop specific queue
+ * ieee80211_stop_queue_dup - stop specific queue
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @queue: queue number (counted from zero).
  *
  * Drivers should use this function instead of netif_stop_queue.
  */
-void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);
+void ieee80211_stop_queue_dup(struct ieee80211_hw *hw, int queue);
 
 /**
- * ieee80211_queue_stopped - test status of the queue
+ * ieee80211_queue_stopped_dup - test status of the queue
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @queue: queue number (counted from zero).
  *
@@ -4311,26 +4311,26 @@ void ieee80211_stop_queue(struct ieee802
  * Return: %true if the queue is stopped. %false otherwise.
  */
 
-int ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);
+int ieee80211_queue_stopped_dup(struct ieee80211_hw *hw, int queue);
 
 /**
- * ieee80211_stop_queues - stop all queues
+ * ieee80211_stop_queues_dup - stop all queues
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  *
  * Drivers should use this function instead of netif_stop_queue.
  */
-void ieee80211_stop_queues(struct ieee80211_hw *hw);
+void ieee80211_stop_queues_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_wake_queues - wake all queues
+ * ieee80211_wake_queues_dup - wake all queues
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  *
  * Drivers should use this function instead of netif_wake_queue.
  */
-void ieee80211_wake_queues(struct ieee80211_hw *hw);
+void ieee80211_wake_queues_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_scan_completed - completed hardware scan
+ * ieee80211_scan_completed_dup - completed hardware scan
  *
  * When hardware scan offload is used (i.e. the hw_scan() callback is
  * assigned) this function needs to be called by the driver to notify
@@ -4340,20 +4340,20 @@ void ieee80211_wake_queues(struct ieee80
  * @hw: the hardware that finished the scan
  * @aborted: set to true if scan was aborted
  */
-void ieee80211_scan_completed(struct ieee80211_hw *hw, bool aborted);
+void ieee80211_scan_completed_dup(struct ieee80211_hw *hw, bool aborted);
 
 /**
- * ieee80211_sched_scan_results - got results from scheduled scan
+ * ieee80211_sched_scan_results_dup - got results from scheduled scan
  *
  * When a scheduled scan is running, this function needs to be called by the
  * driver whenever there are new scan results available.
  *
  * @hw: the hardware that is performing scheduled scans
  */
-void ieee80211_sched_scan_results(struct ieee80211_hw *hw);
+void ieee80211_sched_scan_results_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_sched_scan_stopped - inform that the scheduled scan has stopped
+ * ieee80211_sched_scan_stopped_dup - inform that the scheduled scan has stopped
  *
  * When a scheduled scan is running, this function can be called by
  * the driver if it needs to stop the scan to perform another task.
@@ -4362,7 +4362,7 @@ void ieee80211_sched_scan_results(struct
  *
  * @hw: the hardware that is performing scheduled scans
  */
-void ieee80211_sched_scan_stopped(struct ieee80211_hw *hw);
+void ieee80211_sched_scan_stopped_dup(struct ieee80211_hw *hw);
 
 /**
  * enum ieee80211_interface_iteration_flags - interface iteration flags
@@ -4380,12 +4380,12 @@ enum ieee80211_interface_iteration_flags
 };
 
 /**
- * ieee80211_iterate_active_interfaces - iterate active interfaces
+ * ieee80211_iterate_active_interfaces_dup - iterate active interfaces
  *
  * This function iterates over the interfaces associated with a given
  * hardware that are currently active and calls the callback for them.
  * This function allows the iterator function to sleep, when the iterator
- * function is atomic @ieee80211_iterate_active_interfaces_atomic can
+ * function is atomic @ieee80211_iterate_active_interfaces_atomic_dup can
  * be used.
  * Does not iterate over a new interface during add_interface().
  *
@@ -4394,19 +4394,19 @@ enum ieee80211_interface_iteration_flags
  * @iterator: the iterator function to call
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_active_interfaces(struct ieee80211_hw *hw,
+void ieee80211_iterate_active_interfaces_dup(struct ieee80211_hw *hw,
 					 u32 iter_flags,
 					 void (*iterator)(void *data, u8 *mac,
 						struct ieee80211_vif *vif),
 					 void *data);
 
 /**
- * ieee80211_iterate_active_interfaces_atomic - iterate active interfaces
+ * ieee80211_iterate_active_interfaces_atomic_dup - iterate active interfaces
  *
  * This function iterates over the interfaces associated with a given
  * hardware that are currently active and calls the callback for them.
  * This function requires the iterator callback function to be atomic,
- * if that is not desired, use @ieee80211_iterate_active_interfaces instead.
+ * if that is not desired, use @ieee80211_iterate_active_interfaces_dup instead.
  * Does not iterate over a new interface during add_interface().
  *
  * @hw: the hardware struct of which the interfaces should be iterated over
@@ -4414,7 +4414,7 @@ void ieee80211_iterate_active_interfaces
  * @iterator: the iterator function to call, cannot sleep
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,
+void ieee80211_iterate_active_interfaces_atomic_dup(struct ieee80211_hw *hw,
 						u32 iter_flags,
 						void (*iterator)(void *data,
 						    u8 *mac,
@@ -4422,7 +4422,7 @@ void ieee80211_iterate_active_interfaces
 						void *data);
 
 /**
- * ieee80211_iterate_active_interfaces_rtnl - iterate active interfaces
+ * ieee80211_iterate_active_interfaces_rtnl_dup - iterate active interfaces
  *
  * This function iterates over the interfaces associated with a given
  * hardware that are currently active and calls the callback for them.
@@ -4433,7 +4433,7 @@ void ieee80211_iterate_active_interfaces
  * @iterator: the iterator function to call, cannot sleep
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_active_interfaces_rtnl(struct ieee80211_hw *hw,
+void ieee80211_iterate_active_interfaces_rtnl_dup(struct ieee80211_hw *hw,
 					      u32 iter_flags,
 					      void (*iterator)(void *data,
 						u8 *mac,
@@ -4441,7 +4441,7 @@ void ieee80211_iterate_active_interfaces
 					      void *data);
 
 /**
- * ieee80211_iterate_stations_atomic - iterate stations
+ * ieee80211_iterate_stations_atomic_dup - iterate stations
  *
  * This function iterates over all stations associated with a given
  * hardware that are currently uploaded to the driver and calls the callback
@@ -4452,12 +4452,12 @@ void ieee80211_iterate_active_interfaces
  * @iterator: the iterator function to call, cannot sleep
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,
+void ieee80211_iterate_stations_atomic_dup(struct ieee80211_hw *hw,
 				       void (*iterator)(void *data,
 						struct ieee80211_sta *sta),
 				       void *data);
 /**
- * ieee80211_queue_work - add work onto the mac80211 workqueue
+ * ieee80211_queue_work_dup - add work onto the mac80211 workqueue
  *
  * Drivers and mac80211 use this to add work onto the mac80211 workqueue.
  * This helper ensures drivers are not queueing work when they should not be.
@@ -4465,10 +4465,10 @@ void ieee80211_iterate_stations_atomic(s
  * @hw: the hardware struct for the interface we are adding work for
  * @work: the work we want to add onto the mac80211 workqueue
  */
-void ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);
+void ieee80211_queue_work_dup(struct ieee80211_hw *hw, struct work_struct *work);
 
 /**
- * ieee80211_queue_delayed_work - add work onto the mac80211 workqueue
+ * ieee80211_queue_delayed_work_dup - add work onto the mac80211 workqueue
  *
  * Drivers and mac80211 use this to queue delayed work onto the mac80211
  * workqueue.
@@ -4477,12 +4477,12 @@ void ieee80211_queue_work(struct ieee802
  * @dwork: delayable work to queue onto the mac80211 workqueue
  * @delay: number of jiffies to wait before queueing
  */
-void ieee80211_queue_delayed_work(struct ieee80211_hw *hw,
+void ieee80211_queue_delayed_work_dup(struct ieee80211_hw *hw,
 				  struct delayed_work *dwork,
 				  unsigned long delay);
 
 /**
- * ieee80211_start_tx_ba_session - Start a tx Block Ack session.
+ * ieee80211_start_tx_ba_session_dup - Start a tx Block Ack session.
  * @sta: the station for which to start a BA session
  * @tid: the TID to BA on.
  * @timeout: session timeout value (in TUs)
@@ -4493,11 +4493,11 @@ void ieee80211_queue_delayed_work(struct
  * the need to start aggregation on a certain RA/TID, the session level
  * will be managed by the mac80211.
  */
-int ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,
+int ieee80211_start_tx_ba_session_dup(struct ieee80211_sta *sta, u16 tid,
 				  u16 timeout);
 
 /**
- * ieee80211_start_tx_ba_cb_irqsafe - low level driver ready to aggregate.
+ * ieee80211_start_tx_ba_cb_irqsafe_dup - low level driver ready to aggregate.
  * @vif: &struct ieee80211_vif pointer from the add_interface callback
  * @ra: receiver address of the BA session recipient.
  * @tid: the TID to BA on.
@@ -4506,11 +4506,11 @@ int ieee80211_start_tx_ba_session(struct
  * finished with preparations for the BA session. It can be called
  * from any context.
  */
-void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
+void ieee80211_start_tx_ba_cb_irqsafe_dup(struct ieee80211_vif *vif, const u8 *ra,
 				      u16 tid);
 
 /**
- * ieee80211_stop_tx_ba_session - Stop a Block Ack session.
+ * ieee80211_stop_tx_ba_session_dup - Stop a Block Ack session.
  * @sta: the station whose BA session to stop
  * @tid: the TID to stop BA.
  *
@@ -4520,10 +4520,10 @@ void ieee80211_start_tx_ba_cb_irqsafe(st
  * the need to stop aggregation on a certain RA/TID, the session level
  * will be managed by the mac80211.
  */
-int ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);
+int ieee80211_stop_tx_ba_session_dup(struct ieee80211_sta *sta, u16 tid);
 
 /**
- * ieee80211_stop_tx_ba_cb_irqsafe - low level driver ready to stop aggregate.
+ * ieee80211_stop_tx_ba_cb_irqsafe_dup - low level driver ready to stop aggregate.
  * @vif: &struct ieee80211_vif pointer from the add_interface callback
  * @ra: receiver address of the BA session recipient.
  * @tid: the desired TID to BA on.
@@ -4532,11 +4532,11 @@ int ieee80211_stop_tx_ba_session(struct
  * finished with preparations for the BA session tear down. It
  * can be called from any context.
  */
-void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
+void ieee80211_stop_tx_ba_cb_irqsafe_dup(struct ieee80211_vif *vif, const u8 *ra,
 				     u16 tid);
 
 /**
- * ieee80211_find_sta - find a station
+ * ieee80211_find_sta_dup - find a station
  *
  * @vif: virtual interface to look for station on
  * @addr: station's address
@@ -4546,11 +4546,11 @@ void ieee80211_stop_tx_ba_cb_irqsafe(str
  * Note: This function must be called under RCU lock and the
  * resulting pointer is only valid under RCU lock as well.
  */
-struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,
+struct ieee80211_sta *ieee80211_find_sta_dup(struct ieee80211_vif *vif,
 					 const u8 *addr);
 
 /**
- * ieee80211_find_sta_by_ifaddr - find a station on hardware
+ * ieee80211_find_sta_by_ifaddr_dup - find a station on hardware
  *
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  * @addr: remote station's address
@@ -4571,12 +4571,12 @@ struct ieee80211_sta *ieee80211_find_sta
  *
  * DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.
  */
-struct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,
+struct ieee80211_sta *ieee80211_find_sta_by_ifaddr_dup(struct ieee80211_hw *hw,
 					       const u8 *addr,
 					       const u8 *localaddr);
 
 /**
- * ieee80211_sta_block_awake - block station from waking up
+ * ieee80211_sta_block_awake_dup - block station from waking up
  * @hw: the hardware
  * @pubsta: the station
  * @block: whether to block or unblock
@@ -4604,16 +4604,16 @@ struct ieee80211_sta *ieee80211_find_sta
  * it is unblocked, regardless of whether the station actually
  * woke up while blocked or not.
  */
-void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
+void ieee80211_sta_block_awake_dup(struct ieee80211_hw *hw,
 			       struct ieee80211_sta *pubsta, bool block);
 
 /**
- * ieee80211_sta_eosp - notify mac80211 about end of SP
+ * ieee80211_sta_eosp_dup - notify mac80211 about end of SP
  * @pubsta: the station
  *
  * When a device transmits frames in a way that it can't tell
  * mac80211 in the TX status about the EOSP, it must clear the
- * %IEEE80211_TX_STATUS_EOSP bit and call this function instead.
+ * %ieee80211_tx_status_EOSP bit and call this function instead.
  * This applies for PS-Poll as well as uAPSD.
  *
  * Note that just like with _tx_status() and _rx() drivers must
@@ -4626,10 +4626,10 @@ void ieee80211_sta_block_awake(struct ie
  *     you'd need the _irqsafe version, look at the git history
  *     and restore the _irqsafe version!
  */
-void ieee80211_sta_eosp(struct ieee80211_sta *pubsta);
+void ieee80211_sta_eosp_dup(struct ieee80211_sta *pubsta);
 
 /**
- * ieee80211_iter_keys - iterate keys programmed into the device
+ * ieee80211_iter_keys_dup - iterate keys programmed into the device
  * @hw: pointer obtained from ieee80211_alloc_hw()
  * @vif: virtual interface to iterate, may be %NULL for all
  * @iter: iterator function that will be called for each key
@@ -4646,7 +4646,7 @@ void ieee80211_sta_eosp(struct ieee80211
  * in which they were originally installed and handed to the
  * set_key callback.
  */
-void ieee80211_iter_keys(struct ieee80211_hw *hw,
+void ieee80211_iter_keys_dup(struct ieee80211_hw *hw,
 			 struct ieee80211_vif *vif,
 			 void (*iter)(struct ieee80211_hw *hw,
 				      struct ieee80211_vif *vif,
@@ -4656,7 +4656,7 @@ void ieee80211_iter_keys(struct ieee8021
 			 void *iter_data);
 
 /**
- * ieee80211_iter_chan_contexts_atomic - iterate channel contexts
+ * ieee80211_iter_chan_contexts_atomic_dup - iterate channel contexts
  * @hw: pointre obtained from ieee80211_alloc_hw().
  * @iter: iterator function
  * @iter_data: data passed to iterator function
@@ -4674,7 +4674,7 @@ void ieee80211_iter_keys(struct ieee8021
  * found while iterating, whether they've been re-added already
  * or not.
  */
-void ieee80211_iter_chan_contexts_atomic(
+void ieee80211_iter_chan_contexts_atomic_dup(
 	struct ieee80211_hw *hw,
 	void (*iter)(struct ieee80211_hw *hw,
 		     struct ieee80211_chanctx_conf *chanctx_conf,
@@ -4682,7 +4682,7 @@ void ieee80211_iter_chan_contexts_atomic
 	void *iter_data);
 
 /**
- * ieee80211_ap_probereq_get - retrieve a Probe Request template
+ * ieee80211_ap_probereq_get_dup - retrieve a Probe Request template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4695,11 +4695,11 @@ void ieee80211_iter_chan_contexts_atomic
  *
  * Return: The Probe Request template. %NULL on error.
  */
-struct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_ap_probereq_get_dup(struct ieee80211_hw *hw,
 					  struct ieee80211_vif *vif);
 
 /**
- * ieee80211_beacon_loss - inform hardware does not receive beacons
+ * ieee80211_beacon_loss_dup - inform hardware does not receive beacons
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4707,10 +4707,10 @@ struct sk_buff *ieee80211_ap_probereq_ge
  * %IEEE80211_CONF_PS is set, the driver needs to inform whenever the
  * hardware is not receiving beacons with this function.
  */
-void ieee80211_beacon_loss(struct ieee80211_vif *vif);
+void ieee80211_beacon_loss_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_connection_loss - inform hardware has lost connection to the AP
+ * ieee80211_connection_loss_dup - inform hardware has lost connection to the AP
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4723,10 +4723,10 @@ void ieee80211_beacon_loss(struct ieee80
  * This function will cause immediate change to disassociated state,
  * without connection recovery attempts.
  */
-void ieee80211_connection_loss(struct ieee80211_vif *vif);
+void ieee80211_connection_loss_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_resume_disconnect - disconnect from AP after resume
+ * ieee80211_resume_disconnect_dup - disconnect from AP after resume
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4746,10 +4746,10 @@ void ieee80211_connection_loss(struct ie
  * calls this function, or at least not any locks it needs in the
  * key configuration paths (if it supports HW crypto).
  */
-void ieee80211_resume_disconnect(struct ieee80211_vif *vif);
+void ieee80211_resume_disconnect_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_cqm_rssi_notify - inform a configured connection quality monitoring
+ * ieee80211_cqm_rssi_notify_dup - inform a configured connection quality monitoring
  *	rssi threshold triggered
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
@@ -4760,37 +4760,37 @@ void ieee80211_resume_disconnect(struct
  * monitoring is configured with an rssi threshold, the driver will inform
  * whenever the rssi level reaches the threshold.
  */
-void ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,
+void ieee80211_cqm_rssi_notify_dup(struct ieee80211_vif *vif,
 			       enum nl80211_cqm_rssi_threshold_event rssi_event,
 			       gfp_t gfp);
 
 /**
- * ieee80211_cqm_beacon_loss_notify - inform CQM of beacon loss
+ * ieee80211_cqm_beacon_loss_notify_dup - inform CQM of beacon loss
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @gfp: context flags
  */
-void ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp);
+void ieee80211_cqm_beacon_loss_notify_dup(struct ieee80211_vif *vif, gfp_t gfp);
 
 /**
- * ieee80211_radar_detected - inform that a radar was detected
+ * ieee80211_radar_detected_dup - inform that a radar was detected
  *
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  */
-void ieee80211_radar_detected(struct ieee80211_hw *hw);
+void ieee80211_radar_detected_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_chswitch_done - Complete channel switch process
+ * ieee80211_chswitch_done_dup - Complete channel switch process
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @success: make the channel switch successful or not
  *
  * Complete the channel switch post-process: set the new operational channel
  * and wake up the suspended queues.
  */
-void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success);
+void ieee80211_chswitch_done_dup(struct ieee80211_vif *vif, bool success);
 
 /**
- * ieee80211_request_smps - request SM PS transition
+ * ieee80211_request_smps_dup - request SM PS transition
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @smps_mode: new SM PS mode
  *
@@ -4798,23 +4798,23 @@ void ieee80211_chswitch_done(struct ieee
  * mode. This is useful when the driver has more information than
  * the stack about possible interference, for example by bluetooth.
  */
-void ieee80211_request_smps(struct ieee80211_vif *vif,
+void ieee80211_request_smps_dup(struct ieee80211_vif *vif,
 			    enum ieee80211_smps_mode smps_mode);
 
 /**
- * ieee80211_ready_on_channel - notification of remain-on-channel start
+ * ieee80211_ready_on_channel_dup - notification of remain-on-channel start
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  */
-void ieee80211_ready_on_channel(struct ieee80211_hw *hw);
+void ieee80211_ready_on_channel_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_remain_on_channel_expired - remain_on_channel duration expired
+ * ieee80211_remain_on_channel_expired_dup - remain_on_channel duration expired
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  */
-void ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw);
+void ieee80211_remain_on_channel_expired_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_stop_rx_ba_session - callback to stop existing BA sessions
+ * ieee80211_stop_rx_ba_session_dup - callback to stop existing BA sessions
  *
  * in order not to harm the system performance and user experience, the device
  * may request not to allow any rx ba session and tear down existing rx ba
@@ -4827,11 +4827,11 @@ void ieee80211_remain_on_channel_expired
  * @ba_rx_bitmap: Bit map of open rx ba per tid
  * @addr: & to bssid mac address
  */
-void ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
+void ieee80211_stop_rx_ba_session_dup(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
 				  const u8 *addr);
 
 /**
- * ieee80211_send_bar - send a BlockAckReq frame
+ * ieee80211_send_bar_dup - send a BlockAckReq frame
  *
  * can be used to flush pending frames from the peer's aggregation reorder
  * buffer.
@@ -4841,10 +4841,10 @@ void ieee80211_stop_rx_ba_session(struct
  * @tid: the TID of the aggregation session
  * @ssn: the new starting sequence number for the receiver
  */
-void ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);
+void ieee80211_send_bar_dup(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);
 
 /**
- * ieee80211_start_rx_ba_session_offl - start a Rx BA session
+ * ieee80211_start_rx_ba_session_offl_dup - start a Rx BA session
  *
  * Some device drivers may offload part of the Rx aggregation flow including
  * AddBa/DelBa negotiation but may otherwise be incapable of full Rx
@@ -4857,11 +4857,11 @@ void ieee80211_send_bar(struct ieee80211
  * @addr: station mac address
  * @tid: the rx tid
  */
-void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,
+void ieee80211_start_rx_ba_session_offl_dup(struct ieee80211_vif *vif,
 					const u8 *addr, u16 tid);
 
 /**
- * ieee80211_stop_rx_ba_session_offl - stop a Rx BA session
+ * ieee80211_stop_rx_ba_session_offl_dup - stop a Rx BA session
  *
  * Some device drivers may offload part of the Rx aggregation flow including
  * AddBa/DelBa negotiation but may otherwise be incapable of full Rx
@@ -4874,7 +4874,7 @@ void ieee80211_start_rx_ba_session_offl(
  * @addr: station mac address
  * @tid: the rx tid
  */
-void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,
+void ieee80211_stop_rx_ba_session_offl_dup(struct ieee80211_vif *vif,
 				       const u8 *addr, u16 tid);
 
 /* Rate control API */
@@ -4955,7 +4955,7 @@ static inline int rate_supported(struct
 }
 
 /**
- * rate_control_send_low - helper for drivers for management/no-ack frames
+ * rate_control_send_low_dup - helper for drivers for management/no-ack frames
  *
  * Rate control algorithms that agree to use the lowest rate to
  * send management frames and NO_ACK data with the respective hw
@@ -4972,7 +4972,7 @@ static inline int rate_supported(struct
  * @priv_sta: private rate control structure. This may be null.
  * @txrc: rate control information we sholud populate for mac80211.
  */
-bool rate_control_send_low(struct ieee80211_sta *sta,
+bool rate_control_send_low_dup(struct ieee80211_sta *sta,
 			   void *priv_sta,
 			   struct ieee80211_tx_rate_control *txrc);
 
@@ -5007,7 +5007,7 @@ bool rate_usable_index_exists(struct iee
 }
 
 /**
- * rate_control_set_rates - pass the sta rate selection to mac80211/driver
+ * rate_control_set_rates_dup - pass the sta rate selection to mac80211/driver
  *
  * When not doing a rate control probe to test rates, rate control should pass
  * its rate selection to mac80211. If the driver supports receiving a station
@@ -5018,12 +5018,12 @@ bool rate_usable_index_exists(struct iee
  * @pubsta: &struct ieee80211_sta pointer to the target destination.
  * @rates: new tx rate set to be used for this station.
  */
-int rate_control_set_rates(struct ieee80211_hw *hw,
+int rate_control_set_rates_dup(struct ieee80211_hw *hw,
 			   struct ieee80211_sta *pubsta,
 			   struct ieee80211_sta_rates *rates);
 
-int ieee80211_rate_control_register(const struct rate_control_ops *ops);
-void ieee80211_rate_control_unregister(const struct rate_control_ops *ops);
+int ieee80211_rate_control_register_dup(const struct rate_control_ops *ops);
+void ieee80211_rate_control_unregister_dup(const struct rate_control_ops *ops);
 
 static inline bool
 conf_is_ht20(struct ieee80211_conf *conf)
@@ -5081,14 +5081,14 @@ ieee80211_vif_type_p2p(struct ieee80211_
 	return ieee80211_iftype_p2p(vif->type, vif->p2p);
 }
 
-void ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,
+void ieee80211_enable_rssi_reports_dup(struct ieee80211_vif *vif,
 				   int rssi_min_thold,
 				   int rssi_max_thold);
 
-void ieee80211_disable_rssi_reports(struct ieee80211_vif *vif);
+void ieee80211_disable_rssi_reports_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_ave_rssi - report the average RSSI for the specified interface
+ * ieee80211_ave_rssi_dup - report the average RSSI for the specified interface
  *
  * @vif: the specified virtual interface
  *
@@ -5097,22 +5097,22 @@ void ieee80211_disable_rssi_reports(stru
  * Return: The average RSSI value for the requested interface, or 0 if not
  * applicable.
  */
-int ieee80211_ave_rssi(struct ieee80211_vif *vif);
+int ieee80211_ave_rssi_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_report_wowlan_wakeup - report WoWLAN wakeup
+ * ieee80211_report_wowlan_wakeup_dup - report WoWLAN wakeup
  * @vif: virtual interface
  * @wakeup: wakeup reason(s)
  * @gfp: allocation flags
  *
- * See cfg80211_report_wowlan_wakeup().
+ * See cfg80211_report_wowlan_wakeup_dup().
  */
-void ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,
+void ieee80211_report_wowlan_wakeup_dup(struct ieee80211_vif *vif,
 				    struct cfg80211_wowlan_wakeup *wakeup,
 				    gfp_t gfp);
 
 /**
- * ieee80211_tx_prepare_skb - prepare an 802.11 skb for transmission
+ * ieee80211_tx_prepare_skb_dup - prepare an 802.11 skb for transmission
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  * @vif: virtual interface
  * @skb: frame to be sent from within the driver
@@ -5121,7 +5121,7 @@ void ieee80211_report_wowlan_wakeup(stru
  *
  * Note: must be called under RCU lock
  */
-bool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,
+bool ieee80211_tx_prepare_skb_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif, struct sk_buff *skb,
 			      int band, struct ieee80211_sta **sta);
 
@@ -5153,7 +5153,7 @@ struct ieee80211_noa_data {
 };
 
 /**
- * ieee80211_parse_p2p_noa - initialize NoA tracking data from P2P IE
+ * ieee80211_parse_p2p_noa_dup - initialize NoA tracking data from P2P IE
  *
  * @attr: P2P NoA IE
  * @data: NoA tracking data
@@ -5161,16 +5161,16 @@ struct ieee80211_noa_data {
  *
  * Return: number of successfully parsed descriptors
  */
-int ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,
+int ieee80211_parse_p2p_noa_dup(const struct ieee80211_p2p_noa_attr *attr,
 			    struct ieee80211_noa_data *data, u32 tsf);
 
 /**
- * ieee80211_update_p2p_noa - get next pending P2P GO absent state change
+ * ieee80211_update_p2p_noa_dup - get next pending P2P GO absent state change
  *
  * @data: NoA tracking data
  * @tsf: current TSF timestamp
  */
-void ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);
+void ieee80211_update_p2p_noa_dup(struct ieee80211_noa_data *data, u32 tsf);
 
 /**
  * ieee80211_tdls_oper - request userspace to perform a TDLS operation
@@ -5180,14 +5180,14 @@ void ieee80211_update_p2p_noa(struct iee
  * @reason_code: reason code for the operation, valid for TDLS teardown
  * @gfp: allocation flags
  *
- * See cfg80211_tdls_oper_request().
+ * See cfg80211_tdls_oper_request_dup().
  */
 void ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,
 				 enum nl80211_tdls_operation oper,
 				 u16 reason_code, gfp_t gfp);
 
 /**
- * ieee80211_reserve_tid - request to reserve a specific TID
+ * ieee80211_reserve_tid_dup - request to reserve a specific TID
  *
  * There is sometimes a need (such as in TDLS) for blocking the driver from
  * using a specific TID so that the FW can use it for certain operations such
@@ -5205,10 +5205,10 @@ void ieee80211_tdls_oper_request(struct
  *
  * Returns: 0 on success, else on failure
  */
-int ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid);
+int ieee80211_reserve_tid_dup(struct ieee80211_sta *sta, u8 tid);
 
 /**
- * ieee80211_unreserve_tid - request to unreserve a specific TID
+ * ieee80211_unreserve_tid_dup - request to unreserve a specific TID
  *
  * Once there is no longer any need for reserving a certain TID, this function
  * should be called, and no longer will packets have their TID modified for
@@ -5221,10 +5221,10 @@ int ieee80211_reserve_tid(struct ieee802
  * @sta: the station
  * @tid: the TID to unreserve
  */
-void ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);
+void ieee80211_unreserve_tid_dup(struct ieee80211_sta *sta, u8 tid);
 
 /**
- * ieee80211_ie_split - split an IE buffer according to ordering
+ * ieee80211_ie_split_dup - split an IE buffer according to ordering
  *
  * @ies: the IE buffer
  * @ielen: the length of the IE buffer
@@ -5248,6 +5248,6 @@ void ieee80211_unreserve_tid(struct ieee
  * buffer starts, which may be @ielen if the entire (remainder)
  * of the buffer should be used.
  */
-size_t ieee80211_ie_split(const u8 *ies, size_t ielen,
+size_t ieee80211_ie_split_dup(const u8 *ies, size_t ielen,
 			  const u8 *ids, int n_ids, size_t offset);
 #endif /* MAC80211_H */
--- a/include/net/regulatory.h	2015-06-23 11:07:42.675848940 +0200
+++ b/include/net/regulatory.h	2015-06-23 16:42:02.064819187 +0200
@@ -94,10 +94,10 @@ struct regulatory_request {
  *	ISO / IEC 3166 alpha2 it belongs to. When this is enabled
  *	we will disregard the first regulatory hint (when the
  *	initiator is %REGDOM_SET_BY_CORE). Drivers that use
- *	wiphy_apply_custom_regulatory() should have this flag set
+ *	wiphy_apply_custom_regulatory_dup() should have this flag set
  *	or the regulatory core will set it for the wiphy.
- *	If you use regulatory_hint() *after* using
- *	wiphy_apply_custom_regulatory() the wireless core will
+ *	If you use regulatory_hint_dup() *after* using
+ *	wiphy_apply_custom_regulatory_dup() the wireless core will
  *	clear the REGULATORY_CUSTOM_REG for your wiphy as it would be
  *	implied that the device somehow gained knowledge of its region.
  * @REGULATORY_STRICT_REG: tells us that the wiphy for this device
@@ -111,8 +111,8 @@ struct regulatory_request {
  *	has these channels enabled would enable them for this wiphy,
  *	the device's original regulatory domain will be trusted as the
  *	base. You can program the superset of regulatory rules for this
- *	wiphy with regulatory_hint() for cards programmed with an
- *	ISO3166-alpha2 country code. wiphys that use regulatory_hint()
+ *	wiphy with regulatory_hint_dup() for cards programmed with an
+ *	ISO3166-alpha2 country code. wiphys that use regulatory_hint_dup()
  *	will have their wiphy->regd programmed once the regulatory
  *	domain is set, and all other regulatory hints will be ignored
  *	until their own regulatory domain gets programmed.
--- a/include/net/cfg80211.h	2015-07-21 19:24:11.754130831 +0200
+++ b/include/net/cfg80211.h	2015-07-21 19:24:26.480130471 +0200
@@ -3130,7 +3130,7 @@ struct wiphy {
 
 	u16 max_acl_mac_addrs;
 
-	u32 flags, regulatory_flags, features;
+	u32 flags, features;
 
 	u32 ap_sme_capa;
 
@@ -3156,8 +3156,10 @@ struct wiphy {
 	u32 hw_version;
 
 #ifdef CONFIG_PM
+	union {
+	struct wiphy_wowlan_support wowlan_dummy;
 	const struct wiphy_wowlan_support *wowlan;
-	struct cfg80211_wowlan *wowlan_config;
+	};
 #endif
 
 	u16 max_remain_on_channel_duration;
@@ -3227,6 +3229,11 @@ struct wiphy {
 	u8 max_num_csa_counters;
 	u8 max_adj_channel_rssi_comp;
 
+#ifdef CONFIG_PM
+	struct cfg80211_wowlan *wowlan_config;
+#endif
+	u32 regulatory_flags;
+
 	char priv[0] __aligned(NETDEV_ALIGN);
 };
 
@@ -3437,6 +3444,8 @@ struct wireless_dev {
 
 	struct mutex mtx;
 
+	struct work_struct cleanup_work;
+
 	bool use_4addr, p2p_started;
 
 	u8 address[ETH_ALEN] __aligned(sizeof(u16));
@@ -3444,6 +3453,12 @@ struct wireless_dev {
 	/* currently used for IBSS and SME - might be rearranged later */
 	u8 ssid[IEEE80211_MAX_SSID_LEN];
 	u8 ssid_len, mesh_id_len, mesh_id_up_len;
+       enum {
+               CFG80211_SME_IDLE,
+               CFG80211_SME_CONNECTING,
+               CFG80211_SME_CONNECTED,
+       } sme_state;
+
 	struct cfg80211_conn *conn;
 	struct cfg80211_cached_keys *connect_keys;
 
@@ -3452,10 +3467,9 @@ struct wireless_dev {
 
 	struct cfg80211_internal_bss *current_bss; /* associated / joined */
 	struct cfg80211_chan_def preset_chandef;
-	struct cfg80211_chan_def chandef;
+	struct ieee80211_channel *channel;
 
 	bool ibss_fixed;
-	bool ibss_dfs_possible;
 
 	bool ps;
 	int ps_timeout;
@@ -3466,9 +3480,6 @@ struct wireless_dev {
 
 	bool cac_started;
 	unsigned long cac_start_time;
-	unsigned int cac_time_ms;
-
-	u32 owner_nlportid;
 
 #ifdef CONFIG_CFG80211_WEXT
 	/* wext data */
@@ -3484,6 +3495,12 @@ struct wireless_dev {
 		bool prev_bssid_valid;
 	} wext;
 #endif
+
+	bool ibss_dfs_possible;
+	struct cfg80211_chan_def chandef;
+	unsigned int cac_time_ms;
+	u32 owner_nlportid;
+
 };
 
 static inline u8 *wdev_address(struct wireless_dev *wdev)

